{"ast":null,"code":"// $setWindowFields -  https://docs.mongodb.com/manual/reference/operator/aggregation/setWindowFields/\nimport { getOperator, initOptions, OperatorType } from \"../../core\";\nimport { compose, Lazy } from \"../../lazy\";\nimport { assert, isNumber, isOperator, isString } from \"../../util\";\nimport { $function } from \"../expression/custom/function\";\nimport { $dateAdd } from \"../expression/date/dateAdd\";\nimport { isUnbounded } from \"./_internal\";\nimport { $addFields } from \"./addFields\";\nimport { $group } from \"./group\";\nimport { $sort } from \"./sort\";\n// Operators that require 'sortBy' option.\nconst SORT_REQUIRED_OPS = new Set([\"$denseRank\", \"$documentNumber\", \"$first\", \"$last\", \"$linearFill\", \"$rank\", \"$shift\"]);\n// Operators that require unbounded 'window' option.\nconst WINDOW_UNBOUNDED_OPS = new Set([\"$denseRank\", \"$expMovingAvg\", \"$linearFill\", \"$locf\", \"$rank\", \"$shift\"]);\n/**\n * Randomly selects the specified number of documents from its input. The given iterator must have finite values\n *\n * @param  {Iterator} collection\n * @param  {Object} expr\n * @param  {Options} options\n * @return {*}\n */\nexport const $setWindowFields = (collection, expr, options) => {\n  options = initOptions(options);\n  options.context.addExpressionOps({\n    $function\n  });\n  // validate inputs early since this can be an expensive operation.\n  for (const outputExpr of Object.values(expr.output)) {\n    const keys = Object.keys(outputExpr);\n    const op = keys.find(isOperator);\n    assert(!!getOperator(OperatorType.WINDOW, op, options) || !!getOperator(OperatorType.ACCUMULATOR, op, options), `'${op}' is not a valid window operator`);\n    assert(keys.length > 0 && keys.length <= 2 && (keys.length == 1 || keys.includes(\"window\")), \"'output' option should have a single window operator.\");\n    if (outputExpr === null || outputExpr === void 0 ? void 0 : outputExpr.window) {\n      const {\n        documents,\n        range\n      } = outputExpr.window;\n      assert(!!documents && !range || !documents && !!range || !documents && !range, \"'window' option supports only one of 'documents' or 'range'.\");\n    }\n  }\n  // we sort first if required\n  if (expr.sortBy) {\n    collection = $sort(collection, expr.sortBy, options);\n  }\n  // then partition collection\n  collection = $group(collection, {\n    _id: expr.partitionBy,\n    items: {\n      $push: \"$$CURRENT\"\n    }\n  }, options);\n  // transform values\n  return collection.transform(partitions => {\n    // let iteratorIndex = 0;\n    const iterators = [];\n    const outputConfig = [];\n    for (const [field, outputExpr] of Object.entries(expr.output)) {\n      const op = Object.keys(outputExpr).find(isOperator);\n      const config = {\n        operatorName: op,\n        func: {\n          left: getOperator(OperatorType.ACCUMULATOR, op, options),\n          right: getOperator(OperatorType.WINDOW, op, options)\n        },\n        args: outputExpr[op],\n        field: field,\n        window: outputExpr.window\n      };\n      // sortBy option required for specific operators or bounded window.\n      assert(!!expr.sortBy || !(SORT_REQUIRED_OPS.has(op) || !config.window), `${SORT_REQUIRED_OPS.has(op) ? `'${op}'` : \"bounded window operation\"} requires a sortBy.`);\n      // window must be unbounded for specific operators.\n      assert(!config.window || !WINDOW_UNBOUNDED_OPS.has(op), `${op} does not accept a 'window' field.`);\n      outputConfig.push(config);\n    }\n    // each parition maintains its own closure to process the documents in the window.\n    partitions.forEach(group => {\n      // get the items to process\n      const items = group.items;\n      // create an iterator per group.\n      // we need the index of each document so we track it using a special field.\n      let iterator = Lazy(items);\n      // results map\n      const windowResultMap = {};\n      for (const config of outputConfig) {\n        const {\n          func,\n          args,\n          field,\n          window\n        } = config;\n        const makeResultFunc = getItemsFn => {\n          // closure for object index within the partition\n          let index = -1;\n          return obj => {\n            ++index;\n            // process accumulator function\n            if (func.left) {\n              return func.left(getItemsFn(obj, index), args, options);\n            } else if (func.right) {\n              // OR process 'window' function\n              return func.right(obj, getItemsFn(obj, index), {\n                parentExpr: expr,\n                inputExpr: args,\n                documentNumber: index + 1,\n                field\n              },\n              // must use raw options only since it operates over a collection.\n              options);\n            }\n          };\n        };\n        if (window) {\n          const {\n            documents,\n            range,\n            unit\n          } = window;\n          // TODO: fix the meaning of numeric values in range.\n          //  See definition: https://www.mongodb.com/docs/manual/reference/operator/aggregation/setWindowFields/#std-label-setWindowFields-range\n          //  - A number to add to the value of the sortBy field for the current document.\n          //  - A document is in the window if the sortBy field value is inclusively within the lower and upper boundaries.\n          // TODO: Need to reconcile the two above statments from the doc to implement 'range' option correctly.\n          const boundary = documents || range;\n          if (!isUnbounded(window)) {\n            const [begin, end] = boundary;\n            const toBeginIndex = currentIndex => {\n              if (begin == \"current\") return currentIndex;\n              if (begin == \"unbounded\") return 0;\n              return Math.max(begin + currentIndex, 0);\n            };\n            const toEndIndex = currentIndex => {\n              if (end == \"current\") return currentIndex + 1;\n              if (end == \"unbounded\") return items.length;\n              return end + currentIndex + 1;\n            };\n            const getItems = (current, index) => {\n              // handle string boundaries or documents\n              if (!!documents || boundary.every(isString)) {\n                return items.slice(toBeginIndex(index), toEndIndex(index));\n              }\n              // handle range with numeric boundary values\n              const sortKey = Object.keys(expr.sortBy)[0];\n              let lower;\n              let upper;\n              if (unit) {\n                // we are dealing with datetimes\n                const getTime = amount => {\n                  return $dateAdd(current, {\n                    startDate: new Date(current[sortKey]),\n                    unit,\n                    amount\n                  }, options).getTime();\n                };\n                lower = isNumber(begin) ? getTime(begin) : -Infinity;\n                upper = isNumber(end) ? getTime(end) : Infinity;\n              } else {\n                const currentValue = current[sortKey];\n                lower = isNumber(begin) ? currentValue + begin : -Infinity;\n                upper = isNumber(end) ? currentValue + end : Infinity;\n              }\n              let array = items;\n              if (begin == \"current\") array = items.slice(index);\n              if (end == \"current\") array = items.slice(0, index + 1);\n              // look within the boundary and filter down\n              return array.filter(o => {\n                const n = +o[sortKey];\n                return n >= lower && n <= upper;\n              });\n            };\n            windowResultMap[field] = makeResultFunc(getItems);\n          }\n        }\n        // default action is to utilize the entire set of items\n        if (!windowResultMap[field]) {\n          windowResultMap[field] = makeResultFunc(_ => items);\n        }\n        // invoke add fields to get the desired behaviour using a custom function.\n        iterator = $addFields(iterator, {\n          [field]: {\n            $function: {\n              body: obj => windowResultMap[field](obj),\n              args: [\"$$CURRENT\"]\n            }\n          }\n        }, options);\n      }\n      // add to iterator list\n      iterators.push(iterator);\n    });\n    return compose(...iterators);\n  });\n};","map":{"version":3,"names":["getOperator","initOptions","OperatorType","compose","Lazy","assert","isNumber","isOperator","isString","$function","$dateAdd","isUnbounded","$addFields","$group","$sort","SORT_REQUIRED_OPS","Set","WINDOW_UNBOUNDED_OPS","$setWindowFields","collection","expr","options","context","addExpressionOps","outputExpr","Object","values","output","keys","op","find","WINDOW","ACCUMULATOR","length","includes","window","documents","range","sortBy","_id","partitionBy","items","$push","transform","partitions","iterators","outputConfig","field","entries","config","operatorName","func","left","right","args","has","push","forEach","group","iterator","windowResultMap","makeResultFunc","getItemsFn","index","obj","parentExpr","inputExpr","documentNumber","unit","boundary","begin","end","toBeginIndex","currentIndex","Math","max","toEndIndex","getItems","current","every","slice","sortKey","lower","upper","getTime","amount","startDate","Date","Infinity","currentValue","array","filter","o","n","_","body"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/pipeline/setWindowFields.js"],"sourcesContent":["// $setWindowFields -  https://docs.mongodb.com/manual/reference/operator/aggregation/setWindowFields/\nimport { getOperator, initOptions, OperatorType } from \"../../core\";\nimport { compose, Lazy } from \"../../lazy\";\nimport { assert, isNumber, isOperator, isString } from \"../../util\";\nimport { $function } from \"../expression/custom/function\";\nimport { $dateAdd } from \"../expression/date/dateAdd\";\nimport { isUnbounded } from \"./_internal\";\nimport { $addFields } from \"./addFields\";\nimport { $group } from \"./group\";\nimport { $sort } from \"./sort\";\n// Operators that require 'sortBy' option.\nconst SORT_REQUIRED_OPS = new Set([\n    \"$denseRank\",\n    \"$documentNumber\",\n    \"$first\",\n    \"$last\",\n    \"$linearFill\",\n    \"$rank\",\n    \"$shift\"\n]);\n// Operators that require unbounded 'window' option.\nconst WINDOW_UNBOUNDED_OPS = new Set([\n    \"$denseRank\",\n    \"$expMovingAvg\",\n    \"$linearFill\",\n    \"$locf\",\n    \"$rank\",\n    \"$shift\"\n]);\n/**\n * Randomly selects the specified number of documents from its input. The given iterator must have finite values\n *\n * @param  {Iterator} collection\n * @param  {Object} expr\n * @param  {Options} options\n * @return {*}\n */\nexport const $setWindowFields = (collection, expr, options) => {\n    options = initOptions(options);\n    options.context.addExpressionOps({ $function });\n    // validate inputs early since this can be an expensive operation.\n    for (const outputExpr of Object.values(expr.output)) {\n        const keys = Object.keys(outputExpr);\n        const op = keys.find(isOperator);\n        assert(!!getOperator(OperatorType.WINDOW, op, options) ||\n            !!getOperator(OperatorType.ACCUMULATOR, op, options), `'${op}' is not a valid window operator`);\n        assert(keys.length > 0 &&\n            keys.length <= 2 &&\n            (keys.length == 1 || keys.includes(\"window\")), \"'output' option should have a single window operator.\");\n        if (outputExpr === null || outputExpr === void 0 ? void 0 : outputExpr.window) {\n            const { documents, range } = outputExpr.window;\n            assert((!!documents && !range) ||\n                (!documents && !!range) ||\n                (!documents && !range), \"'window' option supports only one of 'documents' or 'range'.\");\n        }\n    }\n    // we sort first if required\n    if (expr.sortBy) {\n        collection = $sort(collection, expr.sortBy, options);\n    }\n    // then partition collection\n    collection = $group(collection, {\n        _id: expr.partitionBy,\n        items: { $push: \"$$CURRENT\" }\n    }, options);\n    // transform values\n    return collection.transform(((partitions) => {\n        // let iteratorIndex = 0;\n        const iterators = [];\n        const outputConfig = [];\n        for (const [field, outputExpr] of Object.entries(expr.output)) {\n            const op = Object.keys(outputExpr).find(isOperator);\n            const config = {\n                operatorName: op,\n                func: {\n                    left: getOperator(OperatorType.ACCUMULATOR, op, options),\n                    right: getOperator(OperatorType.WINDOW, op, options)\n                },\n                args: outputExpr[op],\n                field: field,\n                window: outputExpr.window\n            };\n            // sortBy option required for specific operators or bounded window.\n            assert(!!expr.sortBy || !(SORT_REQUIRED_OPS.has(op) || !config.window), `${SORT_REQUIRED_OPS.has(op) ? `'${op}'` : \"bounded window operation\"} requires a sortBy.`);\n            // window must be unbounded for specific operators.\n            assert(!config.window || !WINDOW_UNBOUNDED_OPS.has(op), `${op} does not accept a 'window' field.`);\n            outputConfig.push(config);\n        }\n        // each parition maintains its own closure to process the documents in the window.\n        partitions.forEach(((group) => {\n            // get the items to process\n            const items = group.items;\n            // create an iterator per group.\n            // we need the index of each document so we track it using a special field.\n            let iterator = Lazy(items);\n            // results map\n            const windowResultMap = {};\n            for (const config of outputConfig) {\n                const { func, args, field, window } = config;\n                const makeResultFunc = (getItemsFn) => {\n                    // closure for object index within the partition\n                    let index = -1;\n                    return (obj) => {\n                        ++index;\n                        // process accumulator function\n                        if (func.left) {\n                            return func.left(getItemsFn(obj, index), args, options);\n                        }\n                        else if (func.right) {\n                            // OR process 'window' function\n                            return func.right(obj, getItemsFn(obj, index), {\n                                parentExpr: expr,\n                                inputExpr: args,\n                                documentNumber: index + 1,\n                                field\n                            }, \n                            // must use raw options only since it operates over a collection.\n                            options);\n                        }\n                    };\n                };\n                if (window) {\n                    const { documents, range, unit } = window;\n                    // TODO: fix the meaning of numeric values in range.\n                    //  See definition: https://www.mongodb.com/docs/manual/reference/operator/aggregation/setWindowFields/#std-label-setWindowFields-range\n                    //  - A number to add to the value of the sortBy field for the current document.\n                    //  - A document is in the window if the sortBy field value is inclusively within the lower and upper boundaries.\n                    // TODO: Need to reconcile the two above statments from the doc to implement 'range' option correctly.\n                    const boundary = documents || range;\n                    if (!isUnbounded(window)) {\n                        const [begin, end] = boundary;\n                        const toBeginIndex = (currentIndex) => {\n                            if (begin == \"current\")\n                                return currentIndex;\n                            if (begin == \"unbounded\")\n                                return 0;\n                            return Math.max(begin + currentIndex, 0);\n                        };\n                        const toEndIndex = (currentIndex) => {\n                            if (end == \"current\")\n                                return currentIndex + 1;\n                            if (end == \"unbounded\")\n                                return items.length;\n                            return end + currentIndex + 1;\n                        };\n                        const getItems = (current, index) => {\n                            // handle string boundaries or documents\n                            if (!!documents || boundary.every(isString)) {\n                                return items.slice(toBeginIndex(index), toEndIndex(index));\n                            }\n                            // handle range with numeric boundary values\n                            const sortKey = Object.keys(expr.sortBy)[0];\n                            let lower;\n                            let upper;\n                            if (unit) {\n                                // we are dealing with datetimes\n                                const getTime = (amount) => {\n                                    return $dateAdd(current, {\n                                        startDate: new Date(current[sortKey]),\n                                        unit,\n                                        amount\n                                    }, options).getTime();\n                                };\n                                lower = isNumber(begin) ? getTime(begin) : -Infinity;\n                                upper = isNumber(end) ? getTime(end) : Infinity;\n                            }\n                            else {\n                                const currentValue = current[sortKey];\n                                lower = isNumber(begin) ? currentValue + begin : -Infinity;\n                                upper = isNumber(end) ? currentValue + end : Infinity;\n                            }\n                            let array = items;\n                            if (begin == \"current\")\n                                array = items.slice(index);\n                            if (end == \"current\")\n                                array = items.slice(0, index + 1);\n                            // look within the boundary and filter down\n                            return array.filter((o) => {\n                                const n = +o[sortKey];\n                                return n >= lower && n <= upper;\n                            });\n                        };\n                        windowResultMap[field] = makeResultFunc(getItems);\n                    }\n                }\n                // default action is to utilize the entire set of items\n                if (!windowResultMap[field]) {\n                    windowResultMap[field] = makeResultFunc(_ => items);\n                }\n                // invoke add fields to get the desired behaviour using a custom function.\n                iterator = $addFields(iterator, {\n                    [field]: {\n                        $function: {\n                            body: (obj) => windowResultMap[field](obj),\n                            args: [\"$$CURRENT\"]\n                        }\n                    }\n                }, options);\n            }\n            // add to iterator list\n            iterators.push(iterator);\n        }));\n        return compose(...iterators);\n    }));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}