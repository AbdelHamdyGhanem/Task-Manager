{"ast":null,"code":"// Date Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#date-expression-operators\nimport { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport { adjustDate, DATE_FORMAT, DATE_SYM_TABLE, MINUTES_PER_HOUR, parseTimezone, regexQuote, regexStrip } from \"./_internal\";\nconst buildMap = (letters, sign) => {\n  const h = {};\n  letters.split(\"\").forEach((v, i) => h[v] = sign * (i + 1));\n  return h;\n};\nconst TZ_LETTER_OFFSETS = Object.assign(Object.assign(Object.assign({}, buildMap(\"ABCDEFGHIKLM\", 1)), buildMap(\"NOPQRSTUVWXY\", -1)), {\n  Z: 0\n});\n/**\n * Converts a date/time string to a date object.\n * @param obj\n * @param expr\n */\nexport const $dateFromString = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  args.format = args.format || DATE_FORMAT;\n  args.onNull = args.onNull || null;\n  let dateString = args.dateString;\n  if (isNil(dateString)) return args.onNull;\n  // collect all separators of the format string\n  const separators = args.format.split(/%[YGmdHMSLuVzZ]/);\n  separators.reverse();\n  const matches = args.format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g);\n  const dateParts = {};\n  // holds the valid regex of parts that matches input date string\n  let expectedPattern = \"\";\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const formatSpecifier = matches[i];\n    const props = DATE_SYM_TABLE[formatSpecifier];\n    if (isObject(props)) {\n      // get pattern and alias from table\n      const m = props.re.exec(dateString);\n      // get the next separtor\n      const delimiter = separators.pop() || \"\";\n      if (m !== null) {\n        // store and cut out matched part\n        dateParts[props.name] = /^\\d+$/.exec(m[0]) ? parseInt(m[0]) : m[0];\n        dateString = dateString.substr(0, m.index) + dateString.substr(m.index + m[0].length);\n        // construct expected pattern\n        expectedPattern += regexQuote(delimiter) + regexStrip(props.re.toString());\n      } else {\n        dateParts[props.name] = null;\n      }\n    }\n  }\n  // 1. validate all required date parts exists\n  // 2. validate original dateString against expected pattern.\n  if (isNil(dateParts.year) || isNil(dateParts.month) || isNil(dateParts.day) || !new RegExp(\"^\" + expectedPattern + \"[A-Z]?$\").exec(args.dateString)) {\n    return args.onError;\n  }\n  const m = args.dateString.match(/([A-Z])$/);\n  assert(\n  // only one of in-date timeone or timezone argument but not both.\n  !(m && args.timezone), `$dateFromString: you cannot pass in a date/time string with time zone information ('${m && m[0]}') together with a timezone argument`);\n  const minuteOffset = m ? TZ_LETTER_OFFSETS[m[0]] * MINUTES_PER_HOUR : parseTimezone(args.timezone);\n  // create the date. month is 0-based in Date\n  const d = new Date(Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0));\n  if (!isNil(dateParts.hour)) d.setUTCHours(dateParts.hour);\n  if (!isNil(dateParts.minute)) d.setUTCMinutes(dateParts.minute);\n  if (!isNil(dateParts.second)) d.setUTCSeconds(dateParts.second);\n  if (!isNil(dateParts.millisecond)) d.setUTCMilliseconds(dateParts.millisecond);\n  // adjust to the correct represention for UTC\n  adjustDate(d, -minuteOffset);\n  return d;\n};","map":{"version":3,"names":["computeValue","assert","isNil","isObject","adjustDate","DATE_FORMAT","DATE_SYM_TABLE","MINUTES_PER_HOUR","parseTimezone","regexQuote","regexStrip","buildMap","letters","sign","h","split","forEach","v","i","TZ_LETTER_OFFSETS","Object","assign","Z","$dateFromString","obj","expr","options","args","format","onNull","dateString","separators","reverse","matches","match","dateParts","expectedPattern","len","length","formatSpecifier","props","m","re","exec","delimiter","pop","name","parseInt","substr","index","toString","year","month","day","RegExp","onError","timezone","minuteOffset","d","Date","UTC","hour","setUTCHours","minute","setUTCMinutes","second","setUTCSeconds","millisecond","setUTCMilliseconds"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js"],"sourcesContent":["// Date Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#date-expression-operators\nimport { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport { adjustDate, DATE_FORMAT, DATE_SYM_TABLE, MINUTES_PER_HOUR, parseTimezone, regexQuote, regexStrip } from \"./_internal\";\nconst buildMap = (letters, sign) => {\n    const h = {};\n    letters.split(\"\").forEach((v, i) => (h[v] = sign * (i + 1)));\n    return h;\n};\nconst TZ_LETTER_OFFSETS = Object.assign(Object.assign(Object.assign({}, buildMap(\"ABCDEFGHIKLM\", 1)), buildMap(\"NOPQRSTUVWXY\", -1)), { Z: 0 });\n/**\n * Converts a date/time string to a date object.\n * @param obj\n * @param expr\n */\nexport const $dateFromString = (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    args.format = args.format || DATE_FORMAT;\n    args.onNull = args.onNull || null;\n    let dateString = args.dateString;\n    if (isNil(dateString))\n        return args.onNull;\n    // collect all separators of the format string\n    const separators = args.format.split(/%[YGmdHMSLuVzZ]/);\n    separators.reverse();\n    const matches = args.format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g);\n    const dateParts = {};\n    // holds the valid regex of parts that matches input date string\n    let expectedPattern = \"\";\n    for (let i = 0, len = matches.length; i < len; i++) {\n        const formatSpecifier = matches[i];\n        const props = DATE_SYM_TABLE[formatSpecifier];\n        if (isObject(props)) {\n            // get pattern and alias from table\n            const m = props.re.exec(dateString);\n            // get the next separtor\n            const delimiter = separators.pop() || \"\";\n            if (m !== null) {\n                // store and cut out matched part\n                dateParts[props.name] = /^\\d+$/.exec(m[0]) ? parseInt(m[0]) : m[0];\n                dateString =\n                    dateString.substr(0, m.index) +\n                        dateString.substr(m.index + m[0].length);\n                // construct expected pattern\n                expectedPattern +=\n                    regexQuote(delimiter) + regexStrip(props.re.toString());\n            }\n            else {\n                dateParts[props.name] = null;\n            }\n        }\n    }\n    // 1. validate all required date parts exists\n    // 2. validate original dateString against expected pattern.\n    if (isNil(dateParts.year) ||\n        isNil(dateParts.month) ||\n        isNil(dateParts.day) ||\n        !new RegExp(\"^\" + expectedPattern + \"[A-Z]?$\").exec(args.dateString)) {\n        return args.onError;\n    }\n    const m = args.dateString.match(/([A-Z])$/);\n    assert(\n    // only one of in-date timeone or timezone argument but not both.\n    !(m && args.timezone), `$dateFromString: you cannot pass in a date/time string with time zone information ('${m && m[0]}') together with a timezone argument`);\n    const minuteOffset = m\n        ? TZ_LETTER_OFFSETS[m[0]] * MINUTES_PER_HOUR\n        : parseTimezone(args.timezone);\n    // create the date. month is 0-based in Date\n    const d = new Date(Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0));\n    if (!isNil(dateParts.hour))\n        d.setUTCHours(dateParts.hour);\n    if (!isNil(dateParts.minute))\n        d.setUTCMinutes(dateParts.minute);\n    if (!isNil(dateParts.second))\n        d.setUTCSeconds(dateParts.second);\n    if (!isNil(dateParts.millisecond))\n        d.setUTCMilliseconds(dateParts.millisecond);\n    // adjust to the correct represention for UTC\n    adjustDate(d, -minuteOffset);\n    return d;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}