{"ast":null,"code":"import { AbstractNode } from './abstract-node.js';\nimport { Branches } from './branches.js';\nimport { lastOfArray, booleanToBooleanString } from './util.js';\nimport { bddToSimpleBdd } from './minimal-string/index.js';\nexport class RootNode extends AbstractNode {\n  branches = new Branches(this);\n  levels = [];\n  nodesByLevel = new Map();\n  constructor() {\n    super(0, null, 'RootNode');\n    this.levels.push(0);\n    const level0Set = new Set();\n    level0Set.add(this);\n    this.nodesByLevel.set(0, level0Set);\n  }\n  addNode(node) {\n    const level = node.level;\n    if (!this.levels.includes(level)) {\n      this.levels.push(level);\n    }\n    this.ensureLevelSetExists(level);\n    const set = this.nodesByLevel.get(level);\n    set?.add(node);\n  }\n  removeNode(node) {\n    const set = this.nodesByLevel.get(node.level);\n    if (!set.has(node)) {\n      throw new Error('removed non-existing node ' + node.id);\n    }\n    set.delete(node);\n  }\n  ensureLevelSetExists(level) {\n    if (!this.nodesByLevel.has(level)) {\n      this.nodesByLevel.set(level, new Set());\n    }\n  }\n  getLevels() {\n    return Array.from(this.levels).sort((a, b) => a - b);\n  }\n  getNodesOfLevel(level) {\n    this.ensureLevelSetExists(level);\n    const set = this.nodesByLevel.get(level);\n    return Array.from(set);\n  }\n  countNodes() {\n    let ret = 0;\n    this.getLevels().forEach(level => {\n      const nodesAmount = this.getNodesOfLevel(level).length;\n      ret = ret + nodesAmount;\n    });\n    return ret;\n  }\n  /**\n   * applies the reduction rules to the whole bdd\n   */\n  minimize(logState = false) {\n    // console.log('minimize(): START ###############');\n    let done = false;\n    while (!done) {\n      if (logState) {\n        console.log('minimize() itterate once');\n      }\n      let successCount = 0;\n      let lastLevel = lastOfArray(this.getLevels());\n      while (lastLevel > 0) {\n        const nodes = this.getNodesOfLevel(lastLevel);\n        if (logState) {\n          console.log('minimize() run for level ' + lastLevel + ' with ' + nodes.length + ' nodes');\n          // console.dir(nodes);\n        }\n        let nodeCount = 0;\n        for (const node of nodes) {\n          nodeCount++;\n          // do not run that often because it is expensive\n          if (logState && nodeCount % 4000 === 0) {\n            console.log('minimize() node #' + node.id);\n          }\n          if (node.isLeafNode()) {\n            // console.log('have leaf node ' + node.id);\n            const reductionDone = node.asLeafNode().applyEliminationRule();\n            if (reductionDone) {\n              successCount++;\n            }\n          }\n          if (!node.deleted && node.isInternalNode()) {\n            const useNode = node;\n            const reductionDone = useNode.applyReductionRule();\n            let eliminationDone = false;\n            if (!useNode.deleted) {\n              // not might now be deleted from reduction-rule\n              eliminationDone = useNode.applyEliminationRule(nodes);\n            }\n            if (reductionDone || eliminationDone) {\n              successCount++;\n            }\n          }\n        }\n        lastLevel--;\n      }\n      if (successCount === 0) {\n        // could do no more optimisations\n        done = true;\n      } else {\n        if (logState) {\n          console.log('minimize() itteration done with ' + successCount + ' minimisations');\n        }\n      }\n    }\n  }\n  getLeafNodes() {\n    const lastLevel = lastOfArray(this.getLevels());\n    const leafNodes = this.getNodesOfLevel(lastLevel).reverse();\n    return leafNodes;\n  }\n  /**\n   * strips all leaf-nodes\n   * with the given value\n   */\n  removeIrrelevantLeafNodes(leafNodeValue) {\n    let done = false;\n    while (!done) {\n      let countRemoved = 0;\n      const leafNodes = this.getLeafNodes();\n      for (const leafNode of leafNodes) {\n        const removed = leafNode.removeIfValueEquals(leafNodeValue);\n        if (removed) {\n          countRemoved++;\n        }\n      }\n      this.minimize();\n      if (countRemoved === 0) {\n        done = true;\n      }\n    }\n  }\n  resolve(fns, booleanFunctionInput) {\n    let currentNode = this;\n    while (true) {\n      const booleanResult = fns[currentNode.level](booleanFunctionInput);\n      const branchKey = booleanToBooleanString(booleanResult);\n      currentNode = currentNode.branches.getBranch(branchKey);\n      if (currentNode.isLeafNode()) {\n        return currentNode.asLeafNode().value;\n      }\n    }\n  }\n  toSimpleBdd() {\n    return bddToSimpleBdd(this);\n  }\n}","map":{"version":3,"names":["AbstractNode","Branches","lastOfArray","booleanToBooleanString","bddToSimpleBdd","RootNode","branches","levels","nodesByLevel","Map","constructor","push","level0Set","Set","add","set","addNode","node","level","includes","ensureLevelSetExists","get","removeNode","has","Error","id","delete","getLevels","Array","from","sort","a","b","getNodesOfLevel","countNodes","ret","forEach","nodesAmount","length","minimize","logState","done","console","log","successCount","lastLevel","nodes","nodeCount","isLeafNode","reductionDone","asLeafNode","applyEliminationRule","deleted","isInternalNode","useNode","applyReductionRule","eliminationDone","getLeafNodes","leafNodes","reverse","removeIrrelevantLeafNodes","leafNodeValue","countRemoved","leafNode","removed","removeIfValueEquals","resolve","fns","booleanFunctionInput","currentNode","booleanResult","branchKey","getBranch","value","toSimpleBdd"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/binary-decision-diagram/src/root-node.ts"],"sourcesContent":["import { AbstractNode } from './abstract-node.js';\nimport { Branches } from './branches.js';\nimport type {\n    NonRootNode,\n    ResolverFunctions,\n    NonLeafNode,\n    SimpleBdd\n} from './types.js';\nimport {\n    lastOfArray,\n    booleanToBooleanString\n} from './util.js';\nimport { InternalNode } from './internal-node.js';\nimport { LeafNode } from './leaf-node.js';\nimport { bddToSimpleBdd } from './minimal-string/index.js';\n\nexport class RootNode extends AbstractNode {\n    public branches: Branches = new Branches(this);\n\n    public levels: number[] = [];\n    public nodesByLevel: Map<number, Set<AbstractNode>> = new Map();\n\n    constructor() {\n        super(\n            0,\n            null,\n            'RootNode'\n        );\n        this.levels.push(0);\n        const level0Set: Set<AbstractNode> = new Set();\n        level0Set.add(this);\n        this.nodesByLevel.set(0, level0Set);\n    }\n\n    public addNode(node: NonRootNode) {\n        const level = node.level;\n\n        if (!this.levels.includes(level)) {\n            this.levels.push(level);\n        }\n\n        this.ensureLevelSetExists(level);\n        const set = this.nodesByLevel.get(level);\n        set?.add(node);\n    }\n\n    removeNode(node: NonRootNode) {\n        const set = this.nodesByLevel.get(node.level) as Set<NonRootNode>;\n        if (!set.has(node)) {\n            throw new Error('removed non-existing node ' + node.id);\n        }\n        set.delete(node);\n    }\n\n    private ensureLevelSetExists(level: number) {\n        if (!this.nodesByLevel.has(level)) {\n            this.nodesByLevel.set(level, new Set());\n        }\n    }\n\n    public getLevels(): number[] {\n        return Array.from(this.levels).sort((a, b) => a - b);\n    }\n\n    public getNodesOfLevel(level: number): NonRootNode[] {\n        this.ensureLevelSetExists(level);\n        const set = this.nodesByLevel.get(level) as Set<NonRootNode>;\n        return Array.from(set);\n    }\n\n    public countNodes(): number {\n        let ret: number = 0;\n        this.getLevels().forEach(level => {\n            const nodesAmount = this.getNodesOfLevel(level).length;\n            ret = ret + nodesAmount;\n        });\n        return ret;\n    }\n\n    /**\n     * applies the reduction rules to the whole bdd\n     */\n    minimize(logState: boolean = false) {\n        // console.log('minimize(): START ###############');\n        let done = false;\n        while (!done) {\n            if (logState) {\n                console.log('minimize() itterate once');\n            }\n            let successCount = 0;\n            let lastLevel = lastOfArray(this.getLevels());\n            while (lastLevel > 0) {\n                const nodes: InternalNode[] = this.getNodesOfLevel(lastLevel) as InternalNode[];\n                if (logState) {\n                    console.log(\n                        'minimize() run for level ' + lastLevel +\n                        ' with ' + nodes.length + ' nodes'\n                    );\n                    // console.dir(nodes);\n                }\n\n                let nodeCount = 0;\n                for (const node of nodes) {\n                    nodeCount++;\n\n                    // do not run that often because it is expensive\n                    if (logState && nodeCount % 4000 === 0) {\n                        console.log(\n                            'minimize() node #' + node.id\n                        );\n                    }\n                    if (node.isLeafNode()) {\n                        // console.log('have leaf node ' + node.id);\n                        const reductionDone = node.asLeafNode().applyEliminationRule();\n                        if (reductionDone) {\n                            successCount++;\n                        }\n                    }\n                    if (!node.deleted && node.isInternalNode()) {\n                        const useNode = node as InternalNode;\n                        const reductionDone = useNode.applyReductionRule();\n                        let eliminationDone = false;\n                        if (!useNode.deleted) {\n                            // not might now be deleted from reduction-rule\n                            eliminationDone = useNode.applyEliminationRule(nodes);\n                        }\n                        if (reductionDone || eliminationDone) {\n                            successCount++;\n                        }\n                    }\n                }\n                lastLevel--;\n            }\n            if (successCount === 0) {\n                // could do no more optimisations\n                done = true;\n            } else {\n                if (logState) {\n                    console.log(\n                        'minimize() itteration done with ' +\n                        successCount + ' minimisations'\n                    );\n                }\n            }\n        }\n    }\n\n    public getLeafNodes(): LeafNode[] {\n        const lastLevel = lastOfArray(this.getLevels());\n        const leafNodes = this.getNodesOfLevel(lastLevel).reverse() as LeafNode[];\n        return leafNodes;\n    }\n\n    /**\n     * strips all leaf-nodes\n     * with the given value\n     */\n    removeIrrelevantLeafNodes(leafNodeValue: number) {\n        let done = false;\n        while (!done) {\n            let countRemoved = 0;\n            const leafNodes = this.getLeafNodes();\n            for (const leafNode of leafNodes) {\n                const removed = leafNode.removeIfValueEquals(leafNodeValue);\n                if (removed) {\n                    countRemoved++;\n                }\n            }\n            this.minimize();\n\n            if (countRemoved === 0) {\n                done = true;\n            }\n        }\n    }\n\n    resolve(\n        fns: ResolverFunctions,\n        booleanFunctionInput: any\n    ): number {\n        let currentNode: AbstractNode = this;\n        while (true) {\n            const booleanResult = fns[currentNode.level](booleanFunctionInput);\n            const branchKey = booleanToBooleanString(booleanResult);\n            currentNode = (currentNode as NonLeafNode).branches.getBranch(branchKey);\n            if (currentNode.isLeafNode()) {\n                return currentNode.asLeafNode().value;\n            }\n        }\n    }\n\n    public toSimpleBdd(): SimpleBdd {\n        return bddToSimpleBdd(this);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}