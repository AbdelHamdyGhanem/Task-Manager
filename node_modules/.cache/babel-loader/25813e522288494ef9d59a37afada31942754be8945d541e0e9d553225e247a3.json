{"ast":null,"code":"import { assert, hashCode, into, isString, resolve } from \"../../util\";\n/**\n * Performs a left outer join to another collection in the same database to filter in documents from the “joined” collection for processing.\n *\n * @param collection\n * @param expr\n * @param opt\n */\nexport const $lookup = (collection, expr, options) => {\n  const joinColl = isString(expr.from) ? options === null || options === void 0 ? void 0 : options.collectionResolver(expr.from) : expr.from;\n  assert(joinColl instanceof Array, `'from' field must resolve to an array`);\n  const hash = {};\n  for (const obj of joinColl) {\n    const k = hashCode(resolve(obj, expr.foreignField), options === null || options === void 0 ? void 0 : options.hashFunction);\n    hash[k] = hash[k] || [];\n    hash[k].push(obj);\n  }\n  return collection.map(obj => {\n    const k = hashCode(resolve(obj, expr.localField), options === null || options === void 0 ? void 0 : options.hashFunction);\n    const newObj = into({}, obj);\n    newObj[expr.as] = hash[k] || [];\n    return newObj;\n  });\n};","map":{"version":3,"names":["assert","hashCode","into","isString","resolve","$lookup","collection","expr","options","joinColl","from","collectionResolver","Array","hash","obj","k","foreignField","hashFunction","push","map","localField","newObj","as"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/pipeline/lookup.js"],"sourcesContent":["import { assert, hashCode, into, isString, resolve } from \"../../util\";\n/**\n * Performs a left outer join to another collection in the same database to filter in documents from the “joined” collection for processing.\n *\n * @param collection\n * @param expr\n * @param opt\n */\nexport const $lookup = (collection, expr, options) => {\n    const joinColl = isString(expr.from)\n        ? options === null || options === void 0 ? void 0 : options.collectionResolver(expr.from)\n        : expr.from;\n    assert(joinColl instanceof Array, `'from' field must resolve to an array`);\n    const hash = {};\n    for (const obj of joinColl) {\n        const k = hashCode(resolve(obj, expr.foreignField), options === null || options === void 0 ? void 0 : options.hashFunction);\n        hash[k] = hash[k] || [];\n        hash[k].push(obj);\n    }\n    return collection.map((obj) => {\n        const k = hashCode(resolve(obj, expr.localField), options === null || options === void 0 ? void 0 : options.hashFunction);\n        const newObj = into({}, obj);\n        newObj[expr.as] = hash[k] || [];\n        return newObj;\n    });\n};\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,OAAO,QAAQ,YAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAGA,CAACC,UAAU,EAAEC,IAAI,EAAEC,OAAO,KAAK;EAClD,MAAMC,QAAQ,GAAGN,QAAQ,CAACI,IAAI,CAACG,IAAI,CAAC,GAC9BF,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACG,kBAAkB,CAACJ,IAAI,CAACG,IAAI,CAAC,GACvFH,IAAI,CAACG,IAAI;EACfV,MAAM,CAACS,QAAQ,YAAYG,KAAK,EAAE,uCAAuC,CAAC;EAC1E,MAAMC,IAAI,GAAG,CAAC,CAAC;EACf,KAAK,MAAMC,GAAG,IAAIL,QAAQ,EAAE;IACxB,MAAMM,CAAC,GAAGd,QAAQ,CAACG,OAAO,CAACU,GAAG,EAAEP,IAAI,CAACS,YAAY,CAAC,EAAER,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACS,YAAY,CAAC;IAC3HJ,IAAI,CAACE,CAAC,CAAC,GAAGF,IAAI,CAACE,CAAC,CAAC,IAAI,EAAE;IACvBF,IAAI,CAACE,CAAC,CAAC,CAACG,IAAI,CAACJ,GAAG,CAAC;EACrB;EACA,OAAOR,UAAU,CAACa,GAAG,CAAEL,GAAG,IAAK;IAC3B,MAAMC,CAAC,GAAGd,QAAQ,CAACG,OAAO,CAACU,GAAG,EAAEP,IAAI,CAACa,UAAU,CAAC,EAAEZ,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACS,YAAY,CAAC;IACzH,MAAMI,MAAM,GAAGnB,IAAI,CAAC,CAAC,CAAC,EAAEY,GAAG,CAAC;IAC5BO,MAAM,CAACd,IAAI,CAACe,EAAE,CAAC,GAAGT,IAAI,CAACE,CAAC,CAAC,IAAI,EAAE;IAC/B,OAAOM,MAAM;EACjB,CAAC,CAAC;AACN,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}