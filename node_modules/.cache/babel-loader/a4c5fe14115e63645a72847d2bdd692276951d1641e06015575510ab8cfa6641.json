{"ast":null,"code":"/**\n * run some tests on the bdd\n * to ensure everything is correct\n */\nexport function ensureCorrectBdd(bdd) {\n  const jsonString = JSON.stringify(bdd.toJSON(true));\n  let allNodes = [];\n  const nodesById = new Map();\n  bdd.getLevels().forEach(level => {\n    const levelNodes = bdd.getNodesOfLevel(level);\n    levelNodes.forEach(node => {\n      nodesById.set(node.id, node);\n    });\n    allNodes = allNodes.concat(levelNodes);\n  });\n  const recursiveNodes = getNodesRecursive(bdd);\n  if (allNodes.length !== recursiveNodes.size) {\n    const allNodesIds = allNodes.map(n => n.id).sort();\n    const recursiveNodesIds = Array.from(recursiveNodes).map(n => n.id).sort();\n    const nodesOnlyInRecursive = recursiveNodesIds.filter(id => !allNodesIds.includes(id));\n    //        console.log(JSON.stringify(allNodes.map(n => n.id).sort(), null, 2));\n    //      console.log(JSON.stringify(Array.from(recursiveNodes).map(n => n.id).sort(), null, 2));\n    if (recursiveNodes.size > allNodes.length) {\n      const firstId = nodesOnlyInRecursive[0];\n      const referenceToFirst = allNodes.find(n => {\n        if (n.isInternalNode()) {\n          return n.branches.hasNodeIdAsBranch(firstId);\n        }\n        return false;\n      });\n      console.log('referenceToFirst:');\n      referenceToFirst?.log();\n    }\n    throw new Error('ensureCorrectBdd() ' + 'nodes in list not equal size to recursive nodes ' + 'allNodes: ' + allNodes.length + ' ' + 'recursiveNodes: ' + recursiveNodes.size + ' ' + 'nodesOnlyInRecursive: ' + nodesOnlyInRecursive.join(', ') + ' ');\n  }\n  allNodes.forEach(node => {\n    if (node.isRootNode()) {\n      return;\n    }\n    const useNode = node;\n    if (node.deleted) {\n      throw new Error('ensureCorrectBdd() ' + 'bdd includes a deleted node');\n    }\n    // each node should have a parent\n    if (useNode.parents.size === 0) {\n      throw new Error('ensureCorrectBdd() ' + 'node has no parent ' + useNode.id);\n    }\n    if (useNode.isInternalNode()) {\n      const internalNode = useNode;\n      const bothBranches = internalNode.branches.getBothBranches();\n      // a node should not have 2 equal branches\n      if (internalNode.branches.areBranchesStrictEqual()) {\n        throw new Error('ensureCorrectBdd() ' + 'node has two equal branches: ' + bothBranches.map(n => n.id).join(', '));\n      }\n      // each branch should have the node as parent\n      bothBranches.forEach(branch => {\n        if (!branch.parents.has(internalNode)) {\n          throw new Error('ensureCorrectBdd() ' + 'branch must have the node as parent');\n        }\n      });\n    }\n    // each parent should have the child as branch\n    useNode.parents.getAll().forEach(parent => {\n      if (!parent.branches.hasBranchAsNode(useNode)) {\n        throw new Error('ensureCorrectBdd() ' + 'parent node does not have child as branch');\n      }\n    });\n  });\n  if (jsonString.includes('\"deleted\":true')) {\n    throw new Error('ensureCorrectBdd() ' + 'bdd includes a deleted node');\n  }\n}\nexport function getNodesRecursive(node, set = new Set()) {\n  set.add(node);\n  if (!node.isLeafNode()) {\n    const useNode = node;\n    const branch1 = useNode.branches.getBranch('0');\n    set.add(branch1);\n    getNodesRecursive(branch1, set);\n    const branch2 = useNode.branches.getBranch('1');\n    set.add(branch2);\n    getNodesRecursive(branch2, set);\n  }\n  return set;\n}","map":{"version":3,"names":["ensureCorrectBdd","bdd","jsonString","JSON","stringify","toJSON","allNodes","nodesById","Map","getLevels","forEach","level","levelNodes","getNodesOfLevel","node","set","id","concat","recursiveNodes","getNodesRecursive","length","size","allNodesIds","map","n","sort","recursiveNodesIds","Array","from","nodesOnlyInRecursive","filter","includes","firstId","referenceToFirst","find","isInternalNode","branches","hasNodeIdAsBranch","console","log","Error","join","isRootNode","useNode","deleted","parents","internalNode","bothBranches","getBothBranches","areBranchesStrictEqual","branch","has","getAll","parent","hasBranchAsNode","Set","add","isLeafNode","branch1","getBranch","branch2"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/binary-decision-diagram/src/ensure-correct-bdd.ts"],"sourcesContent":["import { RootNode } from './root-node.js';\nimport { AbstractNode } from './abstract-node.js';\nimport type { NonRootNode, NonLeafNode } from './types.js';\nimport { InternalNode } from './internal-node.js';\n\n/**\n * run some tests on the bdd\n * to ensure everything is correct\n */\nexport function ensureCorrectBdd(bdd: RootNode) {\n    const jsonString = JSON.stringify(bdd.toJSON(true));\n\n\n    let allNodes: AbstractNode[] = [];\n    const nodesById: Map<string, AbstractNode> = new Map();\n    bdd.getLevels().forEach(level => {\n        const levelNodes = bdd.getNodesOfLevel(level);\n        levelNodes.forEach(node => {\n            nodesById.set(node.id, node);\n        });\n        allNodes = allNodes.concat(levelNodes);\n    });\n\n\n    const recursiveNodes = getNodesRecursive(bdd);\n\n    if (allNodes.length !== recursiveNodes.size) {\n\n        const allNodesIds = allNodes.map(n => n.id).sort();\n        const recursiveNodesIds = Array.from(recursiveNodes).map(n => n.id).sort();\n        const nodesOnlyInRecursive: string[] = recursiveNodesIds.filter(id => !allNodesIds.includes(id));\n\n        //        console.log(JSON.stringify(allNodes.map(n => n.id).sort(), null, 2));\n        //      console.log(JSON.stringify(Array.from(recursiveNodes).map(n => n.id).sort(), null, 2));\n\n        if (recursiveNodes.size > allNodes.length) {\n            const firstId = nodesOnlyInRecursive[0];\n            const referenceToFirst = allNodes.find(n => {\n                if (n.isInternalNode()) {\n                    return (n as InternalNode).branches.hasNodeIdAsBranch(firstId);\n                }\n                return false;\n            });\n            console.log('referenceToFirst:');\n            referenceToFirst?.log();\n        }\n\n        throw new Error(\n            'ensureCorrectBdd() ' +\n            'nodes in list not equal size to recursive nodes ' +\n            'allNodes: ' + allNodes.length + ' ' +\n            'recursiveNodes: ' + recursiveNodes.size + ' ' +\n            'nodesOnlyInRecursive: ' + nodesOnlyInRecursive.join(', ') + ' '\n        );\n    }\n\n    allNodes.forEach(node => {\n        if (node.isRootNode()) {\n            return;\n        }\n        const useNode = node as NonRootNode;\n\n        if (node.deleted) {\n            throw new Error(\n                'ensureCorrectBdd() ' +\n                'bdd includes a deleted node'\n            );\n        }\n\n        // each node should have a parent\n        if (useNode.parents.size === 0) {\n            throw new Error(\n                'ensureCorrectBdd() ' +\n                'node has no parent ' + useNode.id\n            );\n        }\n\n        if (useNode.isInternalNode()) {\n            const internalNode: InternalNode = useNode as any;\n            const bothBranches = internalNode.branches.getBothBranches();\n\n            // a node should not have 2 equal branches\n            if (internalNode.branches.areBranchesStrictEqual()) {\n                throw new Error(\n                    'ensureCorrectBdd() ' +\n                    'node has two equal branches: ' +\n                    bothBranches.map(n => n.id).join(', ')\n                );\n            }\n\n            // each branch should have the node as parent\n            bothBranches.forEach(branch => {\n                if (!branch.parents.has(internalNode)) {\n                    throw new Error(\n                        'ensureCorrectBdd() ' +\n                        'branch must have the node as parent'\n                    );\n                }\n            });\n        }\n\n        // each parent should have the child as branch\n        useNode.parents.getAll().forEach(parent => {\n            if (!parent.branches.hasBranchAsNode(useNode)) {\n                throw new Error(\n                    'ensureCorrectBdd() ' +\n                    'parent node does not have child as branch'\n                );\n            }\n        });\n    });\n\n\n    if (jsonString.includes('\"deleted\":true')) {\n        throw new Error(\n            'ensureCorrectBdd() ' +\n            'bdd includes a deleted node'\n        );\n    }\n}\n\nexport function getNodesRecursive(\n    node: AbstractNode,\n    set: Set<AbstractNode> = new Set()\n): Set<AbstractNode> {\n    set.add(node);\n    if (!node.isLeafNode()) {\n        const useNode = node as NonLeafNode;\n\n        const branch1 = useNode.branches.getBranch('0');\n        set.add(branch1);\n        getNodesRecursive(branch1, set);\n\n        const branch2 = useNode.branches.getBranch('1');\n        set.add(branch2);\n        getNodesRecursive(branch2, set);\n    }\n\n    return set;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}