{"ast":null,"code":"import { getProperty, lastOfArray } from '../util.js';\nexport const hasLimit = input => {\n  return !!input.queryParams.limit;\n};\nexport const isFindOne = input => {\n  return input.queryParams.limit === 1;\n};\nexport const hasSkip = input => {\n  if (input.queryParams.skip && input.queryParams.skip > 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const isDelete = input => {\n  return input.changeEvent.operation === 'DELETE';\n};\nexport const isInsert = input => {\n  return input.changeEvent.operation === 'INSERT';\n};\nexport const isUpdate = input => {\n  return input.changeEvent.operation === 'UPDATE';\n};\nexport const wasLimitReached = input => {\n  return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;\n};\nexport const sortParamsChanged = input => {\n  const sortFields = input.queryParams.sortFields;\n  const prev = input.changeEvent.previous;\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  if (!prev) {\n    return true;\n  }\n  for (let i = 0; i < sortFields.length; i++) {\n    const field = sortFields[i];\n    const beforeData = getProperty(prev, field);\n    const afterData = getProperty(doc, field);\n    if (beforeData !== afterData) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const wasInResult = input => {\n  const id = input.changeEvent.id;\n  if (input.keyDocumentMap) {\n    const has = input.keyDocumentMap.has(id);\n    return has;\n  } else {\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n      const item = results[i];\n      if (item[primary] === id) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nexport const wasFirst = input => {\n  const first = input.previousResults[0];\n  if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const wasLast = input => {\n  const last = lastOfArray(input.previousResults);\n  if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const wasSortedBeforeFirst = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  const first = input.previousResults[0];\n  if (!first) {\n    return false;\n  }\n  /**\n   * If the changed document is the same as the first,\n   * we cannot sort-compare them, because it might end in a non-deterministic\n   * sort order. Because both document could be equal.\n   * So instead we have to return true.\n   */\n  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(prev, first);\n  return comp < 0;\n};\nexport const wasSortedAfterLast = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  const last = lastOfArray(input.previousResults);\n  if (!last) {\n    return false;\n  }\n  if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(prev, last);\n  return comp > 0;\n};\nexport const isSortedBeforeFirst = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const first = input.previousResults[0];\n  if (!first) {\n    return false;\n  }\n  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(doc, first);\n  return comp < 0;\n};\nexport const isSortedAfterLast = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const last = lastOfArray(input.previousResults);\n  if (!last) {\n    return false;\n  }\n  if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(doc, last);\n  return comp > 0;\n};\nexport const wasMatching = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  return input.queryParams.queryMatcher(prev);\n};\nexport const doesMatchNow = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const ret = input.queryParams.queryMatcher(doc);\n  return ret;\n};\nexport const wasResultsEmpty = input => {\n  return input.previousResults.length === 0;\n};","map":{"version":3,"names":["getProperty","lastOfArray","hasLimit","input","queryParams","limit","isFindOne","hasSkip","skip","isDelete","changeEvent","operation","isInsert","isUpdate","wasLimitReached","previousResults","length","sortParamsChanged","sortFields","prev","previous","doc","i","field","beforeData","afterData","wasInResult","id","keyDocumentMap","has","primary","primaryKey","results","item","wasFirst","first","wasLast","last","wasSortedBeforeFirst","comp","sortComparator","wasSortedAfterLast","isSortedBeforeFirst","isSortedAfterLast","wasMatching","queryMatcher","doesMatchNow","ret","wasResultsEmpty"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/event-reduce-js/src/states/state-resolver.ts"],"sourcesContent":["import type { StateResolveFunction } from '../types/index.js';\nimport { getProperty, lastOfArray } from '../util.js';\n\nexport const hasLimit: StateResolveFunction<any> = (input) => {\n    return !!input.queryParams.limit;\n};\n\nexport const isFindOne: StateResolveFunction<any> = (input) => {\n    return input.queryParams.limit === 1;\n};\n\nexport const hasSkip: StateResolveFunction<any> = (input) => {\n    if (input.queryParams.skip && input.queryParams.skip > 0) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nexport const isDelete: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'DELETE';\n};\n\nexport const isInsert: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'INSERT';\n};\n\nexport const isUpdate: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'UPDATE';\n};\n\n\nexport const wasLimitReached: StateResolveFunction<any> = (input) => {\n    return hasLimit(input) && input.previousResults.length >= (input.queryParams.limit as number);\n};\n\nexport const sortParamsChanged: StateResolveFunction<any> = (input) => {\n    const sortFields = input.queryParams.sortFields;\n    const prev = input.changeEvent.previous;\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    if (!prev) {\n        return true;\n    }\n\n    for (let i = 0; i < sortFields.length; i++) {\n        const field = sortFields[i];\n        const beforeData = getProperty(prev, field);\n        const afterData = getProperty(doc, field);\n        if (beforeData !== afterData) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport const wasInResult: StateResolveFunction<any> = (input) => {\n    const id = input.changeEvent.id;\n    if (input.keyDocumentMap) {\n        const has = input.keyDocumentMap.has(id);\n        return has;\n    } else {\n        const primary = input.queryParams.primaryKey;\n        const results = input.previousResults;\n        for (let i = 0; i < results.length; i++) {\n            const item = results[i];\n            if (item[primary] === id) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nexport const wasFirst: StateResolveFunction<any> = (input) => {\n    const first = input.previousResults[0];\n    if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nexport const wasLast: StateResolveFunction<any> = (input) => {\n    const last = lastOfArray(input.previousResults);\n    if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\n\nexport const wasSortedBeforeFirst: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n\n    /**\n     * If the changed document is the same as the first,\n     * we cannot sort-compare them, because it might end in a non-deterministic\n     * sort order. Because both document could be equal.\n     * So instead we have to return true.\n     */\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        prev,\n        first\n    );\n    return comp < 0;\n};\n\nexport const wasSortedAfterLast: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        prev,\n        last\n    );\n    return comp > 0;\n};\n\nexport const isSortedBeforeFirst: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        doc,\n        first\n    );\n    return comp < 0;\n};\n\nexport const isSortedAfterLast: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        doc,\n        last\n    );\n    return comp > 0;\n};\n\n\nexport const wasMatching: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n    return input.queryParams.queryMatcher(\n        prev\n    );\n};\n\nexport const doesMatchNow: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const ret = input.queryParams.queryMatcher(\n        doc\n    );\n    return ret;\n};\n\n\nexport const wasResultsEmpty: StateResolveFunction<any> = (input) => {\n    return input.previousResults.length === 0;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}