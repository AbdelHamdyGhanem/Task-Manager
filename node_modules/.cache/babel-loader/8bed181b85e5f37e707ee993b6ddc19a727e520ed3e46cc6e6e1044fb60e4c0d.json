{"ast":null,"code":"import { MingoError } from \"./types\";\n/**\n * Returns an iterator\n * @param {*} source An iterable source (Array, Function, Generator, or Iterator)\n */\nexport function Lazy(source) {\n  return source instanceof Iterator ? source : new Iterator(source);\n}\nexport function compose(...iterators) {\n  let index = 0;\n  return Lazy(() => {\n    while (index < iterators.length) {\n      const o = iterators[index].next();\n      if (!o.done) return o;\n      index++;\n    }\n    return {\n      done: true\n    };\n  });\n}\n/**\n * Checks whether the given object is compatible with a generator i.e Object{next:Function}\n * @param {*} o An object\n */\nfunction isGenerator(o) {\n  return !!o && typeof o === \"object\" && (o === null || o === void 0 ? void 0 : o.next) instanceof Function;\n}\nfunction dropItem(array, i) {\n  const rest = array.slice(i + 1);\n  array.splice(i);\n  Array.prototype.push.apply(array, rest);\n}\n// stop iteration error\nconst DONE = new Error();\n// Lazy function actions\nvar Action;\n(function (Action) {\n  Action[Action[\"MAP\"] = 0] = \"MAP\";\n  Action[Action[\"FILTER\"] = 1] = \"FILTER\";\n  Action[Action[\"TAKE\"] = 2] = \"TAKE\";\n  Action[Action[\"DROP\"] = 3] = \"DROP\";\n})(Action || (Action = {}));\nfunction createCallback(nextFn, iteratees, buffer) {\n  let done = false;\n  let index = -1;\n  let bufferIndex = 0; // index for the buffer\n  return function (storeResult) {\n    // special hack to collect all values into buffer\n    try {\n      outer: while (!done) {\n        let o = nextFn();\n        index++;\n        let i = -1;\n        const size = iteratees.length;\n        let innerDone = false;\n        while (++i < size) {\n          const r = iteratees[i];\n          switch (r.action) {\n            case Action.MAP:\n              o = r.func(o, index);\n              break;\n            case Action.FILTER:\n              if (!r.func(o, index)) continue outer;\n              break;\n            case Action.TAKE:\n              --r.count;\n              if (!r.count) innerDone = true;\n              break;\n            case Action.DROP:\n              --r.count;\n              if (!r.count) dropItem(iteratees, i);\n              continue outer;\n            default:\n              break outer;\n          }\n        }\n        done = innerDone;\n        if (storeResult) {\n          buffer[bufferIndex++] = o;\n        } else {\n          return {\n            value: o,\n            done: false\n          };\n        }\n      }\n    } catch (e) {\n      if (e !== DONE) throw e;\n    }\n    done = true;\n    return {\n      done\n    };\n  };\n}\n/**\n * A lazy collection iterator yields a single value at a time upon request.\n */\nexport class Iterator {\n  /**\n   * @param {*} source An iterable object or function.\n   *    Array - return one element per cycle\n   *    Object{next:Function} - call next() for the next value (this also handles generator functions)\n   *    Function - call to return the next value\n   * @param {Function} fn An optional transformation function\n   */\n  constructor(source) {\n    this.iteratees = [];\n    this.yieldedValues = [];\n    this.isDone = false;\n    let nextVal;\n    if (source instanceof Function) {\n      // make iterable\n      source = {\n        next: source\n      };\n    }\n    if (isGenerator(source)) {\n      const src = source;\n      nextVal = () => {\n        const o = src.next();\n        if (o.done) throw DONE;\n        return o.value;\n      };\n    } else if (source instanceof Array) {\n      const data = source;\n      const size = data.length;\n      let index = 0;\n      nextVal = () => {\n        if (index < size) return data[index++];\n        throw DONE;\n      };\n    } else if (!(source instanceof Function)) {\n      throw new MingoError(`Lazy must be initialized with an array, generator, or function.`);\n    }\n    // create next function\n    this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);\n  }\n  /**\n   * Add an iteratee to this lazy sequence\n   */\n  push(action, value) {\n    if (typeof value === \"function\") {\n      this.iteratees.push({\n        action,\n        func: value\n      });\n    } else if (typeof value === \"number\") {\n      this.iteratees.push({\n        action,\n        count: value\n      });\n    }\n    return this;\n  }\n  next() {\n    return this.getNext();\n  }\n  // Iteratees methods\n  /**\n   * Transform each item in the sequence to a new value\n   * @param {Function} f\n   */\n  map(f) {\n    return this.push(Action.MAP, f);\n  }\n  /**\n   * Select only items matching the given predicate\n   * @param {Function} pred\n   */\n  filter(predicate) {\n    return this.push(Action.FILTER, predicate);\n  }\n  /**\n   * Take given numbe for values from sequence\n   * @param {Number} n A number greater than 0\n   */\n  take(n) {\n    return n > 0 ? this.push(Action.TAKE, n) : this;\n  }\n  /**\n   * Drop a number of values from the sequence\n   * @param {Number} n Number of items to drop greater than 0\n   */\n  drop(n) {\n    return n > 0 ? this.push(Action.DROP, n) : this;\n  }\n  // Transformations\n  /**\n   * Returns a new lazy object with results of the transformation\n   * The entire sequence is realized.\n   *\n   * @param {Callback<Source, RawArray>} fn Tranform function of type (Array) => (Any)\n   */\n  transform(fn) {\n    const self = this;\n    let iter;\n    return Lazy(() => {\n      if (!iter) {\n        iter = Lazy(fn(self.value()));\n      }\n      return iter.next();\n    });\n  }\n  // Terminal methods\n  /**\n   * Returns the fully realized values of the iterators.\n   * The return value will be an array unless `lazy.first()` was used.\n   * The realized values are cached for subsequent calls.\n   */\n  value() {\n    if (!this.isDone) {\n      this.isDone = this.getNext(true).done;\n    }\n    return this.yieldedValues;\n  }\n  /**\n   * Execute the funcion for each value. Will stop when an execution returns false.\n   * @param {Function} f\n   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true\n   */\n  each(f) {\n    for (;;) {\n      const o = this.next();\n      if (o.done) break;\n      if (f(o.value) === false) return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the reduction of sequence according the reducing function\n   *\n   * @param {*} f a reducing function\n   * @param {*} initialValue\n   */\n  reduce(f, initialValue) {\n    let o = this.next();\n    if (initialValue === undefined && !o.done) {\n      initialValue = o.value;\n      o = this.next();\n    }\n    while (!o.done) {\n      initialValue = f(initialValue, o.value);\n      o = this.next();\n    }\n    return initialValue;\n  }\n  /**\n   * Returns the number of matched items in the sequence\n   */\n  size() {\n    return this.reduce((acc, _) => ++acc, 0);\n  }\n  [Symbol.iterator]() {\n    /* eslint-disable @typescript-eslint/no-unsafe-return */\n    return this;\n  }\n}","map":{"version":3,"names":["MingoError","Lazy","source","Iterator","compose","iterators","index","length","o","next","done","isGenerator","Function","dropItem","array","i","rest","slice","splice","Array","prototype","push","apply","DONE","Error","Action","createCallback","nextFn","iteratees","buffer","bufferIndex","storeResult","outer","size","innerDone","r","action","MAP","func","FILTER","TAKE","count","DROP","value","e","constructor","yieldedValues","isDone","nextVal","src","data","getNext","map","f","filter","predicate","take","n","drop","transform","fn","self","iter","each","reduce","initialValue","undefined","acc","_","Symbol","iterator"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/lazy.js"],"sourcesContent":["import { MingoError } from \"./types\";\n/**\n * Returns an iterator\n * @param {*} source An iterable source (Array, Function, Generator, or Iterator)\n */\nexport function Lazy(source) {\n    return source instanceof Iterator ? source : new Iterator(source);\n}\nexport function compose(...iterators) {\n    let index = 0;\n    return Lazy(() => {\n        while (index < iterators.length) {\n            const o = iterators[index].next();\n            if (!o.done)\n                return o;\n            index++;\n        }\n        return { done: true };\n    });\n}\n/**\n * Checks whether the given object is compatible with a generator i.e Object{next:Function}\n * @param {*} o An object\n */\nfunction isGenerator(o) {\n    return (!!o && typeof o === \"object\" && (o === null || o === void 0 ? void 0 : o.next) instanceof Function);\n}\nfunction dropItem(array, i) {\n    const rest = array.slice(i + 1);\n    array.splice(i);\n    Array.prototype.push.apply(array, rest);\n}\n// stop iteration error\nconst DONE = new Error();\n// Lazy function actions\nvar Action;\n(function (Action) {\n    Action[Action[\"MAP\"] = 0] = \"MAP\";\n    Action[Action[\"FILTER\"] = 1] = \"FILTER\";\n    Action[Action[\"TAKE\"] = 2] = \"TAKE\";\n    Action[Action[\"DROP\"] = 3] = \"DROP\";\n})(Action || (Action = {}));\nfunction createCallback(nextFn, iteratees, buffer) {\n    let done = false;\n    let index = -1;\n    let bufferIndex = 0; // index for the buffer\n    return function (storeResult) {\n        // special hack to collect all values into buffer\n        try {\n            outer: while (!done) {\n                let o = nextFn();\n                index++;\n                let i = -1;\n                const size = iteratees.length;\n                let innerDone = false;\n                while (++i < size) {\n                    const r = iteratees[i];\n                    switch (r.action) {\n                        case Action.MAP:\n                            o = r.func(o, index);\n                            break;\n                        case Action.FILTER:\n                            if (!r.func(o, index))\n                                continue outer;\n                            break;\n                        case Action.TAKE:\n                            --r.count;\n                            if (!r.count)\n                                innerDone = true;\n                            break;\n                        case Action.DROP:\n                            --r.count;\n                            if (!r.count)\n                                dropItem(iteratees, i);\n                            continue outer;\n                        default:\n                            break outer;\n                    }\n                }\n                done = innerDone;\n                if (storeResult) {\n                    buffer[bufferIndex++] = o;\n                }\n                else {\n                    return { value: o, done: false };\n                }\n            }\n        }\n        catch (e) {\n            if (e !== DONE)\n                throw e;\n        }\n        done = true;\n        return { done };\n    };\n}\n/**\n * A lazy collection iterator yields a single value at a time upon request.\n */\nexport class Iterator {\n    /**\n     * @param {*} source An iterable object or function.\n     *    Array - return one element per cycle\n     *    Object{next:Function} - call next() for the next value (this also handles generator functions)\n     *    Function - call to return the next value\n     * @param {Function} fn An optional transformation function\n     */\n    constructor(source) {\n        this.iteratees = [];\n        this.yieldedValues = [];\n        this.isDone = false;\n        let nextVal;\n        if (source instanceof Function) {\n            // make iterable\n            source = { next: source };\n        }\n        if (isGenerator(source)) {\n            const src = source;\n            nextVal = () => {\n                const o = src.next();\n                if (o.done)\n                    throw DONE;\n                return o.value;\n            };\n        }\n        else if (source instanceof Array) {\n            const data = source;\n            const size = data.length;\n            let index = 0;\n            nextVal = () => {\n                if (index < size)\n                    return data[index++];\n                throw DONE;\n            };\n        }\n        else if (!(source instanceof Function)) {\n            throw new MingoError(`Lazy must be initialized with an array, generator, or function.`);\n        }\n        // create next function\n        this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);\n    }\n    /**\n     * Add an iteratee to this lazy sequence\n     */\n    push(action, value) {\n        if (typeof value === \"function\") {\n            this.iteratees.push({ action, func: value });\n        }\n        else if (typeof value === \"number\") {\n            this.iteratees.push({ action, count: value });\n        }\n        return this;\n    }\n    next() {\n        return this.getNext();\n    }\n    // Iteratees methods\n    /**\n     * Transform each item in the sequence to a new value\n     * @param {Function} f\n     */\n    map(f) {\n        return this.push(Action.MAP, f);\n    }\n    /**\n     * Select only items matching the given predicate\n     * @param {Function} pred\n     */\n    filter(predicate) {\n        return this.push(Action.FILTER, predicate);\n    }\n    /**\n     * Take given numbe for values from sequence\n     * @param {Number} n A number greater than 0\n     */\n    take(n) {\n        return n > 0 ? this.push(Action.TAKE, n) : this;\n    }\n    /**\n     * Drop a number of values from the sequence\n     * @param {Number} n Number of items to drop greater than 0\n     */\n    drop(n) {\n        return n > 0 ? this.push(Action.DROP, n) : this;\n    }\n    // Transformations\n    /**\n     * Returns a new lazy object with results of the transformation\n     * The entire sequence is realized.\n     *\n     * @param {Callback<Source, RawArray>} fn Tranform function of type (Array) => (Any)\n     */\n    transform(fn) {\n        const self = this;\n        let iter;\n        return Lazy(() => {\n            if (!iter) {\n                iter = Lazy(fn(self.value()));\n            }\n            return iter.next();\n        });\n    }\n    // Terminal methods\n    /**\n     * Returns the fully realized values of the iterators.\n     * The return value will be an array unless `lazy.first()` was used.\n     * The realized values are cached for subsequent calls.\n     */\n    value() {\n        if (!this.isDone) {\n            this.isDone = this.getNext(true).done;\n        }\n        return this.yieldedValues;\n    }\n    /**\n     * Execute the funcion for each value. Will stop when an execution returns false.\n     * @param {Function} f\n     * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true\n     */\n    each(f) {\n        for (;;) {\n            const o = this.next();\n            if (o.done)\n                break;\n            if (f(o.value) === false)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the reduction of sequence according the reducing function\n     *\n     * @param {*} f a reducing function\n     * @param {*} initialValue\n     */\n    reduce(f, initialValue) {\n        let o = this.next();\n        if (initialValue === undefined && !o.done) {\n            initialValue = o.value;\n            o = this.next();\n        }\n        while (!o.done) {\n            initialValue = f(initialValue, o.value);\n            o = this.next();\n        }\n        return initialValue;\n    }\n    /**\n     * Returns the number of matched items in the sequence\n     */\n    size() {\n        return this.reduce(((acc, _) => ++acc), 0);\n    }\n    [Symbol.iterator]() {\n        /* eslint-disable @typescript-eslint/no-unsafe-return */\n        return this;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}