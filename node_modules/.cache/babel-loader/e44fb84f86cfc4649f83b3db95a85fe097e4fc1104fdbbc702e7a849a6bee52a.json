{"ast":null,"code":"// Date Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#date-expression-operators\nimport { computeValue } from \"../../../core\";\nimport { DATE_PART_INTERVAL, isLeapYear, MINUTES_PER_HOUR, parseTimezone } from \"./_internal\";\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst getDaysInMonth = date => {\n  return date.month == 2 && isLeapYear(date.year) ? 29 : DAYS_IN_MONTH[date.month - 1];\n};\n/**\n * Constructs and returns a Date object given the date’s constituent properties.\n *\n * @param obj The document\n * @param expr The date expression\n * @param options Options\n */\nexport const $dateFromParts = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const minuteOffset = parseTimezone(args.timezone);\n  // assign default and adjust value ranges of the different parts\n  for (let i = DATE_PART_INTERVAL.length - 1, remainder = 0; i >= 0; i--) {\n    const datePartInterval = DATE_PART_INTERVAL[i];\n    const k = datePartInterval[0];\n    const min = datePartInterval[1];\n    const max = datePartInterval[2];\n    // add remainder from previous part. units should already be correct\n    let part = (args[k] || 0) + remainder;\n    // reset remainder now that it's been used.\n    remainder = 0;\n    // 1. compute the remainder for the next part\n    // 2. adjust the current part to a valid range\n    // 3. assign back to 'args'\n    const limit = max + 1;\n    // invert timezone to adjust the hours to UTC\n    if (k == \"hour\") part += Math.floor(minuteOffset / MINUTES_PER_HOUR) * -1;\n    if (k == \"minute\") part += minuteOffset % MINUTES_PER_HOUR * -1;\n    // smaller than lower bound\n    if (part < min) {\n      const delta = min - part;\n      remainder = -1 * Math.ceil(delta / limit);\n      part = limit - delta % limit;\n    } else if (part > max) {\n      // offset with the 'min' value to adjust non-zero date parts correctly\n      part += min;\n      remainder = Math.trunc(part / limit);\n      part %= limit;\n    }\n    // reassign\n    args[k] = part;\n  }\n  // adjust end of month to correctly handle overflows\n  args.day = Math.min(args.day, getDaysInMonth(args));\n  return new Date(Date.UTC(args.year, args.month - 1, args.day, args.hour, args.minute, args.second, args.millisecond));\n};","map":{"version":3,"names":["computeValue","DATE_PART_INTERVAL","isLeapYear","MINUTES_PER_HOUR","parseTimezone","DAYS_IN_MONTH","getDaysInMonth","date","month","year","$dateFromParts","obj","expr","options","args","minuteOffset","timezone","i","length","remainder","datePartInterval","k","min","max","part","limit","Math","floor","delta","ceil","trunc","day","Date","UTC","hour","minute","second","millisecond"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/expression/date/dateFromParts.js"],"sourcesContent":["// Date Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#date-expression-operators\nimport { computeValue } from \"../../../core\";\nimport { DATE_PART_INTERVAL, isLeapYear, MINUTES_PER_HOUR, parseTimezone } from \"./_internal\";\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst getDaysInMonth = (date) => {\n    return date.month == 2 && isLeapYear(date.year)\n        ? 29\n        : DAYS_IN_MONTH[date.month - 1];\n};\n/**\n * Constructs and returns a Date object given the date’s constituent properties.\n *\n * @param obj The document\n * @param expr The date expression\n * @param options Options\n */\nexport const $dateFromParts = (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    const minuteOffset = parseTimezone(args.timezone);\n    // assign default and adjust value ranges of the different parts\n    for (let i = DATE_PART_INTERVAL.length - 1, remainder = 0; i >= 0; i--) {\n        const datePartInterval = DATE_PART_INTERVAL[i];\n        const k = datePartInterval[0];\n        const min = datePartInterval[1];\n        const max = datePartInterval[2];\n        // add remainder from previous part. units should already be correct\n        let part = (args[k] || 0) + remainder;\n        // reset remainder now that it's been used.\n        remainder = 0;\n        // 1. compute the remainder for the next part\n        // 2. adjust the current part to a valid range\n        // 3. assign back to 'args'\n        const limit = max + 1;\n        // invert timezone to adjust the hours to UTC\n        if (k == \"hour\")\n            part += Math.floor(minuteOffset / MINUTES_PER_HOUR) * -1;\n        if (k == \"minute\")\n            part += (minuteOffset % MINUTES_PER_HOUR) * -1;\n        // smaller than lower bound\n        if (part < min) {\n            const delta = min - part;\n            remainder = -1 * Math.ceil(delta / limit);\n            part = limit - (delta % limit);\n        }\n        else if (part > max) {\n            // offset with the 'min' value to adjust non-zero date parts correctly\n            part += min;\n            remainder = Math.trunc(part / limit);\n            part %= limit;\n        }\n        // reassign\n        args[k] = part;\n    }\n    // adjust end of month to correctly handle overflows\n    args.day = Math.min(args.day, getDaysInMonth(args));\n    return new Date(Date.UTC(args.year, args.month - 1, args.day, args.hour, args.minute, args.second, args.millisecond));\n};\n"],"mappings":"AAAA;AACA,SAASA,YAAY,QAAQ,eAAe;AAC5C,SAASC,kBAAkB,EAAEC,UAAU,EAAEC,gBAAgB,EAAEC,aAAa,QAAQ,aAAa;AAC7F,MAAMC,aAAa,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;AACtE,MAAMC,cAAc,GAAIC,IAAI,IAAK;EAC7B,OAAOA,IAAI,CAACC,KAAK,IAAI,CAAC,IAAIN,UAAU,CAACK,IAAI,CAACE,IAAI,CAAC,GACzC,EAAE,GACFJ,aAAa,CAACE,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;AACvC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,cAAc,GAAGA,CAACC,GAAG,EAAEC,IAAI,EAAEC,OAAO,KAAK;EAClD,MAAMC,IAAI,GAAGd,YAAY,CAACW,GAAG,EAAEC,IAAI,EAAE,IAAI,EAAEC,OAAO,CAAC;EACnD,MAAME,YAAY,GAAGX,aAAa,CAACU,IAAI,CAACE,QAAQ,CAAC;EACjD;EACA,KAAK,IAAIC,CAAC,GAAGhB,kBAAkB,CAACiB,MAAM,GAAG,CAAC,EAAEC,SAAS,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACpE,MAAMG,gBAAgB,GAAGnB,kBAAkB,CAACgB,CAAC,CAAC;IAC9C,MAAMI,CAAC,GAAGD,gBAAgB,CAAC,CAAC,CAAC;IAC7B,MAAME,GAAG,GAAGF,gBAAgB,CAAC,CAAC,CAAC;IAC/B,MAAMG,GAAG,GAAGH,gBAAgB,CAAC,CAAC,CAAC;IAC/B;IACA,IAAII,IAAI,GAAG,CAACV,IAAI,CAACO,CAAC,CAAC,IAAI,CAAC,IAAIF,SAAS;IACrC;IACAA,SAAS,GAAG,CAAC;IACb;IACA;IACA;IACA,MAAMM,KAAK,GAAGF,GAAG,GAAG,CAAC;IACrB;IACA,IAAIF,CAAC,IAAI,MAAM,EACXG,IAAI,IAAIE,IAAI,CAACC,KAAK,CAACZ,YAAY,GAAGZ,gBAAgB,CAAC,GAAG,CAAC,CAAC;IAC5D,IAAIkB,CAAC,IAAI,QAAQ,EACbG,IAAI,IAAKT,YAAY,GAAGZ,gBAAgB,GAAI,CAAC,CAAC;IAClD;IACA,IAAIqB,IAAI,GAAGF,GAAG,EAAE;MACZ,MAAMM,KAAK,GAAGN,GAAG,GAAGE,IAAI;MACxBL,SAAS,GAAG,CAAC,CAAC,GAAGO,IAAI,CAACG,IAAI,CAACD,KAAK,GAAGH,KAAK,CAAC;MACzCD,IAAI,GAAGC,KAAK,GAAIG,KAAK,GAAGH,KAAM;IAClC,CAAC,MACI,IAAID,IAAI,GAAGD,GAAG,EAAE;MACjB;MACAC,IAAI,IAAIF,GAAG;MACXH,SAAS,GAAGO,IAAI,CAACI,KAAK,CAACN,IAAI,GAAGC,KAAK,CAAC;MACpCD,IAAI,IAAIC,KAAK;IACjB;IACA;IACAX,IAAI,CAACO,CAAC,CAAC,GAAGG,IAAI;EAClB;EACA;EACAV,IAAI,CAACiB,GAAG,GAAGL,IAAI,CAACJ,GAAG,CAACR,IAAI,CAACiB,GAAG,EAAEzB,cAAc,CAACQ,IAAI,CAAC,CAAC;EACnD,OAAO,IAAIkB,IAAI,CAACA,IAAI,CAACC,GAAG,CAACnB,IAAI,CAACL,IAAI,EAAEK,IAAI,CAACN,KAAK,GAAG,CAAC,EAAEM,IAAI,CAACiB,GAAG,EAAEjB,IAAI,CAACoB,IAAI,EAAEpB,IAAI,CAACqB,MAAM,EAAErB,IAAI,CAACsB,MAAM,EAAEtB,IAAI,CAACuB,WAAW,CAAC,CAAC;AACzH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}