{"ast":null,"code":"import { computeValue } from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport { assert, compare, findInsertIndex, getType, into, isNil } from \"../../util\";\n/**\n * Categorizes incoming documents into groups, called buckets, based on a specified expression and bucket boundaries.\n * https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/\n *\n * @param {*} collection\n * @param {*} expr\n * @param {Options} opt Pipeline options\n */\nexport const $bucket = (collection, expr, options) => {\n  const boundaries = [...expr.boundaries];\n  const defaultKey = expr.default;\n  const lower = boundaries[0]; // inclusive\n  const upper = boundaries[boundaries.length - 1]; // exclusive\n  const outputExpr = expr.output || {\n    count: {\n      $sum: 1\n    }\n  };\n  assert(expr.boundaries.length > 2, \"$bucket 'boundaries' expression must have at least 3 elements\");\n  const boundType = getType(lower);\n  for (let i = 0, len = boundaries.length - 1; i < len; i++) {\n    assert(boundType === getType(boundaries[i + 1]), \"$bucket 'boundaries' must all be of the same type\");\n    assert(compare(boundaries[i], boundaries[i + 1]) < 0, \"$bucket 'boundaries' must be sorted in ascending order\");\n  }\n  !isNil(defaultKey) && getType(expr.default) === getType(lower) && assert(compare(expr.default, upper) >= 0 || compare(expr.default, lower) < 0, \"$bucket 'default' expression must be out of boundaries range\");\n  const grouped = {};\n  for (const k of boundaries) {\n    grouped[k] = [];\n  }\n  // add default key if provided\n  if (!isNil(defaultKey)) grouped[defaultKey] = [];\n  let iterator;\n  return Lazy(() => {\n    if (!iterator) {\n      collection.each(obj => {\n        const key = computeValue(obj, expr.groupBy, null, options);\n        if (isNil(key) || compare(key, lower) < 0 || compare(key, upper) >= 0) {\n          assert(!isNil(defaultKey), \"$bucket require a default for out of range values\");\n          grouped[defaultKey].push(obj);\n        } else {\n          assert(compare(key, lower) >= 0 && compare(key, upper) < 0, \"$bucket 'groupBy' expression must resolve to a value in range of boundaries\");\n          const index = findInsertIndex(boundaries, key);\n          const boundKey = boundaries[Math.max(0, index - 1)];\n          grouped[boundKey].push(obj);\n        }\n      });\n      // upper bound is exclusive so we remove it\n      boundaries.pop();\n      if (!isNil(defaultKey)) boundaries.push(defaultKey);\n      iterator = Lazy(boundaries).map(key => {\n        const acc = computeValue(grouped[key], outputExpr, null, options);\n        return into(acc, {\n          _id: key\n        });\n      });\n    }\n    return iterator.next();\n  });\n};","map":{"version":3,"names":["computeValue","Lazy","assert","compare","findInsertIndex","getType","into","isNil","$bucket","collection","expr","options","boundaries","defaultKey","default","lower","upper","length","outputExpr","output","count","$sum","boundType","i","len","grouped","k","iterator","each","obj","key","groupBy","push","index","boundKey","Math","max","pop","map","acc","_id","next"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/pipeline/bucket.js"],"sourcesContent":["import { computeValue } from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport { assert, compare, findInsertIndex, getType, into, isNil } from \"../../util\";\n/**\n * Categorizes incoming documents into groups, called buckets, based on a specified expression and bucket boundaries.\n * https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/\n *\n * @param {*} collection\n * @param {*} expr\n * @param {Options} opt Pipeline options\n */\nexport const $bucket = (collection, expr, options) => {\n    const boundaries = [...expr.boundaries];\n    const defaultKey = expr.default;\n    const lower = boundaries[0]; // inclusive\n    const upper = boundaries[boundaries.length - 1]; // exclusive\n    const outputExpr = expr.output || { count: { $sum: 1 } };\n    assert(expr.boundaries.length > 2, \"$bucket 'boundaries' expression must have at least 3 elements\");\n    const boundType = getType(lower);\n    for (let i = 0, len = boundaries.length - 1; i < len; i++) {\n        assert(boundType === getType(boundaries[i + 1]), \"$bucket 'boundaries' must all be of the same type\");\n        assert(compare(boundaries[i], boundaries[i + 1]) < 0, \"$bucket 'boundaries' must be sorted in ascending order\");\n    }\n    !isNil(defaultKey) &&\n        getType(expr.default) === getType(lower) &&\n        assert(compare(expr.default, upper) >= 0 || compare(expr.default, lower) < 0, \"$bucket 'default' expression must be out of boundaries range\");\n    const grouped = {};\n    for (const k of boundaries) {\n        grouped[k] = [];\n    }\n    // add default key if provided\n    if (!isNil(defaultKey))\n        grouped[defaultKey] = [];\n    let iterator;\n    return Lazy(() => {\n        if (!iterator) {\n            collection.each(((obj) => {\n                const key = computeValue(obj, expr.groupBy, null, options);\n                if (isNil(key) || compare(key, lower) < 0 || compare(key, upper) >= 0) {\n                    assert(!isNil(defaultKey), \"$bucket require a default for out of range values\");\n                    grouped[defaultKey].push(obj);\n                }\n                else {\n                    assert(compare(key, lower) >= 0 && compare(key, upper) < 0, \"$bucket 'groupBy' expression must resolve to a value in range of boundaries\");\n                    const index = findInsertIndex(boundaries, key);\n                    const boundKey = boundaries[Math.max(0, index - 1)];\n                    grouped[boundKey].push(obj);\n                }\n            }));\n            // upper bound is exclusive so we remove it\n            boundaries.pop();\n            if (!isNil(defaultKey))\n                boundaries.push(defaultKey);\n            iterator = Lazy(boundaries).map(((key) => {\n                const acc = computeValue(grouped[key], outputExpr, null, options);\n                return into(acc, { _id: key });\n            }));\n        }\n        return iterator.next();\n    });\n};\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,YAAY;AACzC,SAASC,IAAI,QAAQ,YAAY;AACjC,SAASC,MAAM,EAAEC,OAAO,EAAEC,eAAe,EAAEC,OAAO,EAAEC,IAAI,EAAEC,KAAK,QAAQ,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAGA,CAACC,UAAU,EAAEC,IAAI,EAAEC,OAAO,KAAK;EAClD,MAAMC,UAAU,GAAG,CAAC,GAAGF,IAAI,CAACE,UAAU,CAAC;EACvC,MAAMC,UAAU,GAAGH,IAAI,CAACI,OAAO;EAC/B,MAAMC,KAAK,GAAGH,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;EAC7B,MAAMI,KAAK,GAAGJ,UAAU,CAACA,UAAU,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;EACjD,MAAMC,UAAU,GAAGR,IAAI,CAACS,MAAM,IAAI;IAAEC,KAAK,EAAE;MAAEC,IAAI,EAAE;IAAE;EAAE,CAAC;EACxDnB,MAAM,CAACQ,IAAI,CAACE,UAAU,CAACK,MAAM,GAAG,CAAC,EAAE,+DAA+D,CAAC;EACnG,MAAMK,SAAS,GAAGjB,OAAO,CAACU,KAAK,CAAC;EAChC,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGZ,UAAU,CAACK,MAAM,GAAG,CAAC,EAAEM,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IACvDrB,MAAM,CAACoB,SAAS,KAAKjB,OAAO,CAACO,UAAU,CAACW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,mDAAmD,CAAC;IACrGrB,MAAM,CAACC,OAAO,CAACS,UAAU,CAACW,CAAC,CAAC,EAAEX,UAAU,CAACW,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,wDAAwD,CAAC;EACnH;EACA,CAAChB,KAAK,CAACM,UAAU,CAAC,IACdR,OAAO,CAACK,IAAI,CAACI,OAAO,CAAC,KAAKT,OAAO,CAACU,KAAK,CAAC,IACxCb,MAAM,CAACC,OAAO,CAACO,IAAI,CAACI,OAAO,EAAEE,KAAK,CAAC,IAAI,CAAC,IAAIb,OAAO,CAACO,IAAI,CAACI,OAAO,EAAEC,KAAK,CAAC,GAAG,CAAC,EAAE,8DAA8D,CAAC;EACjJ,MAAMU,OAAO,GAAG,CAAC,CAAC;EAClB,KAAK,MAAMC,CAAC,IAAId,UAAU,EAAE;IACxBa,OAAO,CAACC,CAAC,CAAC,GAAG,EAAE;EACnB;EACA;EACA,IAAI,CAACnB,KAAK,CAACM,UAAU,CAAC,EAClBY,OAAO,CAACZ,UAAU,CAAC,GAAG,EAAE;EAC5B,IAAIc,QAAQ;EACZ,OAAO1B,IAAI,CAAC,MAAM;IACd,IAAI,CAAC0B,QAAQ,EAAE;MACXlB,UAAU,CAACmB,IAAI,CAAGC,GAAG,IAAK;QACtB,MAAMC,GAAG,GAAG9B,YAAY,CAAC6B,GAAG,EAAEnB,IAAI,CAACqB,OAAO,EAAE,IAAI,EAAEpB,OAAO,CAAC;QAC1D,IAAIJ,KAAK,CAACuB,GAAG,CAAC,IAAI3B,OAAO,CAAC2B,GAAG,EAAEf,KAAK,CAAC,GAAG,CAAC,IAAIZ,OAAO,CAAC2B,GAAG,EAAEd,KAAK,CAAC,IAAI,CAAC,EAAE;UACnEd,MAAM,CAAC,CAACK,KAAK,CAACM,UAAU,CAAC,EAAE,mDAAmD,CAAC;UAC/EY,OAAO,CAACZ,UAAU,CAAC,CAACmB,IAAI,CAACH,GAAG,CAAC;QACjC,CAAC,MACI;UACD3B,MAAM,CAACC,OAAO,CAAC2B,GAAG,EAAEf,KAAK,CAAC,IAAI,CAAC,IAAIZ,OAAO,CAAC2B,GAAG,EAAEd,KAAK,CAAC,GAAG,CAAC,EAAE,6EAA6E,CAAC;UAC1I,MAAMiB,KAAK,GAAG7B,eAAe,CAACQ,UAAU,EAAEkB,GAAG,CAAC;UAC9C,MAAMI,QAAQ,GAAGtB,UAAU,CAACuB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEH,KAAK,GAAG,CAAC,CAAC,CAAC;UACnDR,OAAO,CAACS,QAAQ,CAAC,CAACF,IAAI,CAACH,GAAG,CAAC;QAC/B;MACJ,CAAE,CAAC;MACH;MACAjB,UAAU,CAACyB,GAAG,CAAC,CAAC;MAChB,IAAI,CAAC9B,KAAK,CAACM,UAAU,CAAC,EAClBD,UAAU,CAACoB,IAAI,CAACnB,UAAU,CAAC;MAC/Bc,QAAQ,GAAG1B,IAAI,CAACW,UAAU,CAAC,CAAC0B,GAAG,CAAGR,GAAG,IAAK;QACtC,MAAMS,GAAG,GAAGvC,YAAY,CAACyB,OAAO,CAACK,GAAG,CAAC,EAAEZ,UAAU,EAAE,IAAI,EAAEP,OAAO,CAAC;QACjE,OAAOL,IAAI,CAACiC,GAAG,EAAE;UAAEC,GAAG,EAAEV;QAAI,CAAC,CAAC;MAClC,CAAE,CAAC;IACP;IACA,OAAOH,QAAQ,CAACc,IAAI,CAAC,CAAC;EAC1B,CAAC,CAAC;AACN,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}