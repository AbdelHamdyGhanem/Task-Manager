{"ast":null,"code":"import { isNumber } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { withMemo } from \"./_internal\";\n/**\n * Given two points (x1, y1) and (x2, y2) and a value 'x' that lies between those two points,\n * solve for 'y' with: y = y1 + (x - x1) * ((y2 - y1)/(x2 - x1)).\n * @see https://en.wikipedia.org/wiki/Linear_interpolation\n */\nconst interpolate = (x1, y1, x2, y2, x) => y1 + (x - x1) * ((y2 - y1) / (x2 - x1));\n/**\n * Fills null and missing fields in a window using linear interpolation based on surrounding field values.\n */\nexport function $linearFill(_, collection, expr, options) {\n  return withMemo(collection, expr, () => {\n    const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n    const points = $push(collection, [sortKey, expr.inputExpr], options).filter(([x, _]) => isNumber(+x));\n    if (points.length !== collection.length) return null;\n    let lindex = -1;\n    let rindex = 0;\n    while (rindex < points.length) {\n      // use sliding window over missing values and fill as we go.\n      // determine nearest left value index\n      while (lindex + 1 < points.length && isNumber(points[lindex + 1][1])) {\n        lindex++;\n        rindex = lindex;\n      }\n      // determine nearest right value index.\n      while (rindex + 1 < points.length && !isNumber(points[rindex + 1][1])) {\n        rindex++;\n      }\n      // we reached the end of our array. nothing more to do.\n      if (rindex + 1 >= points.length) break;\n      // otherwise, we found a number so move rindex pointer to it.\n      rindex++;\n      // now fill everything between lindex and rindex by their proportions to the difference.\n      while (lindex + 1 < rindex) {\n        points[lindex + 1][1] = interpolate(points[lindex][0], points[lindex][1], points[rindex][0], points[rindex][1], points[lindex + 1][0]);\n        lindex++;\n      }\n      // move lindex to right\n      lindex = rindex;\n    }\n    return points.map(([_, y]) => y);\n  }, values => values[expr.documentNumber - 1]);\n}","map":{"version":3,"names":["isNumber","$push","withMemo","interpolate","x1","y1","x2","y2","x","$linearFill","_","collection","expr","options","sortKey","Object","keys","parentExpr","sortBy","points","inputExpr","filter","length","lindex","rindex","map","y","values","documentNumber"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/window/linearFill.js"],"sourcesContent":["import { isNumber } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { withMemo } from \"./_internal\";\n/**\n * Given two points (x1, y1) and (x2, y2) and a value 'x' that lies between those two points,\n * solve for 'y' with: y = y1 + (x - x1) * ((y2 - y1)/(x2 - x1)).\n * @see https://en.wikipedia.org/wiki/Linear_interpolation\n */\nconst interpolate = (x1, y1, x2, y2, x) => y1 + (x - x1) * ((y2 - y1) / (x2 - x1));\n/**\n * Fills null and missing fields in a window using linear interpolation based on surrounding field values.\n */\nexport function $linearFill(_, collection, expr, options) {\n    return withMemo(collection, expr, (() => {\n        const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n        const points = $push(collection, [sortKey, expr.inputExpr], options).filter((([x, _]) => isNumber(+x)));\n        if (points.length !== collection.length)\n            return null;\n        let lindex = -1;\n        let rindex = 0;\n        while (rindex < points.length) {\n            // use sliding window over missing values and fill as we go.\n            // determine nearest left value index\n            while (lindex + 1 < points.length && isNumber(points[lindex + 1][1])) {\n                lindex++;\n                rindex = lindex;\n            }\n            // determine nearest right value index.\n            while (rindex + 1 < points.length && !isNumber(points[rindex + 1][1])) {\n                rindex++;\n            }\n            // we reached the end of our array. nothing more to do.\n            if (rindex + 1 >= points.length)\n                break;\n            // otherwise, we found a number so move rindex pointer to it.\n            rindex++;\n            // now fill everything between lindex and rindex by their proportions to the difference.\n            while (lindex + 1 < rindex) {\n                points[lindex + 1][1] = interpolate(points[lindex][0], points[lindex][1], points[rindex][0], points[rindex][1], points[lindex + 1][0]);\n                lindex++;\n            }\n            // move lindex to right\n            lindex = rindex;\n        }\n        return points.map(([_, y]) => y);\n    }), (values) => values[expr.documentNumber - 1]);\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,YAAY;AACrC,SAASC,KAAK,QAAQ,gBAAgB;AACtC,SAASC,QAAQ,QAAQ,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAGA,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,CAAC,KAAKH,EAAE,GAAG,CAACG,CAAC,GAAGJ,EAAE,KAAK,CAACG,EAAE,GAAGF,EAAE,KAAKC,EAAE,GAAGF,EAAE,CAAC,CAAC;AAClF;AACA;AACA;AACA,OAAO,SAASK,WAAWA,CAACC,CAAC,EAAEC,UAAU,EAAEC,IAAI,EAAEC,OAAO,EAAE;EACtD,OAAOX,QAAQ,CAACS,UAAU,EAAEC,IAAI,EAAG,MAAM;IACrC,MAAME,OAAO,GAAG,GAAG,GAAGC,MAAM,CAACC,IAAI,CAACJ,IAAI,CAACK,UAAU,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC5D,MAAMC,MAAM,GAAGlB,KAAK,CAACU,UAAU,EAAE,CAACG,OAAO,EAAEF,IAAI,CAACQ,SAAS,CAAC,EAAEP,OAAO,CAAC,CAACQ,MAAM,CAAE,CAAC,CAACb,CAAC,EAAEE,CAAC,CAAC,KAAKV,QAAQ,CAAC,CAACQ,CAAC,CAAE,CAAC;IACvG,IAAIW,MAAM,CAACG,MAAM,KAAKX,UAAU,CAACW,MAAM,EACnC,OAAO,IAAI;IACf,IAAIC,MAAM,GAAG,CAAC,CAAC;IACf,IAAIC,MAAM,GAAG,CAAC;IACd,OAAOA,MAAM,GAAGL,MAAM,CAACG,MAAM,EAAE;MAC3B;MACA;MACA,OAAOC,MAAM,GAAG,CAAC,GAAGJ,MAAM,CAACG,MAAM,IAAItB,QAAQ,CAACmB,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;QAClEA,MAAM,EAAE;QACRC,MAAM,GAAGD,MAAM;MACnB;MACA;MACA,OAAOC,MAAM,GAAG,CAAC,GAAGL,MAAM,CAACG,MAAM,IAAI,CAACtB,QAAQ,CAACmB,MAAM,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;QACnEA,MAAM,EAAE;MACZ;MACA;MACA,IAAIA,MAAM,GAAG,CAAC,IAAIL,MAAM,CAACG,MAAM,EAC3B;MACJ;MACAE,MAAM,EAAE;MACR;MACA,OAAOD,MAAM,GAAG,CAAC,GAAGC,MAAM,EAAE;QACxBL,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGpB,WAAW,CAACgB,MAAM,CAACI,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEJ,MAAM,CAACI,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEJ,MAAM,CAACK,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEL,MAAM,CAACK,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEL,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtIA,MAAM,EAAE;MACZ;MACA;MACAA,MAAM,GAAGC,MAAM;IACnB;IACA,OAAOL,MAAM,CAACM,GAAG,CAAC,CAAC,CAACf,CAAC,EAAEgB,CAAC,CAAC,KAAKA,CAAC,CAAC;EACpC,CAAC,EAAIC,MAAM,IAAKA,MAAM,CAACf,IAAI,CAACgB,cAAc,GAAG,CAAC,CAAC,CAAC;AACpD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}