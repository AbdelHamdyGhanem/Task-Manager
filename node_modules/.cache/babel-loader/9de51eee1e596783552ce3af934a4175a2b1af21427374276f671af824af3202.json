{"ast":null,"code":"// Array Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#array-expression-operators\nimport { computeValue } from \"../../../core\";\nimport { assert, isNil } from \"../../../util\";\n/**\n * Returns a subset of an array.\n *\n * @param  {Object} obj\n * @param  {*} expr\n * @return {*}\n */\nexport const $slice = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const arr = args[0];\n  let skip = args[1];\n  let limit = args[2];\n  // MongoDB $slice works a bit differently from Array.slice\n  // Uses single argument for 'limit' and array argument [skip, limit]\n  if (isNil(limit)) {\n    if (skip < 0) {\n      skip = Math.max(0, arr.length + skip);\n      limit = arr.length - skip + 1;\n    } else {\n      limit = skip;\n      skip = 0;\n    }\n  } else {\n    if (skip < 0) {\n      skip = Math.max(0, arr.length + skip);\n    }\n    assert(limit > 0, `Invalid argument for $slice operator. Limit must be a positive number`);\n    limit += skip;\n  }\n  return arr.slice(skip, limit);\n};","map":{"version":3,"names":["computeValue","assert","isNil","$slice","obj","expr","options","args","arr","skip","limit","Math","max","length","slice"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/expression/array/slice.js"],"sourcesContent":["// Array Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#array-expression-operators\nimport { computeValue } from \"../../../core\";\nimport { assert, isNil } from \"../../../util\";\n/**\n * Returns a subset of an array.\n *\n * @param  {Object} obj\n * @param  {*} expr\n * @return {*}\n */\nexport const $slice = (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    const arr = args[0];\n    let skip = args[1];\n    let limit = args[2];\n    // MongoDB $slice works a bit differently from Array.slice\n    // Uses single argument for 'limit' and array argument [skip, limit]\n    if (isNil(limit)) {\n        if (skip < 0) {\n            skip = Math.max(0, arr.length + skip);\n            limit = arr.length - skip + 1;\n        }\n        else {\n            limit = skip;\n            skip = 0;\n        }\n    }\n    else {\n        if (skip < 0) {\n            skip = Math.max(0, arr.length + skip);\n        }\n        assert(limit > 0, `Invalid argument for $slice operator. Limit must be a positive number`);\n        limit += skip;\n    }\n    return arr.slice(skip, limit);\n};\n"],"mappings":"AAAA;AACA,SAASA,YAAY,QAAQ,eAAe;AAC5C,SAASC,MAAM,EAAEC,KAAK,QAAQ,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGA,CAACC,GAAG,EAAEC,IAAI,EAAEC,OAAO,KAAK;EAC1C,MAAMC,IAAI,GAAGP,YAAY,CAACI,GAAG,EAAEC,IAAI,EAAE,IAAI,EAAEC,OAAO,CAAC;EACnD,MAAME,GAAG,GAAGD,IAAI,CAAC,CAAC,CAAC;EACnB,IAAIE,IAAI,GAAGF,IAAI,CAAC,CAAC,CAAC;EAClB,IAAIG,KAAK,GAAGH,IAAI,CAAC,CAAC,CAAC;EACnB;EACA;EACA,IAAIL,KAAK,CAACQ,KAAK,CAAC,EAAE;IACd,IAAID,IAAI,GAAG,CAAC,EAAE;MACVA,IAAI,GAAGE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEJ,GAAG,CAACK,MAAM,GAAGJ,IAAI,CAAC;MACrCC,KAAK,GAAGF,GAAG,CAACK,MAAM,GAAGJ,IAAI,GAAG,CAAC;IACjC,CAAC,MACI;MACDC,KAAK,GAAGD,IAAI;MACZA,IAAI,GAAG,CAAC;IACZ;EACJ,CAAC,MACI;IACD,IAAIA,IAAI,GAAG,CAAC,EAAE;MACVA,IAAI,GAAGE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEJ,GAAG,CAACK,MAAM,GAAGJ,IAAI,CAAC;IACzC;IACAR,MAAM,CAACS,KAAK,GAAG,CAAC,EAAE,uEAAuE,CAAC;IAC1FA,KAAK,IAAID,IAAI;EACjB;EACA,OAAOD,GAAG,CAACM,KAAK,CAACL,IAAI,EAAEC,KAAK,CAAC;AACjC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}