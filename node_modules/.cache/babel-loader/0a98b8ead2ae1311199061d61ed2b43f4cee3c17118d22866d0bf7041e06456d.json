{"ast":null,"code":"/**\n * represents the branches of a single node\n */\nexport class Branches {\n  node;\n  deleted = false;\n  branches = {};\n  constructor(node) {\n    this.node = node;\n  }\n  setBranch(which, branchNode) {\n    const previous = this.branches[which];\n    if (previous === branchNode) {\n      return;\n    }\n    // set new branch\n    this.branches[which] = branchNode;\n    branchNode.parents.add(this.node);\n  }\n  getKeyOfNode(node) {\n    if (this.getBranch('0') === node) {\n      return '0';\n    } else if (this.getBranch('1') === node) {\n      return '1';\n    } else {\n      throw new Error('none matched');\n    }\n  }\n  getBranch(which) {\n    return this.branches[which];\n  }\n  getBothBranches() {\n    return [this.getBranch('0'), this.getBranch('1')];\n  }\n  hasBranchAsNode(node) {\n    if (this.getBranch('0') === node || this.getBranch('1') === node) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  hasNodeIdAsBranch(id) {\n    if (this.getBranch('0').id === id || this.getBranch('1').id === id) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  areBranchesStrictEqual() {\n    return this.branches['0'] === this.branches['1'];\n  }\n  hasEqualBranches() {\n    return JSON.stringify(this.branches['0']) === JSON.stringify(this.branches['1']);\n  }\n}\nexport function ensureNodesNotStrictEqual(node1, node2) {\n  if (node1 === node2) {\n    throw new Error('cannot have two strict equal branches');\n  }\n}","map":{"version":3,"names":["Branches","node","deleted","branches","constructor","setBranch","which","branchNode","previous","parents","add","getKeyOfNode","getBranch","Error","getBothBranches","hasBranchAsNode","hasNodeIdAsBranch","id","areBranchesStrictEqual","hasEqualBranches","JSON","stringify","ensureNodesNotStrictEqual","node1","node2"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/binary-decision-diagram/src/branches.ts"],"sourcesContent":["import type { BooleanString, NonRootNode, NonLeafNode } from './types.js';\nimport { AbstractNode } from './abstract-node.js';\n\n/**\n * represents the branches of a single node\n */\nexport class Branches {\n    public deleted: boolean = false;\n    private branches: {\n        [k in BooleanString]: NonRootNode\n    } = {} as any;\n\n    constructor(\n        private node: NonLeafNode\n    ) { }\n\n    public setBranch(which: BooleanString, branchNode: NonRootNode) {\n        const previous = this.branches[which];\n        if (previous === branchNode) {\n            return;\n        }\n\n        // set new branch\n        this.branches[which] = branchNode;\n        branchNode.parents.add(this.node);\n    }\n\n    public getKeyOfNode(node: NonRootNode): BooleanString {\n        if (this.getBranch('0') === node) {\n            return '0';\n        } else if (this.getBranch('1') === node) {\n            return '1';\n        } else {\n            throw new Error('none matched');\n        }\n    }\n\n    public getBranch(which: BooleanString): NonRootNode {\n        return this.branches[which];\n    }\n\n    public getBothBranches(): NonRootNode[] {\n        return [\n            this.getBranch('0'),\n            this.getBranch('1')\n        ];\n    }\n\n    public hasBranchAsNode(node: AbstractNode): boolean {\n        if (\n            this.getBranch('0') === node ||\n            this.getBranch('1') === node\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public hasNodeIdAsBranch(id: string): boolean {\n        if (\n            this.getBranch('0').id === id ||\n            this.getBranch('1').id === id\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public areBranchesStrictEqual() {\n        return this.branches['0'] === this.branches['1'];\n    }\n\n    public hasEqualBranches() {\n        return JSON.stringify(this.branches['0']) ===\n            JSON.stringify(this.branches['1']);\n    }\n}\n\nexport function ensureNodesNotStrictEqual(\n    node1: NonRootNode,\n    node2: NonRootNode\n) {\n    if (node1 === node2) {\n        throw new Error('cannot have two strict equal branches');\n    }\n}\n"],"mappings":"AAGA;;;AAGA,OAAM,MAAOA,QAAQ;EAOLC,IAAA;EANLC,OAAO,GAAY,KAAK;EACvBC,QAAQ,GAEZ,EAAS;EAEbC,YACYH,IAAiB;IAAjB,KAAAA,IAAI,GAAJA,IAAI;EACZ;EAEGI,SAASA,CAACC,KAAoB,EAAEC,UAAuB;IAC1D,MAAMC,QAAQ,GAAG,IAAI,CAACL,QAAQ,CAACG,KAAK,CAAC;IACrC,IAAIE,QAAQ,KAAKD,UAAU,EAAE;MACzB;IACJ;IAEA;IACA,IAAI,CAACJ,QAAQ,CAACG,KAAK,CAAC,GAAGC,UAAU;IACjCA,UAAU,CAACE,OAAO,CAACC,GAAG,CAAC,IAAI,CAACT,IAAI,CAAC;EACrC;EAEOU,YAAYA,CAACV,IAAiB;IACjC,IAAI,IAAI,CAACW,SAAS,CAAC,GAAG,CAAC,KAAKX,IAAI,EAAE;MAC9B,OAAO,GAAG;IACd,CAAC,MAAM,IAAI,IAAI,CAACW,SAAS,CAAC,GAAG,CAAC,KAAKX,IAAI,EAAE;MACrC,OAAO,GAAG;IACd,CAAC,MAAM;MACH,MAAM,IAAIY,KAAK,CAAC,cAAc,CAAC;IACnC;EACJ;EAEOD,SAASA,CAACN,KAAoB;IACjC,OAAO,IAAI,CAACH,QAAQ,CAACG,KAAK,CAAC;EAC/B;EAEOQ,eAAeA,CAAA;IAClB,OAAO,CACH,IAAI,CAACF,SAAS,CAAC,GAAG,CAAC,EACnB,IAAI,CAACA,SAAS,CAAC,GAAG,CAAC,CACtB;EACL;EAEOG,eAAeA,CAACd,IAAkB;IACrC,IACI,IAAI,CAACW,SAAS,CAAC,GAAG,CAAC,KAAKX,IAAI,IAC5B,IAAI,CAACW,SAAS,CAAC,GAAG,CAAC,KAAKX,IAAI,EAC9B;MACE,OAAO,IAAI;IACf,CAAC,MAAM;MACH,OAAO,KAAK;IAChB;EACJ;EAEOe,iBAAiBA,CAACC,EAAU;IAC/B,IACI,IAAI,CAACL,SAAS,CAAC,GAAG,CAAC,CAACK,EAAE,KAAKA,EAAE,IAC7B,IAAI,CAACL,SAAS,CAAC,GAAG,CAAC,CAACK,EAAE,KAAKA,EAAE,EAC/B;MACE,OAAO,IAAI;IACf,CAAC,MAAM;MACH,OAAO,KAAK;IAChB;EACJ;EAEOC,sBAAsBA,CAAA;IACzB,OAAO,IAAI,CAACf,QAAQ,CAAC,GAAG,CAAC,KAAK,IAAI,CAACA,QAAQ,CAAC,GAAG,CAAC;EACpD;EAEOgB,gBAAgBA,CAAA;IACnB,OAAOC,IAAI,CAACC,SAAS,CAAC,IAAI,CAAClB,QAAQ,CAAC,GAAG,CAAC,CAAC,KACrCiB,IAAI,CAACC,SAAS,CAAC,IAAI,CAAClB,QAAQ,CAAC,GAAG,CAAC,CAAC;EAC1C;;AAGJ,OAAM,SAAUmB,yBAAyBA,CACrCC,KAAkB,EAClBC,KAAkB;EAElB,IAAID,KAAK,KAAKC,KAAK,EAAE;IACjB,MAAM,IAAIX,KAAK,CAAC,uCAAuC,CAAC;EAC5D;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}