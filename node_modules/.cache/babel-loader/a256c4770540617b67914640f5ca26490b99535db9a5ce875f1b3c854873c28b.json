{"ast":null,"code":"import { MingoError } from \"../../types\";\nimport { groupBy, isEqual } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { MILLIS_PER_DAY } from \"../expression/date/_internal\";\nimport { isUnbounded } from \"../pipeline/_internal\";\n// millis map to diffirent time units\nexport const MILLIS_PER_UNIT = {\n  week: MILLIS_PER_DAY * 7,\n  day: MILLIS_PER_DAY,\n  hour: MILLIS_PER_DAY / 24,\n  minute: 60000,\n  second: 1000,\n  millisecond: 1\n};\n// internal cache to store precomputed series once to avoid O(N^2) calls to over the collection\nconst memo = new WeakMap();\n/**\n * Caches all computed values in a window sequence for reuse.\n * This is only useful for operations with unbounded documents.\n */\nexport function withMemo(collection, expr, cacheFn, fn) {\n  // no caching done for bounded inputs\n  if (!isUnbounded(expr.parentExpr.output[expr.field].window)) {\n    return fn(cacheFn());\n  }\n  // first time using collection\n  if (!memo.has(collection)) {\n    memo.set(collection, {\n      [expr.field]: cacheFn()\n    });\n  }\n  const data = memo.get(collection);\n  // subsequent computations over the same collection.\n  if (data[expr.field] === undefined) {\n    data[expr.field] = cacheFn();\n  }\n  let failed = false;\n  try {\n    return fn(data[expr.field]);\n  } catch (e) {\n    failed = true;\n  } finally {\n    // cleanup on failure or last element in collection.\n    if (failed || expr.documentNumber === collection.length) {\n      delete data[expr.field];\n      if (Object.keys(data).length === 0) memo.delete(collection);\n    }\n  }\n}\n/** Returns the position of a document in the $setWindowFields stage partition. */\nexport function rank(_, collection, expr, options, dense) {\n  return withMemo(collection, expr, () => {\n    const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n    const values = $push(collection, sortKey, options);\n    const groups = groupBy(values, (_, n) => values[n], options.hashFunction);\n    return {\n      values,\n      groups\n    };\n  }, input => {\n    const {\n      values,\n      groups: partitions\n    } = input;\n    // same number of paritions as length means all sort keys are unique\n    if (partitions.size == collection.length) {\n      return expr.documentNumber;\n    }\n    const current = values[expr.documentNumber - 1];\n    let i = 0;\n    let offset = 0;\n    // partition keys are already dense so just return the value on match\n    for (const key of partitions.keys()) {\n      if (isEqual(current, key)) {\n        return dense ? i + 1 : offset + 1;\n      }\n      i++;\n      offset += partitions.get(key).length;\n    }\n    // should be unreachable\n    throw new MingoError(\"rank: invalid return value. please submit a bug report.\");\n  });\n}","map":{"version":3,"names":["MingoError","groupBy","isEqual","$push","MILLIS_PER_DAY","isUnbounded","MILLIS_PER_UNIT","week","day","hour","minute","second","millisecond","memo","WeakMap","withMemo","collection","expr","cacheFn","fn","parentExpr","output","field","window","has","set","data","get","undefined","failed","e","documentNumber","length","Object","keys","delete","rank","_","options","dense","sortKey","sortBy","values","groups","n","hashFunction","input","partitions","size","current","i","offset","key"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/window/_internal.js"],"sourcesContent":["import { MingoError } from \"../../types\";\nimport { groupBy, isEqual } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { MILLIS_PER_DAY } from \"../expression/date/_internal\";\nimport { isUnbounded } from \"../pipeline/_internal\";\n// millis map to diffirent time units\nexport const MILLIS_PER_UNIT = {\n    week: MILLIS_PER_DAY * 7,\n    day: MILLIS_PER_DAY,\n    hour: MILLIS_PER_DAY / 24,\n    minute: 60000,\n    second: 1000,\n    millisecond: 1\n};\n// internal cache to store precomputed series once to avoid O(N^2) calls to over the collection\nconst memo = new WeakMap();\n/**\n * Caches all computed values in a window sequence for reuse.\n * This is only useful for operations with unbounded documents.\n */\nexport function withMemo(collection, expr, cacheFn, fn) {\n    // no caching done for bounded inputs\n    if (!isUnbounded(expr.parentExpr.output[expr.field].window)) {\n        return fn(cacheFn());\n    }\n    // first time using collection\n    if (!memo.has(collection)) {\n        memo.set(collection, { [expr.field]: cacheFn() });\n    }\n    const data = memo.get(collection);\n    // subsequent computations over the same collection.\n    if (data[expr.field] === undefined) {\n        data[expr.field] = cacheFn();\n    }\n    let failed = false;\n    try {\n        return fn(data[expr.field]);\n    }\n    catch (e) {\n        failed = true;\n    }\n    finally {\n        // cleanup on failure or last element in collection.\n        if (failed || expr.documentNumber === collection.length) {\n            delete data[expr.field];\n            if (Object.keys(data).length === 0)\n                memo.delete(collection);\n        }\n    }\n}\n/** Returns the position of a document in the $setWindowFields stage partition. */\nexport function rank(_, collection, expr, options, dense) {\n    return withMemo(collection, expr, () => {\n        const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n        const values = $push(collection, sortKey, options);\n        const groups = groupBy(values, ((_, n) => values[n]), options.hashFunction);\n        return { values, groups };\n    }, input => {\n        const { values, groups: partitions } = input;\n        // same number of paritions as length means all sort keys are unique\n        if (partitions.size == collection.length) {\n            return expr.documentNumber;\n        }\n        const current = values[expr.documentNumber - 1];\n        let i = 0;\n        let offset = 0;\n        // partition keys are already dense so just return the value on match\n        for (const key of partitions.keys()) {\n            if (isEqual(current, key)) {\n                return dense ? i + 1 : offset + 1;\n            }\n            i++;\n            offset += partitions.get(key).length;\n        }\n        // should be unreachable\n        throw new MingoError(\"rank: invalid return value. please submit a bug report.\");\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}