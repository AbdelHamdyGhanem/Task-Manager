{"ast":null,"code":"// Date Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#date-expression-operators\nimport { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport { adjustDate, computeDate, DATE_FORMAT, DATE_SYM_TABLE, formatTimezone, padDigits, parseTimezone } from \"./_internal\";\nimport { $dayOfMonth } from \"./dayOfMonth\";\nimport { $hour } from \"./hour\";\nimport { $isoDayOfWeek } from \"./isoDayOfWeek\";\nimport { $isoWeek } from \"./isoWeek\";\nimport { $millisecond } from \"./millisecond\";\nimport { $minute } from \"./minute\";\nimport { $month } from \"./month\";\nimport { $second } from \"./second\";\nimport { $week } from \"./week\";\nimport { $year } from \"./year\";\n// date functions for format specifiers\nconst DATE_FUNCTIONS = {\n  \"%Y\": $year,\n  \"%G\": $year,\n  \"%m\": $month,\n  \"%d\": $dayOfMonth,\n  \"%H\": $hour,\n  \"%M\": $minute,\n  \"%S\": $second,\n  \"%L\": $millisecond,\n  \"%u\": $isoDayOfWeek,\n  \"%U\": $week,\n  \"%V\": $isoWeek\n};\n/**\n * Returns the date as a formatted string.\n *\n * %d\tDay of Month (2 digits, zero padded)\t01-31\n * %G\tYear in ISO 8601 format\t0000-9999\n * %H\tHour (2 digits, zero padded, 24-hour clock)\t00-23\n * %L\tMillisecond (3 digits, zero padded)\t000-999\n * %m\tMonth (2 digits, zero padded)\t01-12\n * %M\tMinute (2 digits, zero padded)\t00-59\n * %S\tSecond (2 digits, zero padded)\t00-60\n * %u\tDay of week number in ISO 8601 format (1-Monday, 7-Sunday)\t1-7\n * %V\tWeek of Year in ISO 8601 format\t1-53\n * %Y\tYear (4 digits, zero padded)\t0000-9999\n * %z\tThe timezone offset from UTC.\t+/-[hh][mm]\n * %Z\tThe minutes offset from UTC as a number. For example, if the timezone offset (+/-[hhmm]) was +0445, the minutes offset is +285.\t+/-mmm\n * %%\tPercent Character as a Literal\t%\n *\n * @param obj current object\n * @param expr operator expression\n */\nexport const $dateToString = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  if (isNil(args.onNull)) args.onNull = null;\n  if (isNil(args.date)) return args.onNull;\n  const date = computeDate(obj, args.date, options);\n  let format = args.format || DATE_FORMAT;\n  const minuteOffset = parseTimezone(args.timezone);\n  const matches = format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%U|%V|%z|%Z)/g);\n  // adjust the date to reflect timezone\n  adjustDate(date, minuteOffset);\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const formatSpecifier = matches[i];\n    const props = DATE_SYM_TABLE[formatSpecifier];\n    const operatorFn = DATE_FUNCTIONS[formatSpecifier];\n    let value;\n    if (isObject(props)) {\n      // reuse date\n      if (props.name === \"timezone\") {\n        value = formatTimezone(minuteOffset);\n      } else if (props.name === \"minuteOffset\") {\n        value = minuteOffset.toString();\n      } else {\n        assert(!!operatorFn, `unsupported date format specifier '${formatSpecifier}'`);\n        value = padDigits(operatorFn(obj, date, options), props.padding);\n      }\n    }\n    // replace the match with resolved value\n    format = format.replace(formatSpecifier, value);\n  }\n  return format;\n};","map":{"version":3,"names":["computeValue","assert","isNil","isObject","adjustDate","computeDate","DATE_FORMAT","DATE_SYM_TABLE","formatTimezone","padDigits","parseTimezone","$dayOfMonth","$hour","$isoDayOfWeek","$isoWeek","$millisecond","$minute","$month","$second","$week","$year","DATE_FUNCTIONS","$dateToString","obj","expr","options","args","onNull","date","format","minuteOffset","timezone","matches","match","i","len","length","formatSpecifier","props","operatorFn","value","name","toString","padding","replace"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/expression/date/dateToString.js"],"sourcesContent":["// Date Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#date-expression-operators\nimport { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport { adjustDate, computeDate, DATE_FORMAT, DATE_SYM_TABLE, formatTimezone, padDigits, parseTimezone } from \"./_internal\";\nimport { $dayOfMonth } from \"./dayOfMonth\";\nimport { $hour } from \"./hour\";\nimport { $isoDayOfWeek } from \"./isoDayOfWeek\";\nimport { $isoWeek } from \"./isoWeek\";\nimport { $millisecond } from \"./millisecond\";\nimport { $minute } from \"./minute\";\nimport { $month } from \"./month\";\nimport { $second } from \"./second\";\nimport { $week } from \"./week\";\nimport { $year } from \"./year\";\n// date functions for format specifiers\nconst DATE_FUNCTIONS = {\n    \"%Y\": $year,\n    \"%G\": $year,\n    \"%m\": $month,\n    \"%d\": $dayOfMonth,\n    \"%H\": $hour,\n    \"%M\": $minute,\n    \"%S\": $second,\n    \"%L\": $millisecond,\n    \"%u\": $isoDayOfWeek,\n    \"%U\": $week,\n    \"%V\": $isoWeek\n};\n/**\n * Returns the date as a formatted string.\n *\n * %d\tDay of Month (2 digits, zero padded)\t01-31\n * %G\tYear in ISO 8601 format\t0000-9999\n * %H\tHour (2 digits, zero padded, 24-hour clock)\t00-23\n * %L\tMillisecond (3 digits, zero padded)\t000-999\n * %m\tMonth (2 digits, zero padded)\t01-12\n * %M\tMinute (2 digits, zero padded)\t00-59\n * %S\tSecond (2 digits, zero padded)\t00-60\n * %u\tDay of week number in ISO 8601 format (1-Monday, 7-Sunday)\t1-7\n * %V\tWeek of Year in ISO 8601 format\t1-53\n * %Y\tYear (4 digits, zero padded)\t0000-9999\n * %z\tThe timezone offset from UTC.\t+/-[hh][mm]\n * %Z\tThe minutes offset from UTC as a number. For example, if the timezone offset (+/-[hhmm]) was +0445, the minutes offset is +285.\t+/-mmm\n * %%\tPercent Character as a Literal\t%\n *\n * @param obj current object\n * @param expr operator expression\n */\nexport const $dateToString = (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    if (isNil(args.onNull))\n        args.onNull = null;\n    if (isNil(args.date))\n        return args.onNull;\n    const date = computeDate(obj, args.date, options);\n    let format = args.format || DATE_FORMAT;\n    const minuteOffset = parseTimezone(args.timezone);\n    const matches = format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%U|%V|%z|%Z)/g);\n    // adjust the date to reflect timezone\n    adjustDate(date, minuteOffset);\n    for (let i = 0, len = matches.length; i < len; i++) {\n        const formatSpecifier = matches[i];\n        const props = DATE_SYM_TABLE[formatSpecifier];\n        const operatorFn = DATE_FUNCTIONS[formatSpecifier];\n        let value;\n        if (isObject(props)) {\n            // reuse date\n            if (props.name === \"timezone\") {\n                value = formatTimezone(minuteOffset);\n            }\n            else if (props.name === \"minuteOffset\") {\n                value = minuteOffset.toString();\n            }\n            else {\n                assert(!!operatorFn, `unsupported date format specifier '${formatSpecifier}'`);\n                value = padDigits(operatorFn(obj, date, options), props.padding);\n            }\n        }\n        // replace the match with resolved value\n        format = format.replace(formatSpecifier, value);\n    }\n    return format;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}