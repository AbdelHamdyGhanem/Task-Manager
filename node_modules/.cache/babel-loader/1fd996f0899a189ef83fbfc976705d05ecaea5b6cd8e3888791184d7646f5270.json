{"ast":null,"code":"import { initOptions } from \"../../core\";\nimport { assert, has, isObject } from \"../../util\";\nimport { $ifNull } from \"../expression/conditional/ifNull\";\nimport { $linearFill } from \"../window/linearFill\";\nimport { $locf } from \"../window/locf\";\nimport { $addFields } from \"./addFields\";\nimport { $setWindowFields } from \"./setWindowFields\";\nconst FILL_METHODS = {\n  locf: \"$locf\",\n  linear: \"$linearFill\"\n};\n/**\n * Populates null and missing field values within documents.\n *\n * @param {Iterator} collection\n * @param {Object} expr\n * @param {Options} options\n */\nexport const $fill = (collection, expr, options) => {\n  var _a, _b;\n  assert(!expr.sortBy || isObject(expr.sortBy), \"sortBy must be an object.\");\n  assert(!!expr.sortBy || Object.values(expr.output).every(m => has(m, \"value\")), \"sortBy required if any output field specifies a 'method'.\");\n  assert(!(expr.partitionBy && expr.partitionByFields), \"specify either partitionBy or partitionByFields.\");\n  assert(!expr.partitionByFields || ((_a = expr === null || expr === void 0 ? void 0 : expr.partitionByFields) === null || _a === void 0 ? void 0 : _a.every(s => s[0] !== \"$\")), \"fields in partitionByFields cannot begin with '$'.\");\n  options = initOptions(options);\n  options.context.addExpressionOps({\n    $ifNull\n  });\n  options.context.addWindowOps({\n    $locf,\n    $linearFill\n  });\n  const partitionExpr = expr.partitionBy || ((_b = expr === null || expr === void 0 ? void 0 : expr.partitionByFields) === null || _b === void 0 ? void 0 : _b.map(s => `$${s}`));\n  // collect and remove all output fields using 'value' instead of 'method'.\n  // if there are any fields remaining, process collection using $setWindowFields.\n  // if the collected output fields is non-empty, use $addFields to add them to their respective partitions.\n  const valueExpr = {};\n  const methodExpr = {};\n  for (const [k, m] of Object.entries(expr.output)) {\n    if (has(m, \"value\")) {\n      // translate to expression for $addFields\n      valueExpr[k] = {\n        $ifNull: [`$$CURRENT.${k}`, m[\"value\"]]\n      };\n    } else {\n      // translate to output expression for $setWindowFields.\n      const fillOp = FILL_METHODS[m[\"method\"]];\n      assert(!!fillOp, `invalid fill method '${m[\"method\"]}'.`);\n      methodExpr[k] = {\n        [fillOp]: \"$\" + k\n      };\n    }\n  }\n  // perform filling with $setWindowFields\n  if (Object.keys(methodExpr).length > 0) {\n    collection = $setWindowFields(collection, {\n      sortBy: expr.sortBy || {},\n      partitionBy: partitionExpr,\n      output: methodExpr\n    }, options);\n  }\n  // fill with values\n  if (Object.keys(valueExpr).length > 0) {\n    collection = $addFields(collection, valueExpr, options);\n  }\n  return collection;\n};","map":{"version":3,"names":["initOptions","assert","has","isObject","$ifNull","$linearFill","$locf","$addFields","$setWindowFields","FILL_METHODS","locf","linear","$fill","collection","expr","options","_a","_b","sortBy","Object","values","output","every","m","partitionBy","partitionByFields","s","context","addExpressionOps","addWindowOps","partitionExpr","map","valueExpr","methodExpr","k","entries","fillOp","keys","length"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/pipeline/fill.js"],"sourcesContent":["import { initOptions } from \"../../core\";\nimport { assert, has, isObject } from \"../../util\";\nimport { $ifNull } from \"../expression/conditional/ifNull\";\nimport { $linearFill } from \"../window/linearFill\";\nimport { $locf } from \"../window/locf\";\nimport { $addFields } from \"./addFields\";\nimport { $setWindowFields } from \"./setWindowFields\";\nconst FILL_METHODS = {\n    locf: \"$locf\",\n    linear: \"$linearFill\"\n};\n/**\n * Populates null and missing field values within documents.\n *\n * @param {Iterator} collection\n * @param {Object} expr\n * @param {Options} options\n */\nexport const $fill = (collection, expr, options) => {\n    var _a, _b;\n    assert(!expr.sortBy || isObject(expr.sortBy), \"sortBy must be an object.\");\n    assert(!!expr.sortBy || Object.values(expr.output).every(m => has(m, \"value\")), \"sortBy required if any output field specifies a 'method'.\");\n    assert(!(expr.partitionBy && expr.partitionByFields), \"specify either partitionBy or partitionByFields.\");\n    assert(!expr.partitionByFields ||\n        ((_a = expr === null || expr === void 0 ? void 0 : expr.partitionByFields) === null || _a === void 0 ? void 0 : _a.every(s => s[0] !== \"$\")), \"fields in partitionByFields cannot begin with '$'.\");\n    options = initOptions(options);\n    options.context.addExpressionOps({ $ifNull });\n    options.context.addWindowOps({ $locf, $linearFill });\n    const partitionExpr = expr.partitionBy || ((_b = expr === null || expr === void 0 ? void 0 : expr.partitionByFields) === null || _b === void 0 ? void 0 : _b.map(s => `$${s}`));\n    // collect and remove all output fields using 'value' instead of 'method'.\n    // if there are any fields remaining, process collection using $setWindowFields.\n    // if the collected output fields is non-empty, use $addFields to add them to their respective partitions.\n    const valueExpr = {};\n    const methodExpr = {};\n    for (const [k, m] of Object.entries(expr.output)) {\n        if (has(m, \"value\")) {\n            // translate to expression for $addFields\n            valueExpr[k] = { $ifNull: [`$$CURRENT.${k}`, m[\"value\"]] };\n        }\n        else {\n            // translate to output expression for $setWindowFields.\n            const fillOp = FILL_METHODS[m[\"method\"]];\n            assert(!!fillOp, `invalid fill method '${m[\"method\"]}'.`);\n            methodExpr[k] = { [fillOp]: \"$\" + k };\n        }\n    }\n    // perform filling with $setWindowFields\n    if (Object.keys(methodExpr).length > 0) {\n        collection = $setWindowFields(collection, {\n            sortBy: expr.sortBy || {},\n            partitionBy: partitionExpr,\n            output: methodExpr\n        }, options);\n    }\n    // fill with values\n    if (Object.keys(valueExpr).length > 0) {\n        collection = $addFields(collection, valueExpr, options);\n    }\n    return collection;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}