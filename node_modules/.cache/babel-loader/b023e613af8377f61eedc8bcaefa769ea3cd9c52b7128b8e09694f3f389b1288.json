{"ast":null,"code":"import { getOperator, initOptions, OperatorType } from \"./core\";\nimport { Cursor } from \"./cursor\";\nimport { MingoError } from \"./types\";\nimport { assert, inArray, isObject, isOperator, normalize } from \"./util\";\n/**\n * An object used to filter input documents\n *\n * @param {Object} condition The condition for constructing predicates\n * @param {Options} options Options for use by operators\n * @constructor\n */\nexport class Query {\n  constructor(condition, options) {\n    this.condition = condition;\n    this.options = initOptions(options);\n    this.compiled = [];\n    this.compile();\n  }\n  compile() {\n    assert(isObject(this.condition), `query criteria must be an object: ${JSON.stringify(this.condition)}`);\n    const whereOperator = {};\n    for (const [field, expr] of Object.entries(this.condition)) {\n      if (\"$where\" === field) {\n        Object.assign(whereOperator, {\n          field: field,\n          expr: expr\n        });\n      } else if (inArray([\"$and\", \"$or\", \"$nor\", \"$expr\", \"$jsonSchema\"], field)) {\n        this.processOperator(field, field, expr);\n      } else {\n        // normalize expression\n        assert(!isOperator(field), `unknown top level operator: ${field}`);\n        for (const [operator, val] of Object.entries(normalize(expr))) {\n          this.processOperator(field, operator, val);\n        }\n      }\n      if (whereOperator.field) {\n        this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);\n      }\n    }\n  }\n  processOperator(field, operator, value) {\n    const call = getOperator(OperatorType.QUERY, operator, this.options);\n    if (!call) {\n      throw new MingoError(`unknown query operator ${operator}`);\n    }\n    const fn = call(field, value, this.options);\n    this.compiled.push(fn);\n  }\n  /**\n   * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n   *\n   * @param obj The object to test\n   * @returns {boolean} True or false\n   */\n  test(obj) {\n    for (let i = 0, len = this.compiled.length; i < len; i++) {\n      if (!this.compiled[i](obj)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Returns a cursor to select matching documents from the input source.\n   *\n   * @param source A source providing a sequence of documents\n   * @param projection An optional projection criteria\n   * @returns {Cursor} A Cursor for iterating over the results\n   */\n  find(collection, projection) {\n    return new Cursor(collection, x => this.test(x), projection || {}, this.options);\n  }\n  /**\n   * Remove matched documents from the collection returning the remainder\n   *\n   * @param collection An array of documents\n   * @returns {Array} A new array with matching elements removed\n   */\n  remove(collection) {\n    return collection.reduce((acc, obj) => {\n      if (!this.test(obj)) acc.push(obj);\n      return acc;\n    }, []);\n  }\n}","map":{"version":3,"names":["getOperator","initOptions","OperatorType","Cursor","MingoError","assert","inArray","isObject","isOperator","normalize","Query","constructor","condition","options","compiled","compile","JSON","stringify","whereOperator","field","expr","Object","entries","assign","processOperator","operator","val","value","call","QUERY","fn","push","test","obj","i","len","length","find","collection","projection","x","remove","reduce","acc"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/query.js"],"sourcesContent":["import { getOperator, initOptions, OperatorType } from \"./core\";\nimport { Cursor } from \"./cursor\";\nimport { MingoError } from \"./types\";\nimport { assert, inArray, isObject, isOperator, normalize } from \"./util\";\n/**\n * An object used to filter input documents\n *\n * @param {Object} condition The condition for constructing predicates\n * @param {Options} options Options for use by operators\n * @constructor\n */\nexport class Query {\n    constructor(condition, options) {\n        this.condition = condition;\n        this.options = initOptions(options);\n        this.compiled = [];\n        this.compile();\n    }\n    compile() {\n        assert(isObject(this.condition), `query criteria must be an object: ${JSON.stringify(this.condition)}`);\n        const whereOperator = {};\n        for (const [field, expr] of Object.entries(this.condition)) {\n            if (\"$where\" === field) {\n                Object.assign(whereOperator, { field: field, expr: expr });\n            }\n            else if (inArray([\"$and\", \"$or\", \"$nor\", \"$expr\", \"$jsonSchema\"], field)) {\n                this.processOperator(field, field, expr);\n            }\n            else {\n                // normalize expression\n                assert(!isOperator(field), `unknown top level operator: ${field}`);\n                for (const [operator, val] of Object.entries(normalize(expr))) {\n                    this.processOperator(field, operator, val);\n                }\n            }\n            if (whereOperator.field) {\n                this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);\n            }\n        }\n    }\n    processOperator(field, operator, value) {\n        const call = getOperator(OperatorType.QUERY, operator, this.options);\n        if (!call) {\n            throw new MingoError(`unknown query operator ${operator}`);\n        }\n        const fn = call(field, value, this.options);\n        this.compiled.push(fn);\n    }\n    /**\n     * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n     *\n     * @param obj The object to test\n     * @returns {boolean} True or false\n     */\n    test(obj) {\n        for (let i = 0, len = this.compiled.length; i < len; i++) {\n            if (!this.compiled[i](obj)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a cursor to select matching documents from the input source.\n     *\n     * @param source A source providing a sequence of documents\n     * @param projection An optional projection criteria\n     * @returns {Cursor} A Cursor for iterating over the results\n     */\n    find(collection, projection) {\n        return new Cursor(collection, ((x) => this.test(x)), projection || {}, this.options);\n    }\n    /**\n     * Remove matched documents from the collection returning the remainder\n     *\n     * @param collection An array of documents\n     * @returns {Array} A new array with matching elements removed\n     */\n    remove(collection) {\n        return collection.reduce((acc, obj) => {\n            if (!this.test(obj))\n                acc.push(obj);\n            return acc;\n        }, []);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}