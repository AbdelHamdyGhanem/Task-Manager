{"ast":null,"code":"/**\n * String Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#string-expression-operators\n */\nimport { computeValue } from \"../../../core\";\nimport { assert, isNumber, isString } from \"../../../util\";\nconst UTF8_MASK = [0xc0, 0xe0, 0xf0];\n// encodes a unicode code point to a utf8 byte sequence\n// https://encoding.spec.whatwg.org/#utf-8\nfunction toUtf8(n) {\n  if (n < 0x80) return [n];\n  let count = n < 0x0800 && 1 || n < 0x10000 && 2 || 3;\n  const offset = UTF8_MASK[count - 1];\n  const utf8 = [(n >> 6 * count) + offset];\n  while (count > 0) utf8.push(0x80 | n >> 6 * --count & 0x3f);\n  return utf8;\n}\nfunction utf8Encode(s) {\n  const buf = [];\n  for (let i = 0, len = s.length; i < len; i++) {\n    buf.push(toUtf8(s.codePointAt(i)));\n  }\n  return buf;\n}\n/**\n * Returns a substring of a string, starting at a specified index position and including the specified number of characters.\n * The index is zero-based.\n *\n * @param obj\n * @param expr\n * @returns {string}\n */\nexport const $substrBytes = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  const s = args[0];\n  const index = args[1];\n  const count = args[2];\n  assert(isString(s) && isNumber(index) && index >= 0 && isNumber(count) && count >= 0, \"$substrBytes: invalid arguments\");\n  const buf = utf8Encode(s);\n  const validIndex = [];\n  let acc = 0;\n  for (let i = 0; i < buf.length; i++) {\n    validIndex.push(acc);\n    acc += buf[i].length;\n  }\n  const begin = validIndex.indexOf(index);\n  const end = validIndex.indexOf(index + count);\n  assert(begin > -1 && end > -1, \"$substrBytes: invalid range, start or end index is a UTF-8 continuation byte.\");\n  return s.substring(begin, end);\n};","map":{"version":3,"names":["computeValue","assert","isNumber","isString","UTF8_MASK","toUtf8","n","count","offset","utf8","push","utf8Encode","s","buf","i","len","length","codePointAt","$substrBytes","obj","expr","options","args","index","validIndex","acc","begin","indexOf","end","substring"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/expression/string/substrBytes.js"],"sourcesContent":["/**\n * String Expression Operators: https://docs.mongodb.com/manual/reference/operator/aggregation/#string-expression-operators\n */\nimport { computeValue } from \"../../../core\";\nimport { assert, isNumber, isString } from \"../../../util\";\nconst UTF8_MASK = [0xc0, 0xe0, 0xf0];\n// encodes a unicode code point to a utf8 byte sequence\n// https://encoding.spec.whatwg.org/#utf-8\nfunction toUtf8(n) {\n    if (n < 0x80)\n        return [n];\n    let count = (n < 0x0800 && 1) || (n < 0x10000 && 2) || 3;\n    const offset = UTF8_MASK[count - 1];\n    const utf8 = [(n >> (6 * count)) + offset];\n    while (count > 0)\n        utf8.push(0x80 | ((n >> (6 * --count)) & 0x3f));\n    return utf8;\n}\nfunction utf8Encode(s) {\n    const buf = [];\n    for (let i = 0, len = s.length; i < len; i++) {\n        buf.push(toUtf8(s.codePointAt(i)));\n    }\n    return buf;\n}\n/**\n * Returns a substring of a string, starting at a specified index position and including the specified number of characters.\n * The index is zero-based.\n *\n * @param obj\n * @param expr\n * @returns {string}\n */\nexport const $substrBytes = (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    const s = args[0];\n    const index = args[1];\n    const count = args[2];\n    assert(isString(s) &&\n        isNumber(index) &&\n        index >= 0 &&\n        isNumber(count) &&\n        count >= 0, \"$substrBytes: invalid arguments\");\n    const buf = utf8Encode(s);\n    const validIndex = [];\n    let acc = 0;\n    for (let i = 0; i < buf.length; i++) {\n        validIndex.push(acc);\n        acc += buf[i].length;\n    }\n    const begin = validIndex.indexOf(index);\n    const end = validIndex.indexOf(index + count);\n    assert(begin > -1 && end > -1, \"$substrBytes: invalid range, start or end index is a UTF-8 continuation byte.\");\n    return s.substring(begin, end);\n};\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,YAAY,QAAQ,eAAe;AAC5C,SAASC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,QAAQ,eAAe;AAC1D,MAAMC,SAAS,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AACpC;AACA;AACA,SAASC,MAAMA,CAACC,CAAC,EAAE;EACf,IAAIA,CAAC,GAAG,IAAI,EACR,OAAO,CAACA,CAAC,CAAC;EACd,IAAIC,KAAK,GAAID,CAAC,GAAG,MAAM,IAAI,CAAC,IAAMA,CAAC,GAAG,OAAO,IAAI,CAAE,IAAI,CAAC;EACxD,MAAME,MAAM,GAAGJ,SAAS,CAACG,KAAK,GAAG,CAAC,CAAC;EACnC,MAAME,IAAI,GAAG,CAAC,CAACH,CAAC,IAAK,CAAC,GAAGC,KAAM,IAAIC,MAAM,CAAC;EAC1C,OAAOD,KAAK,GAAG,CAAC,EACZE,IAAI,CAACC,IAAI,CAAC,IAAI,GAAKJ,CAAC,IAAK,CAAC,GAAG,EAAEC,KAAM,GAAI,IAAK,CAAC;EACnD,OAAOE,IAAI;AACf;AACA,SAASE,UAAUA,CAACC,CAAC,EAAE;EACnB,MAAMC,GAAG,GAAG,EAAE;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,CAAC,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IAC1CD,GAAG,CAACH,IAAI,CAACL,MAAM,CAACO,CAAC,CAACK,WAAW,CAACH,CAAC,CAAC,CAAC,CAAC;EACtC;EACA,OAAOD,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,YAAY,GAAGA,CAACC,GAAG,EAAEC,IAAI,EAAEC,OAAO,KAAK;EAChD,MAAMC,IAAI,GAAGtB,YAAY,CAACmB,GAAG,EAAEC,IAAI,EAAE,IAAI,EAAEC,OAAO,CAAC;EACnD,MAAMT,CAAC,GAAGU,IAAI,CAAC,CAAC,CAAC;EACjB,MAAMC,KAAK,GAAGD,IAAI,CAAC,CAAC,CAAC;EACrB,MAAMf,KAAK,GAAGe,IAAI,CAAC,CAAC,CAAC;EACrBrB,MAAM,CAACE,QAAQ,CAACS,CAAC,CAAC,IACdV,QAAQ,CAACqB,KAAK,CAAC,IACfA,KAAK,IAAI,CAAC,IACVrB,QAAQ,CAACK,KAAK,CAAC,IACfA,KAAK,IAAI,CAAC,EAAE,iCAAiC,CAAC;EAClD,MAAMM,GAAG,GAAGF,UAAU,CAACC,CAAC,CAAC;EACzB,MAAMY,UAAU,GAAG,EAAE;EACrB,IAAIC,GAAG,GAAG,CAAC;EACX,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,CAACG,MAAM,EAAEF,CAAC,EAAE,EAAE;IACjCU,UAAU,CAACd,IAAI,CAACe,GAAG,CAAC;IACpBA,GAAG,IAAIZ,GAAG,CAACC,CAAC,CAAC,CAACE,MAAM;EACxB;EACA,MAAMU,KAAK,GAAGF,UAAU,CAACG,OAAO,CAACJ,KAAK,CAAC;EACvC,MAAMK,GAAG,GAAGJ,UAAU,CAACG,OAAO,CAACJ,KAAK,GAAGhB,KAAK,CAAC;EAC7CN,MAAM,CAACyB,KAAK,GAAG,CAAC,CAAC,IAAIE,GAAG,GAAG,CAAC,CAAC,EAAE,+EAA+E,CAAC;EAC/G,OAAOhB,CAAC,CAACiB,SAAS,CAACH,KAAK,EAAEE,GAAG,CAAC;AAClC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}