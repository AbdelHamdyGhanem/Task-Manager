{"ast":null,"code":"import { createBddFromTruthTable } from './create-bdd-from-truth-table.js';\nimport { firstKeyOfMap, shuffleArray, lastOfArray } from './util.js';\n/**\n * returns the bdd with less nodes\n */\nexport const defaultCompareResults = function (a, b) {\n  if (a.countNodes() <= b.countNodes()) {\n    return a;\n  } else {\n    return b;\n  }\n};\n/**\n * optimises the ordering of the boolean functions\n * by randomly sorting the array\n * and checking the resulting bdd\n */\nexport async function optimizeBruteForce({\n  truthTable,\n  iterations = Infinity,\n  onBetterBdd = () => null,\n  compareResults = defaultCompareResults,\n  afterBddCreation = () => null,\n  initialBdd,\n  log = false\n}) {\n  initialBdd = initialBdd ? initialBdd : await createBddFromTruthTable(truthTable);\n  afterBddCreation(initialBdd);\n  initialBdd.minimize();\n  let currentBestResult = {\n    truthTable,\n    bdd: initialBdd\n  };\n  onBetterBdd(currentBestResult);\n  if (log) {\n    initialBdd.log();\n    console.log('initial nodes amount: ' + initialBdd.countNodes());\n  }\n  let t = 0;\n  while (t < iterations) {\n    t++;\n    if (log) {\n      console.log('-'.repeat(50));\n      console.log('optimizeBruteForce() itterate once');\n    }\n    const shuffledOrdering = shuffleBooleanOrdering(truthTable);\n    const nextBdd = createBddFromTruthTable(shuffledOrdering.newTable);\n    // change the levels of each node\n    const newNodesByLevel = new Map();\n    const lastLevel = lastOfArray(nextBdd.getLevels());\n    const newSortedLevels = [];\n    nextBdd.getLevels().filter(level => level !== lastLevel).forEach(level => {\n      const newLevel = shuffledOrdering.mappingBeforeToAfter[level];\n      newSortedLevels.push(newLevel);\n      const levelSet = new Set();\n      newNodesByLevel.set(newLevel, levelSet);\n      nextBdd.getNodesOfLevel(level).forEach(node => {\n        node.level = newLevel;\n        levelSet.add(node);\n      });\n    });\n    const lastLevelSet = new Set();\n    nextBdd.getNodesOfLevel(lastLevel).forEach(node => lastLevelSet.add(node));\n    newNodesByLevel.set(lastLevel, lastLevelSet);\n    newSortedLevels.push(lastLevel);\n    nextBdd.nodesByLevel = newNodesByLevel;\n    nextBdd.levels = newSortedLevels;\n    afterBddCreation(nextBdd);\n    nextBdd.minimize();\n    if (log) {\n      console.log('got new bdd with nodes amount of ' + nextBdd.countNodes());\n      //            nextBdd.log();\n      console.dir(shuffledOrdering.mappingBeforeToAfter);\n    }\n    const betterBdd = await compareResults(currentBestResult.bdd, nextBdd);\n    if (betterBdd.type !== 'RootNode') {\n      throw new Error('compareResults did not return a bdd');\n    }\n    if (betterBdd === nextBdd) {\n      if (log) {\n        console.log('#'.repeat(50));\n        console.log('found better bdd ' + nextBdd.countNodes());\n      }\n      currentBestResult = {\n        bdd: nextBdd,\n        truthTable: shuffledOrdering.newTable\n      };\n      onBetterBdd(currentBestResult);\n    }\n  }\n  return currentBestResult;\n}\nexport function shuffleBooleanOrdering(truthTable) {\n  const firstKey = firstKeyOfMap(truthTable);\n  const arrayWithIndexes = getArrayWithIndexes(firstKey.length);\n  const shuffled = shuffleArray(arrayWithIndexes);\n  const mapping = {};\n  const mappingBeforeToAfter = {};\n  shuffled.forEach((indexBefore, indexAfter) => {\n    mapping[indexAfter] = indexBefore;\n    mappingBeforeToAfter[indexBefore] = indexAfter;\n  });\n  const newTable = new Map();\n  for (const [key, value] of truthTable.entries()) {\n    const newKey = changeKeyOrder(key, mapping);\n    newTable.set(newKey, value);\n  }\n  return {\n    newTable,\n    mapping,\n    mappingBeforeToAfter\n  };\n}\nexport function changeKeyOrder(oldKey, mappingBeforeToAfter) {\n  const chars = oldKey.split('').map((char, indexBefore) => {\n    return {\n      char,\n      indexBefore,\n      indexAfter: mappingBeforeToAfter[indexBefore]\n    };\n  }).sort((a, b) => a.indexAfter - b.indexAfter).map(charObj => charObj.char).join('');\n  return chars;\n}\nexport function getArrayWithIndexes(size) {\n  const ret = [];\n  let last = 0;\n  while (last < size) {\n    ret.push(last);\n    last++;\n  }\n  return ret;\n}","map":{"version":3,"names":["createBddFromTruthTable","firstKeyOfMap","shuffleArray","lastOfArray","defaultCompareResults","a","b","countNodes","optimizeBruteForce","truthTable","iterations","Infinity","onBetterBdd","compareResults","afterBddCreation","initialBdd","log","minimize","currentBestResult","bdd","console","t","repeat","shuffledOrdering","shuffleBooleanOrdering","nextBdd","newTable","newNodesByLevel","Map","lastLevel","getLevels","newSortedLevels","filter","level","forEach","newLevel","mappingBeforeToAfter","push","levelSet","Set","set","getNodesOfLevel","node","add","lastLevelSet","nodesByLevel","levels","dir","betterBdd","type","Error","firstKey","arrayWithIndexes","getArrayWithIndexes","length","shuffled","mapping","indexBefore","indexAfter","key","value","entries","newKey","changeKeyOrder","oldKey","chars","split","map","char","sort","charObj","join","size","ret","last"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/binary-decision-diagram/src/optimize-brute-force.ts"],"sourcesContent":["import type { TruthTable } from './types.js';\nimport { RootNode } from './root-node.js';\nimport { createBddFromTruthTable } from './create-bdd-from-truth-table.js';\nimport { firstKeyOfMap, shuffleArray, lastOfArray } from './util.js';\nimport { AbstractNode } from './abstract-node.js';\n\n/**\n * a function that is called each time\n * a 'better' bdd was found\n */\nexport type OptmisiationCallback = (bdd: OptimisationResult) => void;\n\nexport interface OptimisationResult {\n    bdd: RootNode;\n    truthTable: TruthTable;\n}\n\nexport type CompareResultsFunction = (a: RootNode, b: RootNode) => RootNode | Promise<RootNode>;\n\n/**\n * returns the bdd with less nodes\n */\nexport const defaultCompareResults: CompareResultsFunction = function (\n    a: RootNode,\n    b: RootNode\n): RootNode {\n    if (a.countNodes() <= b.countNodes()) {\n        return a;\n    } else {\n        return b;\n    }\n};\n\nexport interface OptimizeBruteForceInput {\n    truthTable: TruthTable;\n    iterations?: number;\n    onBetterBdd?: OptmisiationCallback;\n    // a function that returns the 'better' bdd\n    compareResults?: CompareResultsFunction;\n    afterBddCreation?: (bdd: RootNode) => void;\n    initialBdd?: RootNode;\n    log?: boolean;\n}\n\n/**\n * optimises the ordering of the boolean functions\n * by randomly sorting the array\n * and checking the resulting bdd\n */\nexport async function optimizeBruteForce({\n    truthTable,\n    iterations = Infinity,\n    onBetterBdd = () => null,\n    compareResults = defaultCompareResults,\n    afterBddCreation = () => null,\n    initialBdd,\n    log = false\n}: OptimizeBruteForceInput): Promise<OptimisationResult> {\n    initialBdd = initialBdd ? initialBdd : await createBddFromTruthTable(truthTable);\n    afterBddCreation(initialBdd);\n    initialBdd.minimize();\n    let currentBestResult: OptimisationResult = {\n        truthTable,\n        bdd: initialBdd\n    };\n    onBetterBdd(currentBestResult);\n\n    if (log) {\n        initialBdd.log();\n        console.log('initial nodes amount: ' + initialBdd.countNodes());\n    }\n\n    let t = 0;\n    while (t < iterations) {\n        t++;\n\n        if (log) {\n            console.log('-'.repeat(50));\n            console.log('optimizeBruteForce() itterate once');\n        }\n        const shuffledOrdering = shuffleBooleanOrdering(truthTable);\n        const nextBdd = createBddFromTruthTable(shuffledOrdering.newTable);\n\n        // change the levels of each node\n        const newNodesByLevel: Map<number, Set<AbstractNode>> = new Map();\n        const lastLevel = lastOfArray(nextBdd.getLevels());\n        const newSortedLevels: number[] = [];\n        nextBdd.getLevels()\n            .filter(level => level !== lastLevel)\n            .forEach(level => {\n                const newLevel = shuffledOrdering.mappingBeforeToAfter[level];\n                newSortedLevels.push(newLevel);\n                const levelSet: Set<AbstractNode> = new Set();\n                newNodesByLevel.set(newLevel, levelSet);\n                nextBdd.getNodesOfLevel(level).forEach(node => {\n                    node.level = newLevel;\n                    levelSet.add(node);\n                });\n            });\n        const lastLevelSet: Set<AbstractNode> = new Set();\n        nextBdd.getNodesOfLevel(lastLevel).forEach(node => lastLevelSet.add(node));\n        newNodesByLevel.set(lastLevel, lastLevelSet);\n        newSortedLevels.push(lastLevel);\n        nextBdd.nodesByLevel = newNodesByLevel;\n        nextBdd.levels = newSortedLevels;\n\n        afterBddCreation(nextBdd);\n        nextBdd.minimize();\n\n        if (log) {\n            console.log('got new bdd with nodes amount of ' + nextBdd.countNodes());\n            //            nextBdd.log();\n            console.dir(shuffledOrdering.mappingBeforeToAfter);\n        }\n\n        const betterBdd = await compareResults(\n            currentBestResult.bdd,\n            nextBdd\n        );\n        if (betterBdd.type !== 'RootNode') {\n            throw new Error('compareResults did not return a bdd');\n        }\n\n        if (betterBdd === nextBdd) {\n            if (log) {\n                console.log('#'.repeat(50));\n                console.log('found better bdd ' + nextBdd.countNodes());\n            }\n\n            currentBestResult = {\n                bdd: nextBdd,\n                truthTable: shuffledOrdering.newTable\n            };\n            onBetterBdd(currentBestResult);\n        }\n    }\n\n\n    return currentBestResult;\n}\n\n\nexport type BooleanFunctionReorderMapping = {\n    [indexAfter: number]: number; // to indexBefore\n};\n\nexport type BooleanFunctionReorderMappingReverse = {\n    [indexBefore: number]: number; // to indexAfter\n};\n\nexport function shuffleBooleanOrdering(\n    truthTable: TruthTable\n): {\n    newTable: TruthTable,\n    mapping: BooleanFunctionReorderMapping,\n    mappingBeforeToAfter: BooleanFunctionReorderMappingReverse\n} {\n    const firstKey = firstKeyOfMap(truthTable);\n    const arrayWithIndexes = getArrayWithIndexes(firstKey.length);\n    const shuffled = shuffleArray(arrayWithIndexes);\n\n    const mapping: BooleanFunctionReorderMapping = {};\n    const mappingBeforeToAfter: BooleanFunctionReorderMappingReverse = {};\n    shuffled.forEach((indexBefore, indexAfter) => {\n        mapping[indexAfter] = indexBefore;\n        mappingBeforeToAfter[indexBefore] = indexAfter;\n    });\n\n    const newTable: TruthTable = new Map();\n    for (const [key, value] of truthTable.entries()) {\n        const newKey = changeKeyOrder(\n            key,\n            mapping\n        );\n        newTable.set(\n            newKey,\n            value\n        );\n    }\n\n    return {\n        newTable,\n        mapping,\n        mappingBeforeToAfter\n    };\n}\n\nexport function changeKeyOrder(\n    oldKey: string,\n    mappingBeforeToAfter: BooleanFunctionReorderMapping\n): string {\n    const chars = oldKey\n        .split('')\n        .map((char, indexBefore) => {\n            return {\n                char,\n                indexBefore,\n                indexAfter: mappingBeforeToAfter[indexBefore]\n            };\n        })\n        .sort((a, b) => a.indexAfter - b.indexAfter)\n        .map(charObj => charObj.char)\n        .join('');\n    return chars;\n}\n\nexport function getArrayWithIndexes(size: number): number[] {\n    const ret: number[] = [];\n    let last = 0;\n    while (last < size) {\n        ret.push(last);\n        last++;\n    }\n    return ret;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}