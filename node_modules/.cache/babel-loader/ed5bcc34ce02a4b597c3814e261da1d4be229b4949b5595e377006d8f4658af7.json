{"ast":null,"code":"import { computeValue } from \"../../core\";\nimport { assert, has, into, isNil, memoize, sortBy } from \"../../util\";\nconst ID_KEY = \"_id\";\n/**\n * Categorizes incoming documents into a specific number of groups, called buckets,\n * based on a specified expression. Bucket boundaries are automatically determined\n * in an attempt to evenly distribute the documents into the specified number of buckets.\n * https://docs.mongodb.com/manual/reference/operator/aggregation/bucketAuto/\n *\n * @param {*} collection\n * @param {*} expr\n * @param {*} options\n */\nexport const $bucketAuto = (collection, expr, options) => {\n  const outputExpr = expr.output || {\n    count: {\n      $sum: 1\n    }\n  };\n  const groupByExpr = expr.groupBy;\n  const bucketCount = expr.buckets;\n  assert(bucketCount > 0, `The $bucketAuto 'buckets' field must be greater than 0, but found: ${bucketCount}`);\n  return collection.transform(coll => {\n    const approxBucketSize = Math.max(1, Math.round(coll.length / bucketCount));\n    const computeValueOptimized = memoize(computeValue, options === null || options === void 0 ? void 0 : options.hashFunction);\n    const grouped = new Map();\n    const remaining = [];\n    const sorted = sortBy(coll, o => {\n      const key = computeValueOptimized(o, groupByExpr, null, options);\n      if (isNil(key)) {\n        remaining.push(o);\n      } else {\n        if (!grouped.has(key)) grouped.set(key, []);\n        grouped.get(key).push(o);\n      }\n      return key;\n    });\n    const result = [];\n    let index = 0; // counter for sorted collection\n    for (let i = 0, len = sorted.length; i < bucketCount && index < len; i++) {\n      const boundaries = {};\n      const bucketItems = [];\n      for (let j = 0; j < approxBucketSize && index < len; j++) {\n        let key = computeValueOptimized(sorted[index], groupByExpr, null, options);\n        if (isNil(key)) key = null;\n        // populate current bucket with all values for current key\n        into(bucketItems, isNil(key) ? remaining : grouped.get(key));\n        // increase sort index by number of items added\n        index += isNil(key) ? remaining.length : grouped.get(key).length;\n        // set the min key boundary if not already present\n        if (!has(boundaries, \"min\")) boundaries.min = key;\n        if (result.length > 0) {\n          const lastBucket = result[result.length - 1];\n          lastBucket[ID_KEY].max = boundaries.min;\n        }\n      }\n      // if is last bucket add remaining items\n      if (i == bucketCount - 1) {\n        into(bucketItems, sorted.slice(index));\n      }\n      const values = computeValue(bucketItems, outputExpr, null, options);\n      result.push(into(values, {\n        _id: boundaries\n      }));\n    }\n    if (result.length > 0) {\n      result[result.length - 1][ID_KEY].max = computeValueOptimized(sorted[sorted.length - 1], groupByExpr, null, options);\n    }\n    return result;\n  });\n};","map":{"version":3,"names":["computeValue","assert","has","into","isNil","memoize","sortBy","ID_KEY","$bucketAuto","collection","expr","options","outputExpr","output","count","$sum","groupByExpr","groupBy","bucketCount","buckets","transform","coll","approxBucketSize","Math","max","round","length","computeValueOptimized","hashFunction","grouped","Map","remaining","sorted","o","key","push","set","get","result","index","i","len","boundaries","bucketItems","j","min","lastBucket","slice","values","_id"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/pipeline/bucketAuto.js"],"sourcesContent":["import { computeValue } from \"../../core\";\nimport { assert, has, into, isNil, memoize, sortBy } from \"../../util\";\nconst ID_KEY = \"_id\";\n/**\n * Categorizes incoming documents into a specific number of groups, called buckets,\n * based on a specified expression. Bucket boundaries are automatically determined\n * in an attempt to evenly distribute the documents into the specified number of buckets.\n * https://docs.mongodb.com/manual/reference/operator/aggregation/bucketAuto/\n *\n * @param {*} collection\n * @param {*} expr\n * @param {*} options\n */\nexport const $bucketAuto = (collection, expr, options) => {\n    const outputExpr = expr.output || { count: { $sum: 1 } };\n    const groupByExpr = expr.groupBy;\n    const bucketCount = expr.buckets;\n    assert(bucketCount > 0, `The $bucketAuto 'buckets' field must be greater than 0, but found: ${bucketCount}`);\n    return collection.transform((coll) => {\n        const approxBucketSize = Math.max(1, Math.round(coll.length / bucketCount));\n        const computeValueOptimized = memoize(computeValue, options === null || options === void 0 ? void 0 : options.hashFunction);\n        const grouped = new Map();\n        const remaining = [];\n        const sorted = sortBy(coll, o => {\n            const key = computeValueOptimized(o, groupByExpr, null, options);\n            if (isNil(key)) {\n                remaining.push(o);\n            }\n            else {\n                if (!grouped.has(key))\n                    grouped.set(key, []);\n                grouped.get(key).push(o);\n            }\n            return key;\n        });\n        const result = [];\n        let index = 0; // counter for sorted collection\n        for (let i = 0, len = sorted.length; i < bucketCount && index < len; i++) {\n            const boundaries = {};\n            const bucketItems = [];\n            for (let j = 0; j < approxBucketSize && index < len; j++) {\n                let key = computeValueOptimized(sorted[index], groupByExpr, null, options);\n                if (isNil(key))\n                    key = null;\n                // populate current bucket with all values for current key\n                into(bucketItems, isNil(key) ? remaining : grouped.get(key));\n                // increase sort index by number of items added\n                index += isNil(key) ? remaining.length : grouped.get(key).length;\n                // set the min key boundary if not already present\n                if (!has(boundaries, \"min\"))\n                    boundaries.min = key;\n                if (result.length > 0) {\n                    const lastBucket = result[result.length - 1];\n                    lastBucket[ID_KEY].max = boundaries.min;\n                }\n            }\n            // if is last bucket add remaining items\n            if (i == bucketCount - 1) {\n                into(bucketItems, sorted.slice(index));\n            }\n            const values = computeValue(bucketItems, outputExpr, null, options);\n            result.push(into(values, {\n                _id: boundaries\n            }));\n        }\n        if (result.length > 0) {\n            result[result.length - 1][ID_KEY].max =\n                computeValueOptimized(sorted[sorted.length - 1], groupByExpr, null, options);\n        }\n        return result;\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}