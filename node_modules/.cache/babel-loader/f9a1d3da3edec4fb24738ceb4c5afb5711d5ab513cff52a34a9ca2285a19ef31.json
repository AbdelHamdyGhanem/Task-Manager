{"ast":null,"code":"import { ComputeOptions, computeValue } from \"../../core\";\nimport { assert, groupBy, has } from \"../../util\";\n// lookup key for grouping\nconst ID_KEY = \"_id\";\n/**\n * Groups documents together for the purpose of calculating aggregate values based on a collection of documents.\n *\n * @param collection\n * @param expr\n * @param options\n * @returns {Array}\n */\nexport const $group = (collection, expr, options) => {\n  assert(has(expr, ID_KEY), \"a group specification must include an _id\");\n  const idExpr = expr[ID_KEY];\n  const copts = ComputeOptions.init(options);\n  return collection.transform(coll => {\n    const partitions = groupBy(coll, obj => computeValue(obj, idExpr, null, options), options.hashFunction);\n    // remove the group key\n    expr = Object.assign({}, expr);\n    delete expr[ID_KEY];\n    let i = -1;\n    const partitionKeys = Array.from(partitions.keys());\n    const size = partitions.size;\n    return () => {\n      if (++i === size) return {\n        done: true\n      };\n      const groupId = partitionKeys[i];\n      const obj = {};\n      // exclude undefined key value\n      if (groupId !== undefined) {\n        obj[ID_KEY] = groupId;\n      }\n      // compute remaining keys in expression\n      for (const [key, val] of Object.entries(expr)) {\n        obj[key] = computeValue(partitions.get(groupId), val, key, copts.update(null, {\n          groupId\n        }));\n      }\n      return {\n        value: obj,\n        done: false\n      };\n    };\n  });\n};","map":{"version":3,"names":["ComputeOptions","computeValue","assert","groupBy","has","ID_KEY","$group","collection","expr","options","idExpr","copts","init","transform","coll","partitions","obj","hashFunction","Object","assign","i","partitionKeys","Array","from","keys","size","done","groupId","undefined","key","val","entries","get","update","value"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/pipeline/group.js"],"sourcesContent":["import { ComputeOptions, computeValue } from \"../../core\";\nimport { assert, groupBy, has } from \"../../util\";\n// lookup key for grouping\nconst ID_KEY = \"_id\";\n/**\n * Groups documents together for the purpose of calculating aggregate values based on a collection of documents.\n *\n * @param collection\n * @param expr\n * @param options\n * @returns {Array}\n */\nexport const $group = (collection, expr, options) => {\n    assert(has(expr, ID_KEY), \"a group specification must include an _id\");\n    const idExpr = expr[ID_KEY];\n    const copts = ComputeOptions.init(options);\n    return collection.transform(((coll) => {\n        const partitions = groupBy(coll, obj => computeValue(obj, idExpr, null, options), options.hashFunction);\n        // remove the group key\n        expr = Object.assign({}, expr);\n        delete expr[ID_KEY];\n        let i = -1;\n        const partitionKeys = Array.from(partitions.keys());\n        const size = partitions.size;\n        return () => {\n            if (++i === size)\n                return { done: true };\n            const groupId = partitionKeys[i];\n            const obj = {};\n            // exclude undefined key value\n            if (groupId !== undefined) {\n                obj[ID_KEY] = groupId;\n            }\n            // compute remaining keys in expression\n            for (const [key, val] of Object.entries(expr)) {\n                obj[key] = computeValue(partitions.get(groupId), val, key, copts.update(null, { groupId }));\n            }\n            return { value: obj, done: false };\n        };\n    }));\n};\n"],"mappings":"AAAA,SAASA,cAAc,EAAEC,YAAY,QAAQ,YAAY;AACzD,SAASC,MAAM,EAAEC,OAAO,EAAEC,GAAG,QAAQ,YAAY;AACjD;AACA,MAAMC,MAAM,GAAG,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGA,CAACC,UAAU,EAAEC,IAAI,EAAEC,OAAO,KAAK;EACjDP,MAAM,CAACE,GAAG,CAACI,IAAI,EAAEH,MAAM,CAAC,EAAE,2CAA2C,CAAC;EACtE,MAAMK,MAAM,GAAGF,IAAI,CAACH,MAAM,CAAC;EAC3B,MAAMM,KAAK,GAAGX,cAAc,CAACY,IAAI,CAACH,OAAO,CAAC;EAC1C,OAAOF,UAAU,CAACM,SAAS,CAAGC,IAAI,IAAK;IACnC,MAAMC,UAAU,GAAGZ,OAAO,CAACW,IAAI,EAAEE,GAAG,IAAIf,YAAY,CAACe,GAAG,EAAEN,MAAM,EAAE,IAAI,EAAED,OAAO,CAAC,EAAEA,OAAO,CAACQ,YAAY,CAAC;IACvG;IACAT,IAAI,GAAGU,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEX,IAAI,CAAC;IAC9B,OAAOA,IAAI,CAACH,MAAM,CAAC;IACnB,IAAIe,CAAC,GAAG,CAAC,CAAC;IACV,MAAMC,aAAa,GAAGC,KAAK,CAACC,IAAI,CAACR,UAAU,CAACS,IAAI,CAAC,CAAC,CAAC;IACnD,MAAMC,IAAI,GAAGV,UAAU,CAACU,IAAI;IAC5B,OAAO,MAAM;MACT,IAAI,EAAEL,CAAC,KAAKK,IAAI,EACZ,OAAO;QAAEC,IAAI,EAAE;MAAK,CAAC;MACzB,MAAMC,OAAO,GAAGN,aAAa,CAACD,CAAC,CAAC;MAChC,MAAMJ,GAAG,GAAG,CAAC,CAAC;MACd;MACA,IAAIW,OAAO,KAAKC,SAAS,EAAE;QACvBZ,GAAG,CAACX,MAAM,CAAC,GAAGsB,OAAO;MACzB;MACA;MACA,KAAK,MAAM,CAACE,GAAG,EAAEC,GAAG,CAAC,IAAIZ,MAAM,CAACa,OAAO,CAACvB,IAAI,CAAC,EAAE;QAC3CQ,GAAG,CAACa,GAAG,CAAC,GAAG5B,YAAY,CAACc,UAAU,CAACiB,GAAG,CAACL,OAAO,CAAC,EAAEG,GAAG,EAAED,GAAG,EAAElB,KAAK,CAACsB,MAAM,CAAC,IAAI,EAAE;UAAEN;QAAQ,CAAC,CAAC,CAAC;MAC/F;MACA,OAAO;QAAEO,KAAK,EAAElB,GAAG;QAAEU,IAAI,EAAE;MAAM,CAAC;IACtC,CAAC;EACL,CAAE,CAAC;AACP,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}