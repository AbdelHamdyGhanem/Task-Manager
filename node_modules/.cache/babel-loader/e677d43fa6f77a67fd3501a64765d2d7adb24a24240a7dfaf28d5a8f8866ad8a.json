{"ast":null,"code":"import { assert, findInsertIndex, isNumber } from \"../../util\";\nimport { $push } from \"./push\";\n/**\n * Returns an array of scalar values that correspond to specified percentile values. Uses \"approximate\" method by default.\n *\n * If 'expr.method' is \"approximate\", we return the closest value to the computed percentile from the dataset.\n * If 'expr.method' is \"exact\", we return the computed percentile value as is which may not be found in the dataset.\n *\n * @param collection The collection of objects.\n * @param expr The operator expression.\n * @param options Options to use for processing.\n * @returns {Object|*}\n */\nexport const $percentile = (collection, expr, options) => {\n  // MongoDB uses the t-digest algorithm to estimate percentiles.\n  // Since this library expects all data in memory we use the linear interpolation method.\n  const X = $push(collection, expr.input, options).filter(isNumber).sort();\n  const centiles = $push(expr.p, \"$$CURRENT\", options).filter(isNumber);\n  const method = expr.method || \"approximate\";\n  return centiles.map(p => {\n    assert(p > 0 && p <= 1, `percentile value must be between 0 (exclusive) and 1 (inclusive): invalid '${p}'.`);\n    // compute rank for the percentile\n    const r = p * (X.length - 1) + 1;\n    // get the integer part\n    const ri = Math.floor(r);\n    // return zero for NaN values when X[ri-1] is undefined.\n    const result = r === ri ? X[r - 1] : X[ri - 1] + r % 1 * (X[ri] - X[ri - 1] || 0);\n    switch (method) {\n      case \"exact\":\n        return result;\n      case \"approximate\":\n        {\n          // returns nearest value (inclusive) that is closest to the given centile.\n          const i = findInsertIndex(X, result);\n          // we need to adjust the selected value based on whether it falls within the percentile range.\n          // e.g. for X = [10, 20], p <= 0.5 should equal 10 AND p > 0.5 should equal 20.\n          return i / X.length >= p ? X[Math.max(i - 1, 0)] : X[i];\n        }\n    }\n  });\n};","map":{"version":3,"names":["assert","findInsertIndex","isNumber","$push","$percentile","collection","expr","options","X","input","filter","sort","centiles","p","method","map","r","length","ri","Math","floor","result","i","max"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/accumulator/percentile.js"],"sourcesContent":["import { assert, findInsertIndex, isNumber } from \"../../util\";\nimport { $push } from \"./push\";\n/**\n * Returns an array of scalar values that correspond to specified percentile values. Uses \"approximate\" method by default.\n *\n * If 'expr.method' is \"approximate\", we return the closest value to the computed percentile from the dataset.\n * If 'expr.method' is \"exact\", we return the computed percentile value as is which may not be found in the dataset.\n *\n * @param collection The collection of objects.\n * @param expr The operator expression.\n * @param options Options to use for processing.\n * @returns {Object|*}\n */\nexport const $percentile = (collection, expr, options) => {\n    // MongoDB uses the t-digest algorithm to estimate percentiles.\n    // Since this library expects all data in memory we use the linear interpolation method.\n    const X = $push(collection, expr.input, options).filter(isNumber).sort();\n    const centiles = $push(expr.p, \"$$CURRENT\", options).filter(isNumber);\n    const method = expr.method || \"approximate\";\n    return centiles.map(p => {\n        assert(p > 0 && p <= 1, `percentile value must be between 0 (exclusive) and 1 (inclusive): invalid '${p}'.`);\n        // compute rank for the percentile\n        const r = p * (X.length - 1) + 1;\n        // get the integer part\n        const ri = Math.floor(r);\n        // return zero for NaN values when X[ri-1] is undefined.\n        const result = r === ri ? X[r - 1] : X[ri - 1] + (r % 1) * (X[ri] - X[ri - 1] || 0);\n        switch (method) {\n            case \"exact\":\n                return result;\n            case \"approximate\": {\n                // returns nearest value (inclusive) that is closest to the given centile.\n                const i = findInsertIndex(X, result);\n                // we need to adjust the selected value based on whether it falls within the percentile range.\n                // e.g. for X = [10, 20], p <= 0.5 should equal 10 AND p > 0.5 should equal 20.\n                return i / X.length >= p ? X[Math.max(i - 1, 0)] : X[i];\n            }\n        }\n    });\n};\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,eAAe,EAAEC,QAAQ,QAAQ,YAAY;AAC9D,SAASC,KAAK,QAAQ,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAGA,CAACC,UAAU,EAAEC,IAAI,EAAEC,OAAO,KAAK;EACtD;EACA;EACA,MAAMC,CAAC,GAAGL,KAAK,CAACE,UAAU,EAAEC,IAAI,CAACG,KAAK,EAAEF,OAAO,CAAC,CAACG,MAAM,CAACR,QAAQ,CAAC,CAACS,IAAI,CAAC,CAAC;EACxE,MAAMC,QAAQ,GAAGT,KAAK,CAACG,IAAI,CAACO,CAAC,EAAE,WAAW,EAAEN,OAAO,CAAC,CAACG,MAAM,CAACR,QAAQ,CAAC;EACrE,MAAMY,MAAM,GAAGR,IAAI,CAACQ,MAAM,IAAI,aAAa;EAC3C,OAAOF,QAAQ,CAACG,GAAG,CAACF,CAAC,IAAI;IACrBb,MAAM,CAACa,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAI,CAAC,EAAE,8EAA8EA,CAAC,IAAI,CAAC;IAC5G;IACA,MAAMG,CAAC,GAAGH,CAAC,IAAIL,CAAC,CAACS,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;IAChC;IACA,MAAMC,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACJ,CAAC,CAAC;IACxB;IACA,MAAMK,MAAM,GAAGL,CAAC,KAAKE,EAAE,GAAGV,CAAC,CAACQ,CAAC,GAAG,CAAC,CAAC,GAAGR,CAAC,CAACU,EAAE,GAAG,CAAC,CAAC,GAAIF,CAAC,GAAG,CAAC,IAAKR,CAAC,CAACU,EAAE,CAAC,GAAGV,CAAC,CAACU,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;IACnF,QAAQJ,MAAM;MACV,KAAK,OAAO;QACR,OAAOO,MAAM;MACjB,KAAK,aAAa;QAAE;UAChB;UACA,MAAMC,CAAC,GAAGrB,eAAe,CAACO,CAAC,EAAEa,MAAM,CAAC;UACpC;UACA;UACA,OAAOC,CAAC,GAAGd,CAAC,CAACS,MAAM,IAAIJ,CAAC,GAAGL,CAAC,CAACW,IAAI,CAACI,GAAG,CAACD,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,GAAGd,CAAC,CAACc,CAAC,CAAC;QAC3D;IACJ;EACJ,CAAC,CAAC;AACN,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}