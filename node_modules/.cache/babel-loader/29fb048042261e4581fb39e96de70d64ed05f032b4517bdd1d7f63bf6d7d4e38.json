{"ast":null,"code":"import { Iterator, Lazy } from \"../../lazy\";\nimport { isEmpty, isString, removeValue, resolve, resolveGraph, setValue } from \"../../util\";\n/**\n * Takes an array of documents and returns them as a stream of documents.\n *\n * @param collection\n * @param expr\n * @param options\n * @returns {Array}\n */\nexport const $unwind = (collection, expr, _options) => {\n  if (isString(expr)) expr = {\n    path: expr\n  };\n  const path = expr.path;\n  const field = path.substring(1);\n  const includeArrayIndex = (expr === null || expr === void 0 ? void 0 : expr.includeArrayIndex) || false;\n  const preserveNullAndEmptyArrays = expr.preserveNullAndEmptyArrays || false;\n  const format = (o, i) => {\n    if (includeArrayIndex !== false) o[includeArrayIndex] = i;\n    return o;\n  };\n  let value;\n  return Lazy(() => {\n    for (;;) {\n      // take from lazy sequence if available\n      if (value instanceof Iterator) {\n        const tmp = value.next();\n        if (!tmp.done) return tmp;\n      }\n      // fetch next object\n      const wrapper = collection.next();\n      if (wrapper.done) return wrapper;\n      // unwrap value\n      const obj = wrapper.value;\n      // get the value of the field to unwind\n      value = resolve(obj, field);\n      // throw error if value is not an array???\n      if (value instanceof Array) {\n        if (value.length === 0 && preserveNullAndEmptyArrays === true) {\n          value = null; // reset unwind value\n          removeValue(obj, field);\n          return {\n            value: format(obj, null),\n            done: false\n          };\n        } else {\n          // construct a lazy sequence for elements per value\n          value = Lazy(value).map((item, i) => {\n            const newObj = resolveGraph(obj, field, {\n              preserveKeys: true\n            });\n            setValue(newObj, field, item);\n            return format(newObj, i);\n          });\n        }\n      } else if (!isEmpty(value) || preserveNullAndEmptyArrays === true) {\n        return {\n          value: format(obj, null),\n          done: false\n        };\n      }\n    }\n  });\n};","map":{"version":3,"names":["Iterator","Lazy","isEmpty","isString","removeValue","resolve","resolveGraph","setValue","$unwind","collection","expr","_options","path","field","substring","includeArrayIndex","preserveNullAndEmptyArrays","format","o","i","value","tmp","next","done","wrapper","obj","Array","length","map","item","newObj","preserveKeys"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/pipeline/unwind.js"],"sourcesContent":["import { Iterator, Lazy } from \"../../lazy\";\nimport { isEmpty, isString, removeValue, resolve, resolveGraph, setValue } from \"../../util\";\n/**\n * Takes an array of documents and returns them as a stream of documents.\n *\n * @param collection\n * @param expr\n * @param options\n * @returns {Array}\n */\nexport const $unwind = (collection, expr, _options) => {\n    if (isString(expr))\n        expr = { path: expr };\n    const path = expr.path;\n    const field = path.substring(1);\n    const includeArrayIndex = (expr === null || expr === void 0 ? void 0 : expr.includeArrayIndex) || false;\n    const preserveNullAndEmptyArrays = expr.preserveNullAndEmptyArrays || false;\n    const format = (o, i) => {\n        if (includeArrayIndex !== false)\n            o[includeArrayIndex] = i;\n        return o;\n    };\n    let value;\n    return Lazy(() => {\n        for (;;) {\n            // take from lazy sequence if available\n            if (value instanceof Iterator) {\n                const tmp = value.next();\n                if (!tmp.done)\n                    return tmp;\n            }\n            // fetch next object\n            const wrapper = collection.next();\n            if (wrapper.done)\n                return wrapper;\n            // unwrap value\n            const obj = wrapper.value;\n            // get the value of the field to unwind\n            value = resolve(obj, field);\n            // throw error if value is not an array???\n            if (value instanceof Array) {\n                if (value.length === 0 && preserveNullAndEmptyArrays === true) {\n                    value = null; // reset unwind value\n                    removeValue(obj, field);\n                    return { value: format(obj, null), done: false };\n                }\n                else {\n                    // construct a lazy sequence for elements per value\n                    value = Lazy(value).map(((item, i) => {\n                        const newObj = resolveGraph(obj, field, {\n                            preserveKeys: true\n                        });\n                        setValue(newObj, field, item);\n                        return format(newObj, i);\n                    }));\n                }\n            }\n            else if (!isEmpty(value) || preserveNullAndEmptyArrays === true) {\n                return { value: format(obj, null), done: false };\n            }\n        }\n    });\n};\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,IAAI,QAAQ,YAAY;AAC3C,SAASC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,OAAO,EAAEC,YAAY,EAAEC,QAAQ,QAAQ,YAAY;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAGA,CAACC,UAAU,EAAEC,IAAI,EAAEC,QAAQ,KAAK;EACnD,IAAIR,QAAQ,CAACO,IAAI,CAAC,EACdA,IAAI,GAAG;IAAEE,IAAI,EAAEF;EAAK,CAAC;EACzB,MAAME,IAAI,GAAGF,IAAI,CAACE,IAAI;EACtB,MAAMC,KAAK,GAAGD,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC;EAC/B,MAAMC,iBAAiB,GAAG,CAACL,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACK,iBAAiB,KAAK,KAAK;EACvG,MAAMC,0BAA0B,GAAGN,IAAI,CAACM,0BAA0B,IAAI,KAAK;EAC3E,MAAMC,MAAM,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;IACrB,IAAIJ,iBAAiB,KAAK,KAAK,EAC3BG,CAAC,CAACH,iBAAiB,CAAC,GAAGI,CAAC;IAC5B,OAAOD,CAAC;EACZ,CAAC;EACD,IAAIE,KAAK;EACT,OAAOnB,IAAI,CAAC,MAAM;IACd,SAAS;MACL;MACA,IAAImB,KAAK,YAAYpB,QAAQ,EAAE;QAC3B,MAAMqB,GAAG,GAAGD,KAAK,CAACE,IAAI,CAAC,CAAC;QACxB,IAAI,CAACD,GAAG,CAACE,IAAI,EACT,OAAOF,GAAG;MAClB;MACA;MACA,MAAMG,OAAO,GAAGf,UAAU,CAACa,IAAI,CAAC,CAAC;MACjC,IAAIE,OAAO,CAACD,IAAI,EACZ,OAAOC,OAAO;MAClB;MACA,MAAMC,GAAG,GAAGD,OAAO,CAACJ,KAAK;MACzB;MACAA,KAAK,GAAGf,OAAO,CAACoB,GAAG,EAAEZ,KAAK,CAAC;MAC3B;MACA,IAAIO,KAAK,YAAYM,KAAK,EAAE;QACxB,IAAIN,KAAK,CAACO,MAAM,KAAK,CAAC,IAAIX,0BAA0B,KAAK,IAAI,EAAE;UAC3DI,KAAK,GAAG,IAAI,CAAC,CAAC;UACdhB,WAAW,CAACqB,GAAG,EAAEZ,KAAK,CAAC;UACvB,OAAO;YAAEO,KAAK,EAAEH,MAAM,CAACQ,GAAG,EAAE,IAAI,CAAC;YAAEF,IAAI,EAAE;UAAM,CAAC;QACpD,CAAC,MACI;UACD;UACAH,KAAK,GAAGnB,IAAI,CAACmB,KAAK,CAAC,CAACQ,GAAG,CAAE,CAACC,IAAI,EAAEV,CAAC,KAAK;YAClC,MAAMW,MAAM,GAAGxB,YAAY,CAACmB,GAAG,EAAEZ,KAAK,EAAE;cACpCkB,YAAY,EAAE;YAClB,CAAC,CAAC;YACFxB,QAAQ,CAACuB,MAAM,EAAEjB,KAAK,EAAEgB,IAAI,CAAC;YAC7B,OAAOZ,MAAM,CAACa,MAAM,EAAEX,CAAC,CAAC;UAC5B,CAAE,CAAC;QACP;MACJ,CAAC,MACI,IAAI,CAACjB,OAAO,CAACkB,KAAK,CAAC,IAAIJ,0BAA0B,KAAK,IAAI,EAAE;QAC7D,OAAO;UAAEI,KAAK,EAAEH,MAAM,CAACQ,GAAG,EAAE,IAAI,CAAC;UAAEF,IAAI,EAAE;QAAM,CAAC;MACpD;IACJ;EACJ,CAAC,CAAC;AACN,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}