{"ast":null,"code":"/**\n * Utility constants and functions\n */\nimport { MingoError } from \"./types\";\nexport const MAX_INT = 2147483647;\nexport const MIN_INT = -2147483648;\nexport const MAX_LONG = Number.MAX_SAFE_INTEGER;\nexport const MIN_LONG = Number.MIN_SAFE_INTEGER;\n// special value to identify missing items. treated differently from undefined\nconst MISSING = Symbol(\"missing\");\nconst CYCLE_FOUND_ERROR = Object.freeze(new Error(\"mingo: cycle detected while processing object/array\"));\nconst ARRAY_PROTO = Object.getPrototypeOf([]);\nconst OBJECT_PROTO = Object.getPrototypeOf({});\nconst OBJECT_TAG = \"[object Object]\";\nconst OBJECT_TYPE_RE = /^\\[object ([a-zA-Z0-9]+)\\]$/;\nclass Null {}\nclass Undefined {}\nconst getConstructor = v => {\n  if (v === null) return Null;\n  if (v === undefined) return Undefined;\n  return v.constructor;\n};\n/**\n * Uses the simple hash method as described in Effective Java.\n * @see https://stackoverflow.com/a/113600/1370481\n * @param value The value to hash\n * @returns {number}\n */\nconst DEFAULT_HASH_FUNCTION = value => {\n  const s = stringify(value);\n  let hash = 0;\n  let i = s.length;\n  while (i) hash = (hash << 5) - hash ^ s.charCodeAt(--i);\n  return hash >>> 0;\n};\n// no array, object, or function types\nconst JS_SIMPLE_TYPES = new Set([\"null\", \"undefined\", \"boolean\", \"number\", \"string\", \"date\", \"regexp\"]);\nconst IMMUTABLE_TYPES_SET = new Set([Undefined, Null, Boolean, String, Number]);\n/** Convert simple value to string representation. */\nconst toString = v => v.toString(); // eslint-disable-line @typescript-eslint/no-base-to-string\n/** Convert a typed array to string representation. */\nconst typedArrayToString = v => `${getConstructor(v).name}[${v.toString()}]`; // eslint-disable-line @typescript-eslint/no-base-to-string\n/** Map of constructors to string converter functions */\nconst STRING_CONVERTERS = new Map([[Number, toString], [Boolean, toString], [RegExp, toString], [Function, toString], [Symbol, toString], [Date, d => d.toISOString()], [String, JSON.stringify], [Null, _ => \"null\"], [Undefined, _ => \"undefined\"], [Int8Array, typedArrayToString], [Uint8Array, typedArrayToString], [Uint8ClampedArray, typedArrayToString], [Int16Array, typedArrayToString], [Uint16Array, typedArrayToString], [Int32Array, typedArrayToString], [Uint32Array, typedArrayToString], [Float32Array, typedArrayToString], [Float64Array, typedArrayToString]]);\n/**\n * Some types like BigInt are not available on more exotic\n * JavaScript runtimes like ReactNative or QuickJS.\n * So we fill them in only if they exist so that it does not throw an error.\n */\nif (typeof BigInt !== \"undefined\") {\n  STRING_CONVERTERS.set(BigInt, n => \"0x\" + n.toString(16));\n}\nif (typeof BigInt64Array !== \"undefined\") {\n  STRING_CONVERTERS.set(BigInt64Array, typedArrayToString);\n}\nif (typeof BigUint64Array !== \"undefined\") {\n  STRING_CONVERTERS.set(BigUint64Array, typedArrayToString);\n}\n/** MongoDB sort comparison order. https://www.mongodb.com/docs/manual/reference/bson-type-comparison-order */\nconst SORT_ORDER_BY_TYPE = {\n  null: 0,\n  undefined: 0,\n  number: 1,\n  string: 2,\n  object: 3,\n  array: 4,\n  boolean: 5,\n  date: 6,\n  regexp: 7,\n  function: 8\n};\n/**\n * Compare function which adheres to MongoDB comparison order.\n *\n * @param a The first value\n * @param b The second value\n * @returns {Number}\n */\nexport const compare = (a, b) => {\n  if (a === MISSING) a = undefined;\n  if (b === MISSING) b = undefined;\n  const [u, v] = [a, b].map(n => SORT_ORDER_BY_TYPE[getType(n).toLowerCase()]);\n  if (u !== v) return u - v;\n  // number | string | date\n  if (u === 1 || u === 2 || u === 6) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  }\n  // check for equivalence equality\n  if (isEqual(a, b)) return 0;\n  if (a < b) return -1;\n  if (a > b) return 1;\n  // if we get here we are comparing a type that does not make sense.\n  return 0;\n};\nexport function assert(condition, message) {\n  if (!condition) throw new MingoError(message);\n}\nconst isTypedArray = v => {\n  const proto = Object.getPrototypeOf(getConstructor(v));\n  return proto && proto.name === \"TypedArray\";\n};\n/**\n * Deep clone an object. Value types and immutable objects are returned as is.\n */\nexport const cloneDeep = obj => {\n  if (IMMUTABLE_TYPES_SET.has(getConstructor(obj))) return obj;\n  const cycle = new Set();\n  const clone = val => {\n    if (cycle.has(val)) throw CYCLE_FOUND_ERROR;\n    const ctor = getConstructor(val);\n    if (IMMUTABLE_TYPES_SET.has(ctor)) return val;\n    try {\n      // arrays\n      if (isArray(val)) {\n        cycle.add(val);\n        return val.map(clone);\n      }\n      // object literals\n      if (isObject(val)) {\n        cycle.add(val);\n        const res = {};\n        for (const k in val) res[k] = clone(val[k]);\n        return res;\n      }\n    } finally {\n      cycle.delete(val);\n    }\n    // dates, regex, typed arrays\n    if (ctor === Date || ctor === RegExp || isTypedArray(val)) {\n      return new ctor(val);\n    }\n    return val;\n  };\n  return clone(obj);\n};\n/**\n * Returns the name of type as specified in the tag returned by a call to Object.prototype.toString\n * @param v A value\n */\nexport const getType = v => OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];\nexport const isBoolean = v => typeof v === \"boolean\";\nexport const isString = v => typeof v === \"string\";\nexport const isSymbol = v => typeof v === \"symbol\";\nexport const isNumber = v => !isNaN(v) && typeof v === \"number\";\nexport const isBigInt = v => !isNaN(v) && typeof v === \"bigint\";\nexport const isNotNaN = v => !(isNaN(v) && typeof v === \"number\");\nexport const isArray = Array.isArray;\nexport const isObject = v => {\n  if (!v) return false;\n  const proto = Object.getPrototypeOf(v);\n  return (proto === OBJECT_PROTO || proto === null) && OBJECT_TAG === Object.prototype.toString.call(v);\n};\n//  objects, arrays, functions, date, custom object\nexport const isObjectLike = v => v === Object(v);\nexport const isDate = v => v instanceof Date;\nexport const isRegExp = v => v instanceof RegExp;\nexport const isFunction = v => typeof v === \"function\";\nexport const isNil = v => v === null || v === undefined;\nexport const inArray = (arr, item) => arr.includes(item);\nexport const notInArray = (arr, item) => !inArray(arr, item);\nexport const truthy = (arg, strict = true) => !!arg || strict && arg === \"\";\nexport const isEmpty = x => isNil(x) || isString(x) && !x || x instanceof Array && x.length === 0 || isObject(x) && Object.keys(x).length === 0;\nexport const isMissing = v => v === MISSING;\n/** ensure a value is an array or wrapped within one. */\nexport const ensureArray = x => x instanceof Array ? x : [x];\nexport const has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\nconst mergeable = (left, right) => isObject(left) && isObject(right) || isArray(left) && isArray(right);\n/**\n * Deep merge objects or arrays.\n * When the inputs have unmergeable types, the  right hand value is returned.\n * If inputs are arrays and options.flatten is set, elements in the same position are merged together. Remaining elements are appended to the target object.\n * If options.flatten is false, the right hand value is just appended to the left-hand value.\n * @param target {Object|Array} the target to merge into\n * @param obj {Object|Array} the source object\n */\nexport function merge(target, obj, options) {\n  // default options\n  options = options || {\n    flatten: false\n  };\n  // take care of missing inputs\n  if (isMissing(target) || isNil(target)) return obj;\n  if (isMissing(obj) || isNil(obj)) return target;\n  // fail only on initial input.\n  if (!mergeable(target, obj)) {\n    if (options.skipValidation) return obj || target;\n    throw Error(\"mismatched types. must both be array or object\");\n  }\n  // skip validation after initial input.\n  options.skipValidation = true;\n  if (isArray(target)) {\n    const result = target;\n    const input = obj;\n    if (options.flatten) {\n      let i = 0;\n      let j = 0;\n      while (i < result.length && j < input.length) {\n        result[i] = merge(result[i++], input[j++], options);\n      }\n      while (j < input.length) {\n        result.push(obj[j++]);\n      }\n    } else {\n      into(result, input);\n    }\n  } else {\n    for (const k in obj) {\n      target[k] = merge(target[k], obj[k], options);\n    }\n  }\n  return target;\n}\nfunction buildHashIndex(arr, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const map = new Map();\n  arr.forEach((o, i) => {\n    const h = hashCode(o, hashFunction);\n    if (map.has(h)) {\n      if (!map.get(h).some(j => isEqual(arr[j], o))) {\n        map.get(h).push(i);\n      }\n    } else {\n      map.set(h, [i]);\n    }\n  });\n  return map;\n}\n/**\n * Returns the intersection of multiple arrays.\n *\n * @param  {Array} input An array of arrays from which to find intersection.\n * @param  {Function} hashFunction Custom function to hash values, default the hashCode method\n * @return {Array} Array of intersecting values.\n */\nexport function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  // if any array is empty, there is no intersection\n  if (input.some(arr => arr.length == 0)) return [];\n  if (input.length === 1) return Array.from(input);\n  // sort input arrays by to get smallest array\n  // const sorted = sortBy(input, (a: RawArray) => a.length) as RawArray[];\n  const sortedIndex = sortBy(input.map((a, i) => [i, a.length]), a => a[1]);\n  // get the smallest\n  const smallest = input[sortedIndex[0][0]];\n  // get hash index of smallest array\n  const map = buildHashIndex(smallest, hashFunction);\n  // hashIndex for remaining arrays.\n  const rmap = new Map();\n  // final intersection results and index of first occurrence.\n  const results = new Array();\n  map.forEach((v, k) => {\n    const lhs = v.map(j => smallest[j]);\n    const res = lhs.map(_ => 0);\n    // used to track first occurence of value in order of the original input array.\n    const stable = lhs.map(_ => [sortedIndex[0][0], 0]);\n    let found = false;\n    for (let i = 1; i < input.length; i++) {\n      const [currIndex, _] = sortedIndex[i];\n      const arr = input[currIndex];\n      if (!rmap.has(i)) rmap.set(i, buildHashIndex(arr));\n      // we found a match. let's confirm.\n      if (rmap.get(i).has(k)) {\n        const rhs = rmap.get(i).get(k).map(j => arr[j]);\n        // confirm the intersection with an equivalence check.\n        found = lhs.map((s, n) => rhs.some((t, m) => {\n          // we expect only one to match here since these are just collisions.\n          const p = res[n];\n          if (isEqual(s, t)) {\n            res[n]++;\n            // track position of value ordering for stability.\n            if (currIndex < stable[n][0]) {\n              stable[n] = [currIndex, rmap.get(i).get(k)[m]];\n            }\n          }\n          return p < res[n];\n        })).some(Boolean);\n      }\n      // found nothing, so exclude value. this was just a hash collision.\n      if (!found) return;\n    }\n    // extract value into result if we found an intersection.\n    // we find an intersection if the frequency counter matches the count of the remaining arrays.\n    if (found) {\n      into(results, res.map((n, i) => {\n        return n === input.length - 1 ? [lhs[i], stable[i]] : MISSING;\n      }).filter(n => n !== MISSING));\n    }\n  });\n  return results.sort((a, b) => {\n    const [_i, [u, m]] = a;\n    const [_j, [v, n]] = b;\n    const r = compare(u, v);\n    if (r !== 0) return r;\n    return compare(m, n);\n  }).map(v => v[0]);\n}\n/**\n * Flatten the array\n *\n * @param {Array} xs The array to flatten\n * @param {Number} depth The number of nested lists to iterate\n */\nexport function flatten(xs, depth = 0) {\n  const arr = new Array();\n  function flatten2(ys, n) {\n    for (let i = 0, len = ys.length; i < len; i++) {\n      if (isArray(ys[i]) && (n > 0 || n < 0)) {\n        flatten2(ys[i], Math.max(-1, n - 1));\n      } else {\n        arr.push(ys[i]);\n      }\n    }\n  }\n  flatten2(xs, depth);\n  return arr;\n}\n/** Returns all members of the value in an object literal. */\nconst getMembersOf = value => {\n  let [proto, names] = [Object.getPrototypeOf(value), Object.getOwnPropertyNames(value)];\n  // save effective prototype\n  let activeProto = proto;\n  // traverse the prototype hierarchy until we get property names or hit the bottom prototype.\n  while (!names.length && proto !== OBJECT_PROTO && proto !== ARRAY_PROTO) {\n    activeProto = proto;\n    names = Object.getOwnPropertyNames(proto);\n    proto = Object.getPrototypeOf(proto);\n  }\n  const o = {};\n  names.forEach(k => o[k] = value[k]);\n  return [o, activeProto];\n};\n/**\n * Determine whether two values are the same or strictly equivalent.\n * Checking whether values are the same only applies to built in objects.\n * For user-defined objects this checks for only referential equality so\n * two different instances with the same values are not equal.\n *\n * @param  {*}  a The first value\n * @param  {*}  b The second value\n * @return {Boolean}   Result of comparison\n */\nexport function isEqual(a, b) {\n  const args = [[a, b]];\n  while (args.length > 0) {\n    [a, b] = args.pop();\n    // strictly equal must be equal. matches referentially equal values.\n    if (a === b) continue;\n    // unequal types and functions (unless referentially equivalent) cannot be equal.\n    const ctor = getConstructor(a);\n    if (ctor !== getConstructor(b) || isFunction(a)) return false;\n    // string convertable types\n    if (STRING_CONVERTERS.has(ctor)) {\n      const str = STRING_CONVERTERS.get(ctor);\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      if (str(a) !== str(b)) return false;\n      // values are equal, so move next\n      continue;\n    }\n    // handle array and object types\n    if (ctor === Array || ctor === Object) {\n      const ka = Object.keys(a);\n      const kb = Object.keys(b);\n      if (ka.length !== kb.length) return false;\n      if (new Set(ka.concat(kb)).size != ka.length) return false;\n      for (const k of ka) args.push([a[k], b[k]]);\n      // move next\n      continue;\n    }\n    // user-defined type detected.\n    // we don't try to compare user-defined types (even though we could...shhhh).\n    return false;\n  }\n  // nothing left to compare\n  return !args.length;\n}\n/**\n * Return a new unique version of the collection\n * @param  {Array} input The input collection\n * @return {Array}\n */\nexport function unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const result = input.map(_ => MISSING);\n  buildHashIndex(input, hashFunction).forEach((v, _) => {\n    v.forEach(i => result[i] = input[i]);\n  });\n  return result.filter(v => v !== MISSING);\n}\n/**\n * Encode value to string using a simple non-colliding stable scheme.\n * Handles user-defined types by processing keys on first non-empty prototype.\n * If a user-defined type provides a \"toJSON\" function, it is used.\n *\n * @param value The value to convert to a string representation.\n * @returns {String}\n */\nexport function stringify(value) {\n  const cycle = new Set();\n  // stringify with cycle check\n  const str = v => {\n    const ctor = getConstructor(v);\n    // string convertable types\n    if (STRING_CONVERTERS.has(ctor)) {\n      return STRING_CONVERTERS.get(ctor)(v);\n    }\n    const tag = ctor === Object ? \"\" : ctor.name;\n    // handle JSONable objects.\n    if (isFunction(v[\"toJSON\"])) {\n      return `${tag}(${JSON.stringify(v)})`;\n    }\n    // handle cycles\n    if (cycle.has(v)) throw CYCLE_FOUND_ERROR;\n    cycle.add(v);\n    try {\n      // handle array\n      if (ctor === Array) {\n        return \"[\" + v.map(str).join(\",\") + \"]\";\n      }\n      // handle user-defined object\n      if (ctor !== Object) {\n        // handle user-defined types or object literals.\n        const [members, _] = getMembersOf(v);\n        // custom type derived from array.\n        if (isArray(v)) {\n          // include other members as part of array elements.\n          return `${tag}${str([...v, members])}`;\n        }\n        // get members as literal\n        v = members;\n      }\n      const objKeys = Object.keys(v);\n      objKeys.sort();\n      return `${tag}{` + objKeys.map(k => `${k}:${str(v[k])}`).join(\",\") + \"}\";\n    } finally {\n      cycle.delete(v);\n    }\n  };\n  // convert to string\n  return str(value);\n}\n/**\n * Generate hash code\n * This selected function is the result of benchmarking various hash functions.\n * This version performs well and can hash 10^6 documents in ~3s with on average 100 collisions.\n *\n * @param value\n * @returns {number|null}\n */\nexport function hashCode(value, hashFunction) {\n  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;\n  if (isNil(value)) return null;\n  return hashFunction(value).toString();\n}\n/**\n * Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee\n *\n * This implementation treats null/undefined sort keys as less than every other type\n *\n * @param {Array}   collection\n * @param {Function} keyFn The sort key function used to resolve sort keys\n * @param {Function} comparator The comparator function to use for comparing keys. Defaults to standard comparison via `compare(...)`\n * @return {Array} Returns a new sorted array by the given key and comparator function\n */\nexport function sortBy(collection, keyFn, comparator = compare) {\n  if (isEmpty(collection)) return collection;\n  const sorted = new Array();\n  const result = new Array();\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    if (isNil(key)) {\n      result.push(obj);\n    } else {\n      sorted.push([key, obj]);\n    }\n  }\n  // use native array sorting but enforce stableness\n  sorted.sort((a, b) => comparator(a[0], b[0]));\n  return into(result, sorted.map(o => o[1]));\n}\n/**\n * Groups the collection into sets by the returned key\n *\n * @param collection\n * @param keyFn {Function} to compute the group key of an item in the collection\n * @returns {GroupByOutput}\n */\nexport function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  if (collection.length < 1) return new Map();\n  // map of hash to collided values\n  const lookup = new Map();\n  // map of raw key values to objects.\n  const result = new Map();\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    const hash = hashCode(key, hashFunction);\n    if (hash === null) {\n      if (result.has(null)) {\n        result.get(null).push(obj);\n      } else {\n        result.set(null, [obj]);\n      }\n    } else {\n      // find if we can match a hash for which the value is equivalent.\n      // this is used to deal with collisions.\n      const existingKey = lookup.has(hash) ? lookup.get(hash).find(k => isEqual(k, key)) : null;\n      // collision detected or first time seeing key\n      if (isNil(existingKey)) {\n        // collision detected or first entry so we create a new group.\n        result.set(key, [obj]);\n        // upload the lookup with the collided key\n        if (lookup.has(hash)) {\n          lookup.get(hash).push(key);\n        } else {\n          lookup.set(hash, [key]);\n        }\n      } else {\n        // key exists\n        result.get(existingKey).push(obj);\n      }\n    }\n  }\n  return result;\n}\n// max elements to push.\n// See argument limit https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\nconst MAX_ARRAY_PUSH = 50000;\n/**\n * Merge elements into the dest\n *\n * @param {*} target The target object\n * @param {*} rest The array of elements to merge into dest\n */\nexport function into(target, ...rest) {\n  if (target instanceof Array) {\n    return rest.reduce((acc, arr) => {\n      // push arrary in batches to handle large inputs\n      let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n      let begin = 0;\n      while (i-- > 0) {\n        Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));\n        begin += MAX_ARRAY_PUSH;\n      }\n      return acc;\n    }, target);\n  } else {\n    // merge objects. same behaviour as Object.assign\n    return rest.filter(isObjectLike).reduce((acc, item) => {\n      Object.assign(acc, item);\n      return acc;\n    }, target);\n  }\n}\n/**\n * This is a generic memoization function\n *\n * This implementation uses a cache independent of the function being memoized\n * to allow old values to be garbage collected when the memoized function goes out of scope.\n *\n * @param {*} fn The function object to memoize\n */\nexport function memoize(fn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  return (memo => {\n    return (...args) => {\n      const key = hashCode(args, hashFunction) || \"\";\n      if (!has(memo, key)) {\n        memo[key] = fn.apply(this, args);\n      }\n      return memo[key];\n    };\n  })({\n    /* storage */\n  });\n}\n// mingo internal\n/**\n * Retrieve the value of a given key on an object\n * @param obj\n * @param key\n * @returns {*}\n * @private\n */\nfunction getValue(obj, key) {\n  return isObjectLike(obj) ? obj[key] : undefined;\n}\n/**\n * Unwrap a single element array to specified depth\n * @param {Array} arr\n * @param {Number} depth\n */\nfunction unwrap(arr, depth) {\n  if (depth < 1) return arr;\n  while (depth-- && arr.length === 1) arr = arr[0];\n  return arr;\n}\n/**\n * Resolve the value of the field (dot separated) on the given object\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n * @returns {*}\n */\nexport function resolve(obj, selector, options) {\n  let depth = 0;\n  function resolve2(o, path) {\n    let value = o;\n    for (let i = 0; i < path.length; i++) {\n      const field = path[i];\n      const isText = /^\\d+$/.exec(field) === null;\n      // using instanceof to aid typescript compiler\n      if (isText && value instanceof Array) {\n        // On the first iteration, we check if we received a stop flag.\n        // If so, we stop to prevent iterating over a nested array value\n        // on consecutive object keys in the selector.\n        if (i === 0 && depth > 0) break;\n        depth += 1;\n        // only look at the rest of the path\n        const subpath = path.slice(i);\n        value = value.reduce((acc, item) => {\n          const v = resolve2(item, subpath);\n          if (v !== undefined) acc.push(v);\n          return acc;\n        }, []);\n        break;\n      } else {\n        value = getValue(value, field);\n      }\n      if (value === undefined) break;\n    }\n    return value;\n  }\n  const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase()) ? obj : resolve2(obj, selector.split(\".\"));\n  return result instanceof Array && (options === null || options === void 0 ? void 0 : options.unwrapArray) ? unwrap(result, depth) : result;\n}\n/**\n * Returns the full object to the resolved value given by the selector.\n * This function excludes empty values as they aren't practically useful.\n *\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n */\nexport function resolveGraph(obj, selector, options) {\n  const names = selector.split(\".\");\n  const key = names[0];\n  // get the next part of the selector\n  const next = names.slice(1).join(\".\");\n  const isIndex = /^\\d+$/.exec(key) !== null;\n  const hasNext = names.length > 1;\n  let result;\n  let value;\n  if (obj instanceof Array) {\n    if (isIndex) {\n      result = getValue(obj, Number(key));\n      if (hasNext) {\n        result = resolveGraph(result, next, options);\n      }\n      result = [result];\n    } else {\n      result = [];\n      for (const item of obj) {\n        value = resolveGraph(item, selector, options);\n        if (options === null || options === void 0 ? void 0 : options.preserveMissing) {\n          if (value === undefined) {\n            value = MISSING;\n          }\n          result.push(value);\n        } else if (value !== undefined) {\n          result.push(value);\n        }\n      }\n    }\n  } else {\n    value = getValue(obj, key);\n    if (hasNext) {\n      value = resolveGraph(value, next, options);\n    }\n    if (value === undefined) return undefined;\n    result = (options === null || options === void 0 ? void 0 : options.preserveKeys) ? Object.assign({}, obj) : {};\n    result[key] = value;\n  }\n  return result;\n}\n/**\n * Filter out all MISSING values from the object in-place\n *\n * @param obj The object to filter\n */\nexport function filterMissing(obj) {\n  if (obj instanceof Array) {\n    for (let i = obj.length - 1; i >= 0; i--) {\n      if (obj[i] === MISSING) {\n        obj.splice(i, 1);\n      } else {\n        filterMissing(obj[i]);\n      }\n    }\n  } else if (isObject(obj)) {\n    for (const k in obj) {\n      if (has(obj, k)) {\n        filterMissing(obj[k]);\n      }\n    }\n  }\n}\nconst NUMBER_RE = /^\\d+$/;\n/**\n * Walk the object graph and execute the given transform function\n *\n * @param  {Object|Array} obj   The object to traverse.\n * @param  {String} selector    The selector to navigate.\n * @param  {Callback} fn Callback to execute for value at the end the traversal.\n * @param  {WalkOptions} options The opetions to use for the function.\n * @return {*}\n */\nexport function walk(obj, selector, fn, options) {\n  const names = selector.split(\".\");\n  const key = names[0];\n  const next = names.slice(1).join(\".\");\n  if (names.length === 1) {\n    if (isObject(obj) || isArray(obj) && NUMBER_RE.test(key)) {\n      fn(obj, key);\n    }\n  } else {\n    // force the rest of the graph while traversing\n    if ((options === null || options === void 0 ? void 0 : options.buildGraph) && isNil(obj[key])) {\n      obj[key] = {};\n    }\n    // get the next item\n    const item = obj[key];\n    // nothing more to do\n    if (!item) return;\n    // we peek to see if next key is an array index.\n    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));\n    // if we have an array value but the next key is not an index and the 'descendArray' option is set,\n    // we walk each item in the array separately. This allows for handling traversing keys for objects\n    // nested within an array.\n    //\n    // Eg: Given { array: [ {k:1}, {k:2}, {k:3} ] }\n    //  - individual objecs can be traversed with \"array.k\"\n    //  - a specific object can be traversed with \"array.1\"\n    if (item instanceof Array && (options === null || options === void 0 ? void 0 : options.descendArray) && !isNextArrayIndex) {\n      item.forEach(e => walk(e, next, fn, options));\n    } else {\n      walk(item, next, fn, options);\n    }\n  }\n}\n/**\n * Set the value of the given object field\n *\n * @param obj {Object|Array} the object context\n * @param selector {String} path to field\n * @param value {*} the value to set. if it is function, it is invoked with the old value and must return the new value.\n */\nexport function setValue(obj, selector, value) {\n  walk(obj, selector, (item, key) => {\n    item[key] = isFunction(value) ? value(item[key]) : value;\n  }, {\n    buildGraph: true\n  });\n}\n/**\n * Removes an element from the container.\n * If the selector resolves to an array and the leaf is a non-numeric key,\n * the remove operation will be performed on objects of the array.\n *\n * @param obj {ArrayOrObject} object or array\n * @param selector {String} dot separated path to element to remove\n */\nexport function removeValue(obj, selector, options) {\n  walk(obj, selector, (item, key) => {\n    if (item instanceof Array) {\n      if (/^\\d+$/.test(key)) {\n        item.splice(parseInt(key), 1);\n      } else if (options && options.descendArray) {\n        for (const elem of item) {\n          if (isObject(elem)) {\n            delete elem[key];\n          }\n        }\n      }\n    } else if (isObject(item)) {\n      delete item[key];\n    }\n  }, options);\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\n/**\n * Check whether the given name passes for an operator. We assume AnyVal field name starting with '$' is an operator.\n * This is cheap and safe to do since keys beginning with '$' should be reserved for internal use.\n * @param {String} name\n */\nexport function isOperator(name) {\n  return OPERATOR_NAME_PATTERN.test(name);\n}\n/**\n * Simplify expression for easy evaluation with query operators map\n * @param expr\n * @returns {*}\n */\nexport function normalize(expr) {\n  // normalized primitives\n  if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {\n    return isRegExp(expr) ? {\n      $regex: expr\n    } : {\n      $eq: expr\n    };\n  }\n  // normalize object expression. using ObjectLike handles custom types\n  if (isObjectLike(expr)) {\n    const exprObj = expr;\n    // no valid query operator found, so we do simple comparison\n    if (!Object.keys(exprObj).some(isOperator)) {\n      return {\n        $eq: expr\n      };\n    }\n    // ensure valid regex\n    if (has(expr, \"$regex\")) {\n      const newExpr = Object.assign({}, expr);\n      newExpr[\"$regex\"] = new RegExp(expr[\"$regex\"], expr[\"$options\"]);\n      delete newExpr[\"$options\"];\n      return newExpr;\n    }\n  }\n  return expr;\n}\n/**\n * Find the insert index for the given key in a sorted array.\n *\n * @param {*} sorted The sorted array to search\n * @param {*} item The search key\n */\nexport function findInsertIndex(sorted, item) {\n  // uses binary search\n  let lo = 0;\n  let hi = sorted.length - 1;\n  while (lo <= hi) {\n    const mid = Math.round(lo + (hi - lo) / 2);\n    if (compare(item, sorted[mid]) < 0) {\n      hi = mid - 1;\n    } else if (compare(item, sorted[mid]) > 0) {\n      lo = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return lo;\n}","map":{"version":3,"names":["MingoError","MAX_INT","MIN_INT","MAX_LONG","Number","MAX_SAFE_INTEGER","MIN_LONG","MIN_SAFE_INTEGER","MISSING","Symbol","CYCLE_FOUND_ERROR","Object","freeze","Error","ARRAY_PROTO","getPrototypeOf","OBJECT_PROTO","OBJECT_TAG","OBJECT_TYPE_RE","Null","Undefined","getConstructor","v","undefined","constructor","DEFAULT_HASH_FUNCTION","value","s","stringify","hash","i","length","charCodeAt","JS_SIMPLE_TYPES","Set","IMMUTABLE_TYPES_SET","Boolean","String","toString","typedArrayToString","name","STRING_CONVERTERS","Map","RegExp","Function","Date","d","toISOString","JSON","_","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt","set","n","BigInt64Array","BigUint64Array","SORT_ORDER_BY_TYPE","null","number","string","object","array","boolean","date","regexp","function","compare","a","b","u","map","getType","toLowerCase","isEqual","assert","condition","message","isTypedArray","proto","cloneDeep","obj","has","cycle","clone","val","ctor","isArray","add","isObject","res","k","delete","exec","prototype","call","isBoolean","isString","isSymbol","isNumber","isNaN","isBigInt","isNotNaN","Array","isObjectLike","isDate","isRegExp","isFunction","isNil","inArray","arr","item","includes","notInArray","truthy","arg","strict","isEmpty","x","keys","isMissing","ensureArray","prop","hasOwnProperty","mergeable","left","right","merge","target","options","flatten","skipValidation","result","input","j","push","into","buildHashIndex","hashFunction","forEach","o","h","hashCode","get","some","intersection","from","sortedIndex","sortBy","smallest","rmap","results","lhs","stable","found","currIndex","rhs","t","m","p","filter","sort","_i","_j","r","xs","depth","flatten2","ys","len","Math","max","getMembersOf","names","getOwnPropertyNames","activeProto","args","pop","str","ka","kb","concat","size","unique","tag","join","members","objKeys","collection","keyFn","comparator","sorted","key","groupBy","lookup","existingKey","find","MAX_ARRAY_PUSH","rest","reduce","acc","ceil","begin","apply","slice","assign","memoize","fn","memo","getValue","unwrap","resolve","selector","resolve2","path","field","isText","subpath","split","unwrapArray","resolveGraph","next","isIndex","hasNext","preserveMissing","preserveKeys","filterMissing","splice","NUMBER_RE","walk","test","buildGraph","isNextArrayIndex","descendArray","e","setValue","removeValue","parseInt","elem","OPERATOR_NAME_PATTERN","isOperator","normalize","expr","$regex","$eq","exprObj","newExpr","findInsertIndex","lo","hi","mid","round"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/util.js"],"sourcesContent":["/**\n * Utility constants and functions\n */\nimport { MingoError } from \"./types\";\nexport const MAX_INT = 2147483647;\nexport const MIN_INT = -2147483648;\nexport const MAX_LONG = Number.MAX_SAFE_INTEGER;\nexport const MIN_LONG = Number.MIN_SAFE_INTEGER;\n// special value to identify missing items. treated differently from undefined\nconst MISSING = Symbol(\"missing\");\nconst CYCLE_FOUND_ERROR = Object.freeze(new Error(\"mingo: cycle detected while processing object/array\"));\nconst ARRAY_PROTO = Object.getPrototypeOf([]);\nconst OBJECT_PROTO = Object.getPrototypeOf({});\nconst OBJECT_TAG = \"[object Object]\";\nconst OBJECT_TYPE_RE = /^\\[object ([a-zA-Z0-9]+)\\]$/;\nclass Null {\n}\nclass Undefined {\n}\nconst getConstructor = (v) => {\n    if (v === null)\n        return Null;\n    if (v === undefined)\n        return Undefined;\n    return v.constructor;\n};\n/**\n * Uses the simple hash method as described in Effective Java.\n * @see https://stackoverflow.com/a/113600/1370481\n * @param value The value to hash\n * @returns {number}\n */\nconst DEFAULT_HASH_FUNCTION = (value) => {\n    const s = stringify(value);\n    let hash = 0;\n    let i = s.length;\n    while (i)\n        hash = ((hash << 5) - hash) ^ s.charCodeAt(--i);\n    return hash >>> 0;\n};\n// no array, object, or function types\nconst JS_SIMPLE_TYPES = new Set([\n    \"null\",\n    \"undefined\",\n    \"boolean\",\n    \"number\",\n    \"string\",\n    \"date\",\n    \"regexp\"\n]);\nconst IMMUTABLE_TYPES_SET = new Set([Undefined, Null, Boolean, String, Number]);\n/** Convert simple value to string representation. */\nconst toString = (v) => v.toString(); // eslint-disable-line @typescript-eslint/no-base-to-string\n/** Convert a typed array to string representation. */\nconst typedArrayToString = (v) => `${getConstructor(v).name}[${v.toString()}]`; // eslint-disable-line @typescript-eslint/no-base-to-string\n/** Map of constructors to string converter functions */\nconst STRING_CONVERTERS = new Map([\n    [Number, toString],\n    [Boolean, toString],\n    [RegExp, toString],\n    [Function, toString],\n    [Symbol, toString],\n    [Date, (d) => d.toISOString()],\n    [String, JSON.stringify],\n    [Null, (_) => \"null\"],\n    [Undefined, (_) => \"undefined\"],\n    [Int8Array, typedArrayToString],\n    [Uint8Array, typedArrayToString],\n    [Uint8ClampedArray, typedArrayToString],\n    [Int16Array, typedArrayToString],\n    [Uint16Array, typedArrayToString],\n    [Int32Array, typedArrayToString],\n    [Uint32Array, typedArrayToString],\n    [Float32Array, typedArrayToString],\n    [Float64Array, typedArrayToString]\n]);\n/**\n * Some types like BigInt are not available on more exotic\n * JavaScript runtimes like ReactNative or QuickJS.\n * So we fill them in only if they exist so that it does not throw an error.\n */\nif (typeof BigInt !== \"undefined\") {\n    STRING_CONVERTERS.set(BigInt, (n) => \"0x\" + n.toString(16));\n}\nif (typeof BigInt64Array !== \"undefined\") {\n    STRING_CONVERTERS.set(BigInt64Array, typedArrayToString);\n}\nif (typeof BigUint64Array !== \"undefined\") {\n    STRING_CONVERTERS.set(BigUint64Array, typedArrayToString);\n}\n/** MongoDB sort comparison order. https://www.mongodb.com/docs/manual/reference/bson-type-comparison-order */\nconst SORT_ORDER_BY_TYPE = {\n    null: 0,\n    undefined: 0,\n    number: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    boolean: 5,\n    date: 6,\n    regexp: 7,\n    function: 8\n};\n/**\n * Compare function which adheres to MongoDB comparison order.\n *\n * @param a The first value\n * @param b The second value\n * @returns {Number}\n */\nexport const compare = (a, b) => {\n    if (a === MISSING)\n        a = undefined;\n    if (b === MISSING)\n        b = undefined;\n    const [u, v] = [a, b].map(n => SORT_ORDER_BY_TYPE[getType(n).toLowerCase()]);\n    if (u !== v)\n        return u - v;\n    // number | string | date\n    if (u === 1 || u === 2 || u === 6) {\n        if (a < b)\n            return -1;\n        if (a > b)\n            return 1;\n        return 0;\n    }\n    // check for equivalence equality\n    if (isEqual(a, b))\n        return 0;\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    // if we get here we are comparing a type that does not make sense.\n    return 0;\n};\nexport function assert(condition, message) {\n    if (!condition)\n        throw new MingoError(message);\n}\nconst isTypedArray = (v) => {\n    const proto = Object.getPrototypeOf(getConstructor(v));\n    return proto && proto.name === \"TypedArray\";\n};\n/**\n * Deep clone an object. Value types and immutable objects are returned as is.\n */\nexport const cloneDeep = (obj) => {\n    if (IMMUTABLE_TYPES_SET.has(getConstructor(obj)))\n        return obj;\n    const cycle = new Set();\n    const clone = (val) => {\n        if (cycle.has(val))\n            throw CYCLE_FOUND_ERROR;\n        const ctor = getConstructor(val);\n        if (IMMUTABLE_TYPES_SET.has(ctor))\n            return val;\n        try {\n            // arrays\n            if (isArray(val)) {\n                cycle.add(val);\n                return val.map(clone);\n            }\n            // object literals\n            if (isObject(val)) {\n                cycle.add(val);\n                const res = {};\n                for (const k in val)\n                    res[k] = clone(val[k]);\n                return res;\n            }\n        }\n        finally {\n            cycle.delete(val);\n        }\n        // dates, regex, typed arrays\n        if (ctor === Date || ctor === RegExp || isTypedArray(val)) {\n            return new ctor(val);\n        }\n        return val;\n    };\n    return clone(obj);\n};\n/**\n * Returns the name of type as specified in the tag returned by a call to Object.prototype.toString\n * @param v A value\n */\nexport const getType = (v) => OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];\nexport const isBoolean = (v) => typeof v === \"boolean\";\nexport const isString = (v) => typeof v === \"string\";\nexport const isSymbol = (v) => typeof v === \"symbol\";\nexport const isNumber = (v) => !isNaN(v) && typeof v === \"number\";\nexport const isBigInt = (v) => !isNaN(v) && typeof v === \"bigint\";\nexport const isNotNaN = (v) => !(isNaN(v) && typeof v === \"number\");\nexport const isArray = Array.isArray;\nexport const isObject = (v) => {\n    if (!v)\n        return false;\n    const proto = Object.getPrototypeOf(v);\n    return ((proto === OBJECT_PROTO || proto === null) &&\n        OBJECT_TAG === Object.prototype.toString.call(v));\n};\n//  objects, arrays, functions, date, custom object\nexport const isObjectLike = (v) => v === Object(v);\nexport const isDate = (v) => v instanceof Date;\nexport const isRegExp = (v) => v instanceof RegExp;\nexport const isFunction = (v) => typeof v === \"function\";\nexport const isNil = (v) => v === null || v === undefined;\nexport const inArray = (arr, item) => arr.includes(item);\nexport const notInArray = (arr, item) => !inArray(arr, item);\nexport const truthy = (arg, strict = true) => !!arg || (strict && arg === \"\");\nexport const isEmpty = (x) => isNil(x) ||\n    (isString(x) && !x) ||\n    (x instanceof Array && x.length === 0) ||\n    (isObject(x) && Object.keys(x).length === 0);\nexport const isMissing = (v) => v === MISSING;\n/** ensure a value is an array or wrapped within one. */\nexport const ensureArray = (x) => x instanceof Array ? x : [x];\nexport const has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\nconst mergeable = (left, right) => (isObject(left) && isObject(right)) || (isArray(left) && isArray(right));\n/**\n * Deep merge objects or arrays.\n * When the inputs have unmergeable types, the  right hand value is returned.\n * If inputs are arrays and options.flatten is set, elements in the same position are merged together. Remaining elements are appended to the target object.\n * If options.flatten is false, the right hand value is just appended to the left-hand value.\n * @param target {Object|Array} the target to merge into\n * @param obj {Object|Array} the source object\n */\nexport function merge(target, obj, options) {\n    // default options\n    options = options || { flatten: false };\n    // take care of missing inputs\n    if (isMissing(target) || isNil(target))\n        return obj;\n    if (isMissing(obj) || isNil(obj))\n        return target;\n    // fail only on initial input.\n    if (!mergeable(target, obj)) {\n        if (options.skipValidation)\n            return obj || target;\n        throw Error(\"mismatched types. must both be array or object\");\n    }\n    // skip validation after initial input.\n    options.skipValidation = true;\n    if (isArray(target)) {\n        const result = target;\n        const input = obj;\n        if (options.flatten) {\n            let i = 0;\n            let j = 0;\n            while (i < result.length && j < input.length) {\n                result[i] = merge(result[i++], input[j++], options);\n            }\n            while (j < input.length) {\n                result.push(obj[j++]);\n            }\n        }\n        else {\n            into(result, input);\n        }\n    }\n    else {\n        for (const k in obj) {\n            target[k] = merge(target[k], obj[k], options);\n        }\n    }\n    return target;\n}\nfunction buildHashIndex(arr, hashFunction = DEFAULT_HASH_FUNCTION) {\n    const map = new Map();\n    arr.forEach((o, i) => {\n        const h = hashCode(o, hashFunction);\n        if (map.has(h)) {\n            if (!map.get(h).some(j => isEqual(arr[j], o))) {\n                map.get(h).push(i);\n            }\n        }\n        else {\n            map.set(h, [i]);\n        }\n    });\n    return map;\n}\n/**\n * Returns the intersection of multiple arrays.\n *\n * @param  {Array} input An array of arrays from which to find intersection.\n * @param  {Function} hashFunction Custom function to hash values, default the hashCode method\n * @return {Array} Array of intersecting values.\n */\nexport function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n    // if any array is empty, there is no intersection\n    if (input.some(arr => arr.length == 0))\n        return [];\n    if (input.length === 1)\n        return Array.from(input);\n    // sort input arrays by to get smallest array\n    // const sorted = sortBy(input, (a: RawArray) => a.length) as RawArray[];\n    const sortedIndex = sortBy(input.map((a, i) => [i, a.length]), (a) => a[1]);\n    // get the smallest\n    const smallest = input[sortedIndex[0][0]];\n    // get hash index of smallest array\n    const map = buildHashIndex(smallest, hashFunction);\n    // hashIndex for remaining arrays.\n    const rmap = new Map();\n    // final intersection results and index of first occurrence.\n    const results = new Array();\n    map.forEach((v, k) => {\n        const lhs = v.map(j => smallest[j]);\n        const res = lhs.map(_ => 0);\n        // used to track first occurence of value in order of the original input array.\n        const stable = lhs.map(_ => [sortedIndex[0][0], 0]);\n        let found = false;\n        for (let i = 1; i < input.length; i++) {\n            const [currIndex, _] = sortedIndex[i];\n            const arr = input[currIndex];\n            if (!rmap.has(i))\n                rmap.set(i, buildHashIndex(arr));\n            // we found a match. let's confirm.\n            if (rmap.get(i).has(k)) {\n                const rhs = rmap\n                    .get(i)\n                    .get(k)\n                    .map(j => arr[j]);\n                // confirm the intersection with an equivalence check.\n                found = lhs\n                    .map((s, n) => rhs.some((t, m) => {\n                    // we expect only one to match here since these are just collisions.\n                    const p = res[n];\n                    if (isEqual(s, t)) {\n                        res[n]++;\n                        // track position of value ordering for stability.\n                        if (currIndex < stable[n][0]) {\n                            stable[n] = [currIndex, rmap.get(i).get(k)[m]];\n                        }\n                    }\n                    return p < res[n];\n                }))\n                    .some(Boolean);\n            }\n            // found nothing, so exclude value. this was just a hash collision.\n            if (!found)\n                return;\n        }\n        // extract value into result if we found an intersection.\n        // we find an intersection if the frequency counter matches the count of the remaining arrays.\n        if (found) {\n            into(results, res\n                .map((n, i) => {\n                return n === input.length - 1 ? [lhs[i], stable[i]] : MISSING;\n            })\n                .filter(n => n !== MISSING));\n        }\n    });\n    return results\n        .sort((a, b) => {\n        const [_i, [u, m]] = a;\n        const [_j, [v, n]] = b;\n        const r = compare(u, v);\n        if (r !== 0)\n            return r;\n        return compare(m, n);\n    })\n        .map(v => v[0]);\n}\n/**\n * Flatten the array\n *\n * @param {Array} xs The array to flatten\n * @param {Number} depth The number of nested lists to iterate\n */\nexport function flatten(xs, depth = 0) {\n    const arr = new Array();\n    function flatten2(ys, n) {\n        for (let i = 0, len = ys.length; i < len; i++) {\n            if (isArray(ys[i]) && (n > 0 || n < 0)) {\n                flatten2(ys[i], Math.max(-1, n - 1));\n            }\n            else {\n                arr.push(ys[i]);\n            }\n        }\n    }\n    flatten2(xs, depth);\n    return arr;\n}\n/** Returns all members of the value in an object literal. */\nconst getMembersOf = (value) => {\n    let [proto, names] = [\n        Object.getPrototypeOf(value),\n        Object.getOwnPropertyNames(value)\n    ];\n    // save effective prototype\n    let activeProto = proto;\n    // traverse the prototype hierarchy until we get property names or hit the bottom prototype.\n    while (!names.length && proto !== OBJECT_PROTO && proto !== ARRAY_PROTO) {\n        activeProto = proto;\n        names = Object.getOwnPropertyNames(proto);\n        proto = Object.getPrototypeOf(proto);\n    }\n    const o = {};\n    names.forEach(k => (o[k] = value[k]));\n    return [o, activeProto];\n};\n/**\n * Determine whether two values are the same or strictly equivalent.\n * Checking whether values are the same only applies to built in objects.\n * For user-defined objects this checks for only referential equality so\n * two different instances with the same values are not equal.\n *\n * @param  {*}  a The first value\n * @param  {*}  b The second value\n * @return {Boolean}   Result of comparison\n */\nexport function isEqual(a, b) {\n    const args = [[a, b]];\n    while (args.length > 0) {\n        [a, b] = args.pop();\n        // strictly equal must be equal. matches referentially equal values.\n        if (a === b)\n            continue;\n        // unequal types and functions (unless referentially equivalent) cannot be equal.\n        const ctor = getConstructor(a);\n        if (ctor !== getConstructor(b) || isFunction(a))\n            return false;\n        // string convertable types\n        if (STRING_CONVERTERS.has(ctor)) {\n            const str = STRING_CONVERTERS.get(ctor);\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n            if (str(a) !== str(b))\n                return false;\n            // values are equal, so move next\n            continue;\n        }\n        // handle array and object types\n        if (ctor === Array || ctor === Object) {\n            const ka = Object.keys(a);\n            const kb = Object.keys(b);\n            if (ka.length !== kb.length)\n                return false;\n            if (new Set(ka.concat(kb)).size != ka.length)\n                return false;\n            for (const k of ka)\n                args.push([a[k], b[k]]);\n            // move next\n            continue;\n        }\n        // user-defined type detected.\n        // we don't try to compare user-defined types (even though we could...shhhh).\n        return false;\n    }\n    // nothing left to compare\n    return !args.length;\n}\n/**\n * Return a new unique version of the collection\n * @param  {Array} input The input collection\n * @return {Array}\n */\nexport function unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n    const result = input.map(_ => MISSING);\n    buildHashIndex(input, hashFunction).forEach((v, _) => {\n        v.forEach(i => (result[i] = input[i]));\n    });\n    return result.filter(v => v !== MISSING);\n}\n/**\n * Encode value to string using a simple non-colliding stable scheme.\n * Handles user-defined types by processing keys on first non-empty prototype.\n * If a user-defined type provides a \"toJSON\" function, it is used.\n *\n * @param value The value to convert to a string representation.\n * @returns {String}\n */\nexport function stringify(value) {\n    const cycle = new Set();\n    // stringify with cycle check\n    const str = (v) => {\n        const ctor = getConstructor(v);\n        // string convertable types\n        if (STRING_CONVERTERS.has(ctor)) {\n            return STRING_CONVERTERS.get(ctor)(v);\n        }\n        const tag = ctor === Object ? \"\" : ctor.name;\n        // handle JSONable objects.\n        if (isFunction(v[\"toJSON\"])) {\n            return `${tag}(${JSON.stringify(v)})`;\n        }\n        // handle cycles\n        if (cycle.has(v))\n            throw CYCLE_FOUND_ERROR;\n        cycle.add(v);\n        try {\n            // handle array\n            if (ctor === Array) {\n                return \"[\" + v.map(str).join(\",\") + \"]\";\n            }\n            // handle user-defined object\n            if (ctor !== Object) {\n                // handle user-defined types or object literals.\n                const [members, _] = getMembersOf(v);\n                // custom type derived from array.\n                if (isArray(v)) {\n                    // include other members as part of array elements.\n                    return `${tag}${str([...v, members])}`;\n                }\n                // get members as literal\n                v = members;\n            }\n            const objKeys = Object.keys(v);\n            objKeys.sort();\n            return (`${tag}{` +\n                objKeys.map(k => `${k}:${str(v[k])}`).join(\",\") +\n                \"}\");\n        }\n        finally {\n            cycle.delete(v);\n        }\n    };\n    // convert to string\n    return str(value);\n}\n/**\n * Generate hash code\n * This selected function is the result of benchmarking various hash functions.\n * This version performs well and can hash 10^6 documents in ~3s with on average 100 collisions.\n *\n * @param value\n * @returns {number|null}\n */\nexport function hashCode(value, hashFunction) {\n    hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;\n    if (isNil(value))\n        return null;\n    return hashFunction(value).toString();\n}\n/**\n * Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee\n *\n * This implementation treats null/undefined sort keys as less than every other type\n *\n * @param {Array}   collection\n * @param {Function} keyFn The sort key function used to resolve sort keys\n * @param {Function} comparator The comparator function to use for comparing keys. Defaults to standard comparison via `compare(...)`\n * @return {Array} Returns a new sorted array by the given key and comparator function\n */\nexport function sortBy(collection, keyFn, comparator = compare) {\n    if (isEmpty(collection))\n        return collection;\n    const sorted = new Array();\n    const result = new Array();\n    for (let i = 0; i < collection.length; i++) {\n        const obj = collection[i];\n        const key = keyFn(obj, i);\n        if (isNil(key)) {\n            result.push(obj);\n        }\n        else {\n            sorted.push([key, obj]);\n        }\n    }\n    // use native array sorting but enforce stableness\n    sorted.sort((a, b) => comparator(a[0], b[0]));\n    return into(result, sorted.map((o) => o[1]));\n}\n/**\n * Groups the collection into sets by the returned key\n *\n * @param collection\n * @param keyFn {Function} to compute the group key of an item in the collection\n * @returns {GroupByOutput}\n */\nexport function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n    if (collection.length < 1)\n        return new Map();\n    // map of hash to collided values\n    const lookup = new Map();\n    // map of raw key values to objects.\n    const result = new Map();\n    for (let i = 0; i < collection.length; i++) {\n        const obj = collection[i];\n        const key = keyFn(obj, i);\n        const hash = hashCode(key, hashFunction);\n        if (hash === null) {\n            if (result.has(null)) {\n                result.get(null).push(obj);\n            }\n            else {\n                result.set(null, [obj]);\n            }\n        }\n        else {\n            // find if we can match a hash for which the value is equivalent.\n            // this is used to deal with collisions.\n            const existingKey = lookup.has(hash)\n                ? lookup.get(hash).find(k => isEqual(k, key))\n                : null;\n            // collision detected or first time seeing key\n            if (isNil(existingKey)) {\n                // collision detected or first entry so we create a new group.\n                result.set(key, [obj]);\n                // upload the lookup with the collided key\n                if (lookup.has(hash)) {\n                    lookup.get(hash).push(key);\n                }\n                else {\n                    lookup.set(hash, [key]);\n                }\n            }\n            else {\n                // key exists\n                result.get(existingKey).push(obj);\n            }\n        }\n    }\n    return result;\n}\n// max elements to push.\n// See argument limit https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\nconst MAX_ARRAY_PUSH = 50000;\n/**\n * Merge elements into the dest\n *\n * @param {*} target The target object\n * @param {*} rest The array of elements to merge into dest\n */\nexport function into(target, ...rest) {\n    if (target instanceof Array) {\n        return rest.reduce(((acc, arr) => {\n            // push arrary in batches to handle large inputs\n            let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n            let begin = 0;\n            while (i-- > 0) {\n                Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));\n                begin += MAX_ARRAY_PUSH;\n            }\n            return acc;\n        }), target);\n    }\n    else {\n        // merge objects. same behaviour as Object.assign\n        return rest.filter(isObjectLike).reduce((acc, item) => {\n            Object.assign(acc, item);\n            return acc;\n        }, target);\n    }\n}\n/**\n * This is a generic memoization function\n *\n * This implementation uses a cache independent of the function being memoized\n * to allow old values to be garbage collected when the memoized function goes out of scope.\n *\n * @param {*} fn The function object to memoize\n */\nexport function memoize(fn, hashFunction = DEFAULT_HASH_FUNCTION) {\n    return ((memo) => {\n        return (...args) => {\n            const key = hashCode(args, hashFunction) || \"\";\n            if (!has(memo, key)) {\n                memo[key] = fn.apply(this, args);\n            }\n            return memo[key];\n        };\n    })({\n    /* storage */\n    });\n}\n// mingo internal\n/**\n * Retrieve the value of a given key on an object\n * @param obj\n * @param key\n * @returns {*}\n * @private\n */\nfunction getValue(obj, key) {\n    return isObjectLike(obj) ? obj[key] : undefined;\n}\n/**\n * Unwrap a single element array to specified depth\n * @param {Array} arr\n * @param {Number} depth\n */\nfunction unwrap(arr, depth) {\n    if (depth < 1)\n        return arr;\n    while (depth-- && arr.length === 1)\n        arr = arr[0];\n    return arr;\n}\n/**\n * Resolve the value of the field (dot separated) on the given object\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n * @returns {*}\n */\nexport function resolve(obj, selector, options) {\n    let depth = 0;\n    function resolve2(o, path) {\n        let value = o;\n        for (let i = 0; i < path.length; i++) {\n            const field = path[i];\n            const isText = /^\\d+$/.exec(field) === null;\n            // using instanceof to aid typescript compiler\n            if (isText && value instanceof Array) {\n                // On the first iteration, we check if we received a stop flag.\n                // If so, we stop to prevent iterating over a nested array value\n                // on consecutive object keys in the selector.\n                if (i === 0 && depth > 0)\n                    break;\n                depth += 1;\n                // only look at the rest of the path\n                const subpath = path.slice(i);\n                value = value.reduce((acc, item) => {\n                    const v = resolve2(item, subpath);\n                    if (v !== undefined)\n                        acc.push(v);\n                    return acc;\n                }, []);\n                break;\n            }\n            else {\n                value = getValue(value, field);\n            }\n            if (value === undefined)\n                break;\n        }\n        return value;\n    }\n    const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase())\n        ? obj\n        : resolve2(obj, selector.split(\".\"));\n    return result instanceof Array && (options === null || options === void 0 ? void 0 : options.unwrapArray)\n        ? unwrap(result, depth)\n        : result;\n}\n/**\n * Returns the full object to the resolved value given by the selector.\n * This function excludes empty values as they aren't practically useful.\n *\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n */\nexport function resolveGraph(obj, selector, options) {\n    const names = selector.split(\".\");\n    const key = names[0];\n    // get the next part of the selector\n    const next = names.slice(1).join(\".\");\n    const isIndex = /^\\d+$/.exec(key) !== null;\n    const hasNext = names.length > 1;\n    let result;\n    let value;\n    if (obj instanceof Array) {\n        if (isIndex) {\n            result = getValue(obj, Number(key));\n            if (hasNext) {\n                result = resolveGraph(result, next, options);\n            }\n            result = [result];\n        }\n        else {\n            result = [];\n            for (const item of obj) {\n                value = resolveGraph(item, selector, options);\n                if (options === null || options === void 0 ? void 0 : options.preserveMissing) {\n                    if (value === undefined) {\n                        value = MISSING;\n                    }\n                    result.push(value);\n                }\n                else if (value !== undefined) {\n                    result.push(value);\n                }\n            }\n        }\n    }\n    else {\n        value = getValue(obj, key);\n        if (hasNext) {\n            value = resolveGraph(value, next, options);\n        }\n        if (value === undefined)\n            return undefined;\n        result = (options === null || options === void 0 ? void 0 : options.preserveKeys) ? Object.assign({}, obj) : {};\n        result[key] = value;\n    }\n    return result;\n}\n/**\n * Filter out all MISSING values from the object in-place\n *\n * @param obj The object to filter\n */\nexport function filterMissing(obj) {\n    if (obj instanceof Array) {\n        for (let i = obj.length - 1; i >= 0; i--) {\n            if (obj[i] === MISSING) {\n                obj.splice(i, 1);\n            }\n            else {\n                filterMissing(obj[i]);\n            }\n        }\n    }\n    else if (isObject(obj)) {\n        for (const k in obj) {\n            if (has(obj, k)) {\n                filterMissing(obj[k]);\n            }\n        }\n    }\n}\nconst NUMBER_RE = /^\\d+$/;\n/**\n * Walk the object graph and execute the given transform function\n *\n * @param  {Object|Array} obj   The object to traverse.\n * @param  {String} selector    The selector to navigate.\n * @param  {Callback} fn Callback to execute for value at the end the traversal.\n * @param  {WalkOptions} options The opetions to use for the function.\n * @return {*}\n */\nexport function walk(obj, selector, fn, options) {\n    const names = selector.split(\".\");\n    const key = names[0];\n    const next = names.slice(1).join(\".\");\n    if (names.length === 1) {\n        if (isObject(obj) || (isArray(obj) && NUMBER_RE.test(key))) {\n            fn(obj, key);\n        }\n    }\n    else {\n        // force the rest of the graph while traversing\n        if ((options === null || options === void 0 ? void 0 : options.buildGraph) && isNil(obj[key])) {\n            obj[key] = {};\n        }\n        // get the next item\n        const item = obj[key];\n        // nothing more to do\n        if (!item)\n            return;\n        // we peek to see if next key is an array index.\n        const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));\n        // if we have an array value but the next key is not an index and the 'descendArray' option is set,\n        // we walk each item in the array separately. This allows for handling traversing keys for objects\n        // nested within an array.\n        //\n        // Eg: Given { array: [ {k:1}, {k:2}, {k:3} ] }\n        //  - individual objecs can be traversed with \"array.k\"\n        //  - a specific object can be traversed with \"array.1\"\n        if (item instanceof Array && (options === null || options === void 0 ? void 0 : options.descendArray) && !isNextArrayIndex) {\n            item.forEach(((e) => walk(e, next, fn, options)));\n        }\n        else {\n            walk(item, next, fn, options);\n        }\n    }\n}\n/**\n * Set the value of the given object field\n *\n * @param obj {Object|Array} the object context\n * @param selector {String} path to field\n * @param value {*} the value to set. if it is function, it is invoked with the old value and must return the new value.\n */\nexport function setValue(obj, selector, value) {\n    walk(obj, selector, ((item, key) => {\n        item[key] = isFunction(value) ? value(item[key]) : value;\n    }), { buildGraph: true });\n}\n/**\n * Removes an element from the container.\n * If the selector resolves to an array and the leaf is a non-numeric key,\n * the remove operation will be performed on objects of the array.\n *\n * @param obj {ArrayOrObject} object or array\n * @param selector {String} dot separated path to element to remove\n */\nexport function removeValue(obj, selector, options) {\n    walk(obj, selector, ((item, key) => {\n        if (item instanceof Array) {\n            if (/^\\d+$/.test(key)) {\n                item.splice(parseInt(key), 1);\n            }\n            else if (options && options.descendArray) {\n                for (const elem of item) {\n                    if (isObject(elem)) {\n                        delete elem[key];\n                    }\n                }\n            }\n        }\n        else if (isObject(item)) {\n            delete item[key];\n        }\n    }), options);\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\n/**\n * Check whether the given name passes for an operator. We assume AnyVal field name starting with '$' is an operator.\n * This is cheap and safe to do since keys beginning with '$' should be reserved for internal use.\n * @param {String} name\n */\nexport function isOperator(name) {\n    return OPERATOR_NAME_PATTERN.test(name);\n}\n/**\n * Simplify expression for easy evaluation with query operators map\n * @param expr\n * @returns {*}\n */\nexport function normalize(expr) {\n    // normalized primitives\n    if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {\n        return isRegExp(expr) ? { $regex: expr } : { $eq: expr };\n    }\n    // normalize object expression. using ObjectLike handles custom types\n    if (isObjectLike(expr)) {\n        const exprObj = expr;\n        // no valid query operator found, so we do simple comparison\n        if (!Object.keys(exprObj).some(isOperator)) {\n            return { $eq: expr };\n        }\n        // ensure valid regex\n        if (has(expr, \"$regex\")) {\n            const newExpr = Object.assign({}, expr);\n            newExpr[\"$regex\"] = new RegExp(expr[\"$regex\"], expr[\"$options\"]);\n            delete newExpr[\"$options\"];\n            return newExpr;\n        }\n    }\n    return expr;\n}\n/**\n * Find the insert index for the given key in a sorted array.\n *\n * @param {*} sorted The sorted array to search\n * @param {*} item The search key\n */\nexport function findInsertIndex(sorted, item) {\n    // uses binary search\n    let lo = 0;\n    let hi = sorted.length - 1;\n    while (lo <= hi) {\n        const mid = Math.round(lo + (hi - lo) / 2);\n        if (compare(item, sorted[mid]) < 0) {\n            hi = mid - 1;\n        }\n        else if (compare(item, sorted[mid]) > 0) {\n            lo = mid + 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return lo;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}