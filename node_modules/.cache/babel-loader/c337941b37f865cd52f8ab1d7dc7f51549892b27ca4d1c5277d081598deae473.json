{"ast":null,"code":"/**\n * Predicates used for Query and Expression operators.\n */\nimport { computeValue } from \"../core\";\nimport { Query } from \"../query\";\nimport { MingoError } from \"../types\";\nimport { compare as mingoCmp, ensureArray, flatten, getType, inArray, intersection, isArray, isBoolean, isDate, isEmpty, isEqual, isNil, isNumber, isObject, isOperator, isRegExp, isString, MAX_INT, MAX_LONG, MIN_INT, MIN_LONG, resolve, truthy } from \"../util\";\n/**\n * Returns a query operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createQueryOperator(predicate) {\n  const f = (selector, value, options) => {\n    const opts = {\n      unwrapArray: true\n    };\n    const depth = Math.max(1, selector.split(\".\").length - 1);\n    return obj => {\n      // value of field must be fully resolved.\n      const lhs = resolve(obj, selector, opts);\n      return predicate(lhs, value, Object.assign(Object.assign({}, options), {\n        depth\n      }));\n    };\n  };\n  f.op = \"query\";\n  return f; // as QueryOperator;\n}\n/**\n * Returns an expression operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createExpressionOperator(predicate) {\n  return (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    return predicate(...args);\n  };\n}\n/**\n * Checks that two values are equal.\n *\n * @param a         The lhs operand as resolved from the object by the given selector\n * @param b         The rhs operand provided by the user\n * @returns {*}\n */\nexport function $eq(a, b, options) {\n  // start with simple equality check\n  if (isEqual(a, b)) return true;\n  // https://docs.mongodb.com/manual/tutorial/query-for-null-fields/\n  if (isNil(a) && isNil(b)) return true;\n  // check\n  if (a instanceof Array) {\n    const eq = isEqual.bind(null, b);\n    return a.some(eq) || flatten(a, options === null || options === void 0 ? void 0 : options.depth).some(eq);\n  }\n  return false;\n}\n/**\n * Matches all values that are not equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $ne(a, b, options) {\n  return !$eq(a, b, options);\n}\n/**\n * Matches any of the values that exist in an array specified in the query.\n *\n * @param a\n * @param b\n * @returns {*}\n */\nexport function $in(a, b, options) {\n  // queries for null should be able to find undefined fields\n  if (isNil(a)) return b.some(v => v === null);\n  return intersection([ensureArray(a), b], options === null || options === void 0 ? void 0 : options.hashFunction).length > 0;\n}\n/**\n * Matches values that do not exist in an array specified to the query.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $nin(a, b, options) {\n  return !$in(a, b, options);\n}\n/**\n * Matches values that are less than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) < 0);\n}\n/**\n * Matches values that are less than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) <= 0);\n}\n/**\n * Matches values that are greater than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) > 0);\n}\n/**\n * Matches values that are greater than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) >= 0);\n}\n/**\n * Performs a modulo operation on the value of a field and selects documents with a specified result.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $mod(a, b, _options) {\n  return ensureArray(a).some(x => b.length === 2 && x % b[0] === b[1]);\n}\n/**\n * Selects documents where values match a specified regular expression.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $regex(a, b, options) {\n  const lhs = ensureArray(a);\n  const match = x => isString(x) && truthy(b.exec(x), options === null || options === void 0 ? void 0 : options.useStrictMode);\n  return lhs.some(match) || flatten(lhs, 1).some(match);\n}\n/**\n * Matches documents that have the specified field.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $exists(a, b, _options) {\n  return (b === false || b === 0) && a === undefined || (b === true || b === 1) && a !== undefined;\n}\n/**\n * Matches arrays that contain all elements specified in the query.\n *\n * @param values\n * @param queries\n * @returns boolean\n */\nexport function $all(values, queries, options) {\n  if (!isArray(values) || !isArray(queries) || !values.length || !queries.length) {\n    return false;\n  }\n  let matched = true;\n  for (const query of queries) {\n    // no need to check all the queries.\n    if (!matched) break;\n    if (isObject(query) && inArray(Object.keys(query), \"$elemMatch\")) {\n      matched = $elemMatch(values, query[\"$elemMatch\"], options);\n    } else if (query instanceof RegExp) {\n      matched = values.some(s => typeof s === \"string\" && query.test(s));\n    } else {\n      matched = values.some(v => isEqual(query, v));\n    }\n  }\n  return matched;\n}\n/**\n * Selects documents if the array field is a specified size.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $size(a, b, _options) {\n  return Array.isArray(a) && a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n  return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\n/**\n * Selects documents if element in the array field matches all the specified $elemMatch condition.\n *\n * @param a {Array} element to match against\n * @param b {Object} subquery\n */\nexport function $elemMatch(a, b, options) {\n  // should return false for non-matching input\n  if (isArray(a) && !isEmpty(a)) {\n    let format = x => x;\n    let criteria = b;\n    // If we find a boolean operator in the subquery, we fake a field to point to it. This is an\n    // attempt to ensure that it is a valid criteria. We cannot make this substitution for operators\n    // like $and/$or/$nor; as otherwise, this faking will break our query.\n    if (Object.keys(b).every(isNonBooleanOperator)) {\n      criteria = {\n        temp: b\n      };\n      format = x => ({\n        temp: x\n      });\n    }\n    const query = new Query(criteria, options);\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (query.test(format(a[i]))) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n// helper functions\nconst isNull = a => a === null;\nconst isInt = a => isNumber(a) && a >= MIN_INT && a <= MAX_INT && a.toString().indexOf(\".\") === -1;\nconst isLong = a => isNumber(a) && a >= MIN_LONG && a <= MAX_LONG && a.toString().indexOf(\".\") === -1;\n/** Mapping of type to predicate */\nconst compareFuncs = {\n  array: isArray,\n  bool: isBoolean,\n  boolean: isBoolean,\n  date: isDate,\n  decimal: isNumber,\n  double: isNumber,\n  int: isInt,\n  long: isLong,\n  number: isNumber,\n  null: isNull,\n  object: isObject,\n  regex: isRegExp,\n  regexp: isRegExp,\n  string: isString,\n  // added for completeness\n  undefined: isNil,\n  // deprecated\n  function: _ => {\n    throw new MingoError(\"unsupported type key `function`.\");\n  },\n  // Mongo identifiers\n  1: isNumber,\n  //double\n  2: isString,\n  3: isObject,\n  4: isArray,\n  6: isNil,\n  // deprecated\n  8: isBoolean,\n  9: isDate,\n  10: isNull,\n  11: isRegExp,\n  16: isInt,\n  18: isLong,\n  19: isNumber //decimal\n};\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction compareType(a, b, _) {\n  const f = compareFuncs[b];\n  return f ? f(a) : false;\n}\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $type(a, b, options) {\n  return Array.isArray(b) ? b.findIndex(t => compareType(a, t, options)) >= 0 : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n  return ensureArray(a).some(x => getType(x) === getType(b) && f(x, b));\n}","map":{"version":3,"names":["computeValue","Query","MingoError","compare","mingoCmp","ensureArray","flatten","getType","inArray","intersection","isArray","isBoolean","isDate","isEmpty","isEqual","isNil","isNumber","isObject","isOperator","isRegExp","isString","MAX_INT","MAX_LONG","MIN_INT","MIN_LONG","resolve","truthy","createQueryOperator","predicate","f","selector","value","options","opts","unwrapArray","depth","Math","max","split","length","obj","lhs","Object","assign","op","createExpressionOperator","expr","args","$eq","a","b","Array","eq","bind","some","$ne","$in","v","hashFunction","$nin","$lt","_options","x","y","$lte","$gt","$gte","$mod","$regex","match","exec","useStrictMode","$exists","undefined","$all","values","queries","matched","query","keys","$elemMatch","RegExp","s","test","$size","isNonBooleanOperator","name","indexOf","format","criteria","every","temp","i","len","isNull","isInt","toString","isLong","compareFuncs","array","bool","boolean","date","decimal","double","int","long","number","null","object","regex","regexp","string","function","_","compareType","$type","findIndex","t"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/operators/_predicates.js"],"sourcesContent":["/**\n * Predicates used for Query and Expression operators.\n */\nimport { computeValue } from \"../core\";\nimport { Query } from \"../query\";\nimport { MingoError } from \"../types\";\nimport { compare as mingoCmp, ensureArray, flatten, getType, inArray, intersection, isArray, isBoolean, isDate, isEmpty, isEqual, isNil, isNumber, isObject, isOperator, isRegExp, isString, MAX_INT, MAX_LONG, MIN_INT, MIN_LONG, resolve, truthy } from \"../util\";\n/**\n * Returns a query operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createQueryOperator(predicate) {\n    const f = (selector, value, options) => {\n        const opts = { unwrapArray: true };\n        const depth = Math.max(1, selector.split(\".\").length - 1);\n        return (obj) => {\n            // value of field must be fully resolved.\n            const lhs = resolve(obj, selector, opts);\n            return predicate(lhs, value, Object.assign(Object.assign({}, options), { depth }));\n        };\n    };\n    f.op = \"query\";\n    return f; // as QueryOperator;\n}\n/**\n * Returns an expression operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createExpressionOperator(predicate) {\n    return (obj, expr, options) => {\n        const args = computeValue(obj, expr, null, options);\n        return predicate(...args);\n    };\n}\n/**\n * Checks that two values are equal.\n *\n * @param a         The lhs operand as resolved from the object by the given selector\n * @param b         The rhs operand provided by the user\n * @returns {*}\n */\nexport function $eq(a, b, options) {\n    // start with simple equality check\n    if (isEqual(a, b))\n        return true;\n    // https://docs.mongodb.com/manual/tutorial/query-for-null-fields/\n    if (isNil(a) && isNil(b))\n        return true;\n    // check\n    if (a instanceof Array) {\n        const eq = isEqual.bind(null, b);\n        return a.some(eq) || flatten(a, options === null || options === void 0 ? void 0 : options.depth).some(eq);\n    }\n    return false;\n}\n/**\n * Matches all values that are not equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $ne(a, b, options) {\n    return !$eq(a, b, options);\n}\n/**\n * Matches any of the values that exist in an array specified in the query.\n *\n * @param a\n * @param b\n * @returns {*}\n */\nexport function $in(a, b, options) {\n    // queries for null should be able to find undefined fields\n    if (isNil(a))\n        return b.some(v => v === null);\n    return intersection([ensureArray(a), b], options === null || options === void 0 ? void 0 : options.hashFunction).length > 0;\n}\n/**\n * Matches values that do not exist in an array specified to the query.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $nin(a, b, options) {\n    return !$in(a, b, options);\n}\n/**\n * Matches values that are less than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lt(a, b, _options) {\n    return compare(a, b, (x, y) => mingoCmp(x, y) < 0);\n}\n/**\n * Matches values that are less than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lte(a, b, _options) {\n    return compare(a, b, (x, y) => mingoCmp(x, y) <= 0);\n}\n/**\n * Matches values that are greater than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gt(a, b, _options) {\n    return compare(a, b, (x, y) => mingoCmp(x, y) > 0);\n}\n/**\n * Matches values that are greater than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gte(a, b, _options) {\n    return compare(a, b, (x, y) => mingoCmp(x, y) >= 0);\n}\n/**\n * Performs a modulo operation on the value of a field and selects documents with a specified result.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $mod(a, b, _options) {\n    return ensureArray(a).some(((x) => b.length === 2 && x % b[0] === b[1]));\n}\n/**\n * Selects documents where values match a specified regular expression.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $regex(a, b, options) {\n    const lhs = ensureArray(a);\n    const match = (x) => isString(x) && truthy(b.exec(x), options === null || options === void 0 ? void 0 : options.useStrictMode);\n    return lhs.some(match) || flatten(lhs, 1).some(match);\n}\n/**\n * Matches documents that have the specified field.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $exists(a, b, _options) {\n    return (((b === false || b === 0) && a === undefined) ||\n        ((b === true || b === 1) && a !== undefined));\n}\n/**\n * Matches arrays that contain all elements specified in the query.\n *\n * @param values\n * @param queries\n * @returns boolean\n */\nexport function $all(values, queries, options) {\n    if (!isArray(values) ||\n        !isArray(queries) ||\n        !values.length ||\n        !queries.length) {\n        return false;\n    }\n    let matched = true;\n    for (const query of queries) {\n        // no need to check all the queries.\n        if (!matched)\n            break;\n        if (isObject(query) && inArray(Object.keys(query), \"$elemMatch\")) {\n            matched = $elemMatch(values, query[\"$elemMatch\"], options);\n        }\n        else if (query instanceof RegExp) {\n            matched = values.some(s => typeof s === \"string\" && query.test(s));\n        }\n        else {\n            matched = values.some(v => isEqual(query, v));\n        }\n    }\n    return matched;\n}\n/**\n * Selects documents if the array field is a specified size.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $size(a, b, _options) {\n    return Array.isArray(a) && a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n    return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\n/**\n * Selects documents if element in the array field matches all the specified $elemMatch condition.\n *\n * @param a {Array} element to match against\n * @param b {Object} subquery\n */\nexport function $elemMatch(a, b, options) {\n    // should return false for non-matching input\n    if (isArray(a) && !isEmpty(a)) {\n        let format = (x) => x;\n        let criteria = b;\n        // If we find a boolean operator in the subquery, we fake a field to point to it. This is an\n        // attempt to ensure that it is a valid criteria. We cannot make this substitution for operators\n        // like $and/$or/$nor; as otherwise, this faking will break our query.\n        if (Object.keys(b).every(isNonBooleanOperator)) {\n            criteria = { temp: b };\n            format = x => ({ temp: x });\n        }\n        const query = new Query(criteria, options);\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (query.test(format(a[i]))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// helper functions\nconst isNull = (a) => a === null;\nconst isInt = (a) => isNumber(a) &&\n    a >= MIN_INT &&\n    a <= MAX_INT &&\n    a.toString().indexOf(\".\") === -1;\nconst isLong = (a) => isNumber(a) &&\n    a >= MIN_LONG &&\n    a <= MAX_LONG &&\n    a.toString().indexOf(\".\") === -1;\n/** Mapping of type to predicate */\nconst compareFuncs = {\n    array: isArray,\n    bool: isBoolean,\n    boolean: isBoolean,\n    date: isDate,\n    decimal: isNumber,\n    double: isNumber,\n    int: isInt,\n    long: isLong,\n    number: isNumber,\n    null: isNull,\n    object: isObject,\n    regex: isRegExp,\n    regexp: isRegExp,\n    string: isString,\n    // added for completeness\n    undefined: isNil, // deprecated\n    function: (_) => {\n        throw new MingoError(\"unsupported type key `function`.\");\n    },\n    // Mongo identifiers\n    1: isNumber, //double\n    2: isString,\n    3: isObject,\n    4: isArray,\n    6: isNil, // deprecated\n    8: isBoolean,\n    9: isDate,\n    10: isNull,\n    11: isRegExp,\n    16: isInt,\n    18: isLong,\n    19: isNumber //decimal\n};\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction compareType(a, b, _) {\n    const f = compareFuncs[b];\n    return f ? f(a) : false;\n}\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $type(a, b, options) {\n    return Array.isArray(b)\n        ? b.findIndex(t => compareType(a, t, options)) >= 0\n        : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n    return ensureArray(a).some(x => getType(x) === getType(b) && f(x, b));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}