{"ast":null,"code":"import { pushAtSortPosition } from 'array-push-at-sort-position';\nexport const doNothing = _input => {};\nexport const insertFirst = input => {\n  input.previousResults.unshift(input.changeEvent.doc);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n  }\n};\nexport const insertLast = input => {\n  input.previousResults.push(input.changeEvent.doc);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n  }\n};\nexport const removeFirstItem = input => {\n  const first = input.previousResults.shift();\n  if (input.keyDocumentMap && first) {\n    input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);\n  }\n};\nexport const removeLastItem = input => {\n  const last = input.previousResults.pop();\n  if (input.keyDocumentMap && last) {\n    input.keyDocumentMap.delete(last[input.queryParams.primaryKey]);\n  }\n};\nexport const removeFirstInsertLast = input => {\n  removeFirstItem(input);\n  insertLast(input);\n};\nexport const removeLastInsertFirst = input => {\n  removeLastItem(input);\n  insertFirst(input);\n};\nexport const removeFirstInsertFirst = input => {\n  removeFirstItem(input);\n  insertFirst(input);\n};\nexport const removeLastInsertLast = input => {\n  removeLastItem(input);\n  insertLast(input);\n};\nexport const removeExisting = input => {\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.delete(input.changeEvent.id);\n  }\n  // find index of document\n  const primary = input.queryParams.primaryKey;\n  const results = input.previousResults;\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i];\n    // remove\n    if (item[primary] === input.changeEvent.id) {\n      results.splice(i, 1);\n      break;\n    }\n  }\n};\nexport const replaceExisting = input => {\n  // find index of document\n  const doc = input.changeEvent.doc;\n  const primary = input.queryParams.primaryKey;\n  const results = input.previousResults;\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i];\n    // replace\n    if (item[primary] === input.changeEvent.id) {\n      results[i] = doc;\n      if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, doc);\n      }\n      break;\n    }\n  }\n};\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong = input => {\n  const wrongHuman = {\n    _id: 'wrongHuman' + new Date().getTime()\n  };\n  input.previousResults.length = 0; // clear array\n  input.previousResults.push(wrongHuman);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.clear();\n    input.keyDocumentMap.set(wrongHuman._id, wrongHuman);\n  }\n};\nexport const insertAtSortPosition = input => {\n  const docId = input.changeEvent.id;\n  const doc = input.changeEvent.doc;\n  if (input.keyDocumentMap) {\n    if (input.keyDocumentMap.has(docId)) {\n      /**\n       * If document is already in results,\n       * we cannot add it again because it would throw on non-deterministic ordering.\n       */\n      return;\n    }\n    input.keyDocumentMap.set(docId, doc);\n  } else {\n    const isDocInResults = input.previousResults.find(d => d[input.queryParams.primaryKey] === docId);\n    /**\n     * If document is already in results,\n     * we cannot add it again because it would throw on non-deterministic ordering.\n     */\n    if (isDocInResults) {\n      return;\n    }\n  }\n  pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, 0);\n};\nexport const removeExistingAndInsertAtSortPosition = input => {\n  removeExisting(input);\n  insertAtSortPosition(input);\n};\nexport const runFullQueryAgain = _input => {\n  throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\nexport const unknownAction = _input => {\n  throw new Error('Action unknownAction should never be called');\n};","map":{"version":3,"names":["pushAtSortPosition","doNothing","_input","insertFirst","input","previousResults","unshift","changeEvent","doc","keyDocumentMap","set","id","insertLast","push","removeFirstItem","first","shift","delete","queryParams","primaryKey","removeLastItem","last","pop","removeFirstInsertLast","removeLastInsertFirst","removeFirstInsertFirst","removeLastInsertLast","removeExisting","primary","results","i","length","item","splice","replaceExisting","alwaysWrong","wrongHuman","_id","Date","getTime","clear","insertAtSortPosition","docId","has","isDocInResults","find","d","sortComparator","removeExistingAndInsertAtSortPosition","runFullQueryAgain","Error","unknownAction"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/event-reduce-js/src/actions/action-functions.ts"],"sourcesContent":["import {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\n\nimport type { ActionFunction } from '../types/index.js';\n\nexport const doNothing: ActionFunction<any> = (_input) => { };\n\nexport const insertFirst: ActionFunction<any> = (input) => {\n    input.previousResults.unshift(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(\n            input.changeEvent.id,\n            input.changeEvent.doc\n        );\n    }\n};\nexport const insertLast: ActionFunction<any> = (input) => {\n    input.previousResults.push(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(\n            input.changeEvent.id,\n            input.changeEvent.doc\n        );\n    }\n};\nexport const removeFirstItem: ActionFunction<any> = (input) => {\n    const first = input.previousResults.shift();\n    if (input.keyDocumentMap && first) {\n        input.keyDocumentMap.delete(\n            first[input.queryParams.primaryKey]\n        );\n    }\n};\n\nexport const removeLastItem: ActionFunction<any> = (input) => {\n    const last = input.previousResults.pop();\n    if (input.keyDocumentMap && last) {\n        input.keyDocumentMap.delete(\n            last[input.queryParams.primaryKey]\n        );\n    }\n};\n\nexport const removeFirstInsertLast: ActionFunction<any> = (input) => {\n    removeFirstItem(input);\n    insertLast(input);\n};\n\nexport const removeLastInsertFirst: ActionFunction<any> = (input) => {\n    removeLastItem(input);\n    insertFirst(input);\n};\n\nexport const removeFirstInsertFirst: ActionFunction<any> = (input) => {\n    removeFirstItem(input);\n    insertFirst(input);\n};\n\nexport const removeLastInsertLast: ActionFunction<any> = (input) => {\n    removeLastItem(input);\n    insertLast(input);\n};\n\nexport const removeExisting: ActionFunction<any> = (input) => {\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.delete(\n            input.changeEvent.id\n        );\n    }\n\n    // find index of document\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // remove\n        if (item[primary] === input.changeEvent.id) {\n            results.splice(i, 1);\n            break;\n        }\n    }\n};\n\nexport const replaceExisting: ActionFunction<any> = (input) => {\n    // find index of document\n    const doc = input.changeEvent.doc;\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // replace\n        if (item[primary] === input.changeEvent.id) {\n            results[i] = doc;\n            if (input.keyDocumentMap) {\n                input.keyDocumentMap.set(\n                    input.changeEvent.id,\n                    doc\n                );\n            }\n            break;\n        }\n    }\n};\n\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong: ActionFunction<any> = (input) => {\n    const wrongHuman = {\n        _id: 'wrongHuman' + new Date().getTime()\n    };\n    input.previousResults.length = 0; // clear array\n    input.previousResults.push(wrongHuman);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.clear();\n        input.keyDocumentMap.set(\n            wrongHuman._id,\n            wrongHuman\n        );\n    }\n};\n\nexport const insertAtSortPosition: ActionFunction<any> = (input) => {\n    const docId = input.changeEvent.id;\n    const doc = input.changeEvent.doc;\n    if (input.keyDocumentMap) {\n\n        if (input.keyDocumentMap.has(docId)) {\n            /**\n             * If document is already in results,\n             * we cannot add it again because it would throw on non-deterministic ordering.\n             */\n            return;\n        }\n\n        input.keyDocumentMap.set(\n            docId,\n            doc\n        );\n    } else {\n        const isDocInResults = input.previousResults.find((d: any) => d[input.queryParams.primaryKey] === docId);\n        /**\n         * If document is already in results,\n         * we cannot add it again because it would throw on non-deterministic ordering.\n         */\n        if (isDocInResults) {\n            return;\n        }\n    }\n\n    pushAtSortPosition(\n        input.previousResults,\n        doc,\n        input.queryParams.sortComparator,\n        0\n    );\n};\n\nexport const removeExistingAndInsertAtSortPosition: ActionFunction<any> = (input) => {\n    removeExisting(input);\n    insertAtSortPosition(input);\n};\n\nexport const runFullQueryAgain: ActionFunction<any> = (_input) => {\n    throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\n\nexport const unknownAction: ActionFunction<any> = (_input) => {\n    throw new Error('Action unknownAction should never be called');\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}