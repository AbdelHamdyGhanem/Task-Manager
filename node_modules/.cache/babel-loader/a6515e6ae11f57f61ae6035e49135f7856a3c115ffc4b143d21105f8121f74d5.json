{"ast":null,"code":"import { hasLimit, isFindOne, hasSkip, wasResultsEmpty, isDelete, isInsert, isUpdate, wasLimitReached, sortParamsChanged, wasInResult, wasFirst, wasLast, wasSortedBeforeFirst, wasSortedAfterLast, isSortedBeforeFirst, isSortedAfterLast, wasMatching, doesMatchNow } from './state-resolver.js';\nexport * from './state-resolver.js';\n/**\n * all states ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedStateList = ['isInsert', 'isUpdate', 'isDelete', 'hasLimit', 'isFindOne', 'hasSkip', 'wasResultsEmpty', 'wasLimitReached', 'wasFirst', 'wasLast', 'sortParamsChanged', 'wasInResult', 'wasSortedBeforeFirst', 'wasSortedAfterLast', 'isSortedBeforeFirst', 'isSortedAfterLast', 'wasMatching', 'doesMatchNow'];\nexport const stateResolveFunctions = {\n  isInsert,\n  isUpdate,\n  isDelete,\n  hasLimit,\n  isFindOne,\n  hasSkip,\n  wasResultsEmpty,\n  wasLimitReached,\n  wasFirst,\n  wasLast,\n  sortParamsChanged,\n  wasInResult,\n  wasSortedBeforeFirst,\n  wasSortedAfterLast,\n  isSortedBeforeFirst,\n  isSortedAfterLast,\n  wasMatching,\n  doesMatchNow\n};\nexport const stateResolveFunctionByIndex = {\n  0: isInsert,\n  1: isUpdate,\n  2: isDelete,\n  3: hasLimit,\n  4: isFindOne,\n  5: hasSkip,\n  6: wasResultsEmpty,\n  7: wasLimitReached,\n  8: wasFirst,\n  9: wasLast,\n  10: sortParamsChanged,\n  11: wasInResult,\n  12: wasSortedBeforeFirst,\n  13: wasSortedAfterLast,\n  14: isSortedBeforeFirst,\n  15: isSortedAfterLast,\n  16: wasMatching,\n  17: doesMatchNow\n};\nexport function resolveState(stateName, input) {\n  const fn = stateResolveFunctions[stateName];\n  if (!fn) {\n    throw new Error('resolveState() has no function for ' + stateName);\n  }\n  return fn(input);\n}\nexport function getStateSet(input) {\n  let set = '';\n  for (let i = 0; i < orderedStateList.length; i++) {\n    const name = orderedStateList[i];\n    const value = resolveState(name, input);\n    const add = value ? '1' : '0';\n    set += add;\n  }\n  return set;\n}\nexport function logStateSet(stateSet) {\n  orderedStateList.forEach((state, index) => {\n    console.log('state: ' + state + ' : ' + stateSet[index]);\n  });\n}","map":{"version":3,"names":["hasLimit","isFindOne","hasSkip","wasResultsEmpty","isDelete","isInsert","isUpdate","wasLimitReached","sortParamsChanged","wasInResult","wasFirst","wasLast","wasSortedBeforeFirst","wasSortedAfterLast","isSortedBeforeFirst","isSortedAfterLast","wasMatching","doesMatchNow","orderedStateList","stateResolveFunctions","stateResolveFunctionByIndex","resolveState","stateName","input","fn","Error","getStateSet","set","i","length","name","value","add","logStateSet","stateSet","forEach","state","index","console","log"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/event-reduce-js/src/states/index.ts"],"sourcesContent":["import { ResolverFunctions } from 'binary-decision-diagram';\n\nimport type {\n    StateName,\n    StateResolveFunction,\n    StateSet,\n    StateResolveFunctionInput\n} from '../types/index.js';\n\nimport {\n    hasLimit,\n    isFindOne,\n    hasSkip,\n    wasResultsEmpty,\n    isDelete,\n    isInsert,\n    isUpdate,\n    wasLimitReached,\n    sortParamsChanged,\n    wasInResult,\n    wasFirst,\n    wasLast,\n    wasSortedBeforeFirst,\n    wasSortedAfterLast,\n    isSortedBeforeFirst,\n    isSortedAfterLast,\n    wasMatching,\n    doesMatchNow\n} from './state-resolver.js';\n\nexport * from './state-resolver.js';\n\n/**\n * all states ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedStateList: StateName[] = [\n    'isInsert',\n    'isUpdate',\n    'isDelete',\n    'hasLimit',\n    'isFindOne',\n    'hasSkip',\n    'wasResultsEmpty',\n    'wasLimitReached',\n    'wasFirst',\n    'wasLast',\n    'sortParamsChanged',\n    'wasInResult',\n    'wasSortedBeforeFirst',\n    'wasSortedAfterLast',\n    'isSortedBeforeFirst',\n    'isSortedAfterLast',\n    'wasMatching',\n    'doesMatchNow'\n];\n\nexport const stateResolveFunctions: {\n    readonly [k in StateName]: StateResolveFunction<any>\n} = {\n    isInsert,\n    isUpdate,\n    isDelete,\n    hasLimit,\n    isFindOne,\n    hasSkip,\n    wasResultsEmpty,\n    wasLimitReached,\n    wasFirst,\n    wasLast,\n    sortParamsChanged,\n    wasInResult,\n    wasSortedBeforeFirst,\n    wasSortedAfterLast,\n    isSortedBeforeFirst,\n    isSortedAfterLast,\n    wasMatching,\n    doesMatchNow\n};\n\nexport const stateResolveFunctionByIndex: ResolverFunctions<\n    StateResolveFunctionInput<any>\n> = {\n    0: isInsert,\n    1: isUpdate,\n    2: isDelete,\n    3: hasLimit,\n    4: isFindOne,\n    5: hasSkip,\n    6: wasResultsEmpty,\n    7: wasLimitReached,\n    8: wasFirst,\n    9: wasLast,\n    10: sortParamsChanged,\n    11: wasInResult,\n    12: wasSortedBeforeFirst,\n    13: wasSortedAfterLast,\n    14: isSortedBeforeFirst,\n    15: isSortedAfterLast,\n    16: wasMatching,\n    17: doesMatchNow\n};\n\nexport function resolveState<DocType>(\n    stateName: StateName,\n    input: StateResolveFunctionInput<DocType>\n): boolean {\n    const fn: StateResolveFunction<DocType> = stateResolveFunctions[stateName];\n    if (!fn) {\n        throw new Error('resolveState() has no function for ' + stateName);\n    }\n    return fn(input);\n}\n\nexport function getStateSet<DocType>(\n    input: StateResolveFunctionInput<DocType>\n): StateSet {\n    let set: StateSet = '';\n    for (let i = 0; i < orderedStateList.length; i++) {\n        const name: StateName = orderedStateList[i];\n        const value = resolveState(name, input);\n        const add = value ? '1' : '0';\n        set += add;\n    }\n    return set;\n}\n\nexport function logStateSet(stateSet: StateSet) {\n    orderedStateList.forEach((state, index) => {\n        console.log('state: ' + state + ' : ' + stateSet[index]);\n    });\n}\n"],"mappings":"AASA,SACIA,QAAQ,EACRC,SAAS,EACTC,OAAO,EACPC,eAAe,EACfC,QAAQ,EACRC,QAAQ,EACRC,QAAQ,EACRC,eAAe,EACfC,iBAAiB,EACjBC,WAAW,EACXC,QAAQ,EACRC,OAAO,EACPC,oBAAoB,EACpBC,kBAAkB,EAClBC,mBAAmB,EACnBC,iBAAiB,EACjBC,WAAW,EACXC,YAAY,QACT,qBAAqB;AAE5B,cAAc,qBAAqB;AAEnC;;;;;AAKA,OAAO,MAAMC,gBAAgB,GAAgB,CACzC,UAAU,EACV,UAAU,EACV,UAAU,EACV,UAAU,EACV,WAAW,EACX,SAAS,EACT,iBAAiB,EACjB,iBAAiB,EACjB,UAAU,EACV,SAAS,EACT,mBAAmB,EACnB,aAAa,EACb,sBAAsB,EACtB,oBAAoB,EACpB,qBAAqB,EACrB,mBAAmB,EACnB,aAAa,EACb,cAAc,CACjB;AAED,OAAO,MAAMC,qBAAqB,GAE9B;EACAd,QAAQ;EACRC,QAAQ;EACRF,QAAQ;EACRJ,QAAQ;EACRC,SAAS;EACTC,OAAO;EACPC,eAAe;EACfI,eAAe;EACfG,QAAQ;EACRC,OAAO;EACPH,iBAAiB;EACjBC,WAAW;EACXG,oBAAoB;EACpBC,kBAAkB;EAClBC,mBAAmB;EACnBC,iBAAiB;EACjBC,WAAW;EACXC;CACH;AAED,OAAO,MAAMG,2BAA2B,GAEpC;EACA,CAAC,EAAEf,QAAQ;EACX,CAAC,EAAEC,QAAQ;EACX,CAAC,EAAEF,QAAQ;EACX,CAAC,EAAEJ,QAAQ;EACX,CAAC,EAAEC,SAAS;EACZ,CAAC,EAAEC,OAAO;EACV,CAAC,EAAEC,eAAe;EAClB,CAAC,EAAEI,eAAe;EAClB,CAAC,EAAEG,QAAQ;EACX,CAAC,EAAEC,OAAO;EACV,EAAE,EAAEH,iBAAiB;EACrB,EAAE,EAAEC,WAAW;EACf,EAAE,EAAEG,oBAAoB;EACxB,EAAE,EAAEC,kBAAkB;EACtB,EAAE,EAAEC,mBAAmB;EACvB,EAAE,EAAEC,iBAAiB;EACrB,EAAE,EAAEC,WAAW;EACf,EAAE,EAAEC;CACP;AAED,OAAM,SAAUI,YAAYA,CACxBC,SAAoB,EACpBC,KAAyC;EAEzC,MAAMC,EAAE,GAAkCL,qBAAqB,CAACG,SAAS,CAAC;EAC1E,IAAI,CAACE,EAAE,EAAE;IACL,MAAM,IAAIC,KAAK,CAAC,qCAAqC,GAAGH,SAAS,CAAC;;EAEtE,OAAOE,EAAE,CAACD,KAAK,CAAC;AACpB;AAEA,OAAM,SAAUG,WAAWA,CACvBH,KAAyC;EAEzC,IAAII,GAAG,GAAa,EAAE;EACtB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,gBAAgB,CAACW,MAAM,EAAED,CAAC,EAAE,EAAE;IAC9C,MAAME,IAAI,GAAcZ,gBAAgB,CAACU,CAAC,CAAC;IAC3C,MAAMG,KAAK,GAAGV,YAAY,CAACS,IAAI,EAAEP,KAAK,CAAC;IACvC,MAAMS,GAAG,GAAGD,KAAK,GAAG,GAAG,GAAG,GAAG;IAC7BJ,GAAG,IAAIK,GAAG;;EAEd,OAAOL,GAAG;AACd;AAEA,OAAM,SAAUM,WAAWA,CAACC,QAAkB;EAC1ChB,gBAAgB,CAACiB,OAAO,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAI;IACtCC,OAAO,CAACC,GAAG,CAAC,SAAS,GAAGH,KAAK,GAAG,KAAK,GAAGF,QAAQ,CAACG,KAAK,CAAC,CAAC;EAC5D,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}