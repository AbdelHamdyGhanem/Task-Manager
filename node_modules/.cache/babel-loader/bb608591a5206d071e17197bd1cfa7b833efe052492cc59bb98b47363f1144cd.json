{"ast":null,"code":"import { MingoError } from \"./types\";\nimport { assert, has, isArray, isFunction, isNil, isObject, isObjectLike, isOperator, isString, resolve } from \"./util\";\n/**\n * This controls how input and output documents are processed to meet different application needs.\n * Each mode has different trade offs for; immutability, reference sharing, and performance.\n */\nexport var ProcessingMode;\n(function (ProcessingMode) {\n  /**\n   * Clone inputs prior to processing, and the outputs if some objects graphs may be shared.\n   * Use this option to keep input collection immutable and to get distinct output objects.\n   *\n   * Note: This option is expensive and reduces performance.\n   */\n  ProcessingMode[\"CLONE_ALL\"] = \"CLONE_ALL\";\n  /**\n   * Clones inputs prior to processing.\n   * This option will return output objects with shared graphs in their path if specific operators are used.\n   * Use this option to keep the input collection immutable.\n   *\n   */\n  ProcessingMode[\"CLONE_INPUT\"] = \"CLONE_INPUT\";\n  /**\n   * Clones the output to return distinct objects with no shared paths.\n   * This option modifies the input collection and during processing.\n   */\n  ProcessingMode[\"CLONE_OUTPUT\"] = \"CLONE_OUTPUT\";\n  /**\n   * Turn off cloning and modifies the input collection as needed.\n   * This option will also return output objects with shared paths in their graph when specific operators are used.\n   * This option provides the greatest speedup for the biggest tradeoff.\n   * When using the aggregation pipeline, you can use the \"$out\" operator to collect immutable intermediate results.\n   *\n   * @default\n   */\n  ProcessingMode[\"CLONE_OFF\"] = \"CLONE_OFF\";\n})(ProcessingMode || (ProcessingMode = {}));\n/** Custom type to facilitate type checking for global options */\nexport class ComputeOptions {\n  constructor(_opts, /** Reference to the root object when processing subgraphs of the object. */\n  _root, _local, /** The current time in milliseconds. Remains the same throughout all stages of the aggregation pipeline. */\n  timestamp = Date.now()) {\n    this._opts = _opts;\n    this._root = _root;\n    this._local = _local;\n    this.timestamp = timestamp;\n    this.update(_root, _local);\n  }\n  /**\n   * Initialize new ComputeOptions.\n   *\n   * @param options\n   * @param root\n   * @param local\n   * @returns {ComputeOptions}\n   */\n  static init(options, root, local) {\n    return options instanceof ComputeOptions ? new ComputeOptions(options._opts, isNil(options.root) ? root : options.root, Object.assign({}, options.local, local)) : new ComputeOptions(options, root, local);\n  }\n  /** Updates the internal mutable state. */\n  update(root, local) {\n    var _a;\n    // NOTE: this is done for efficiency to avoid creating too many intermediate options objects.\n    this._root = root;\n    this._local = local ? Object.assign({}, local, {\n      variables: Object.assign({}, (_a = this._local) === null || _a === void 0 ? void 0 : _a.variables, local === null || local === void 0 ? void 0 : local.variables)\n    }) : local;\n    return this;\n  }\n  getOptions() {\n    return Object.freeze(Object.assign(Object.assign({}, this._opts), {\n      context: Context.from(this._opts.context)\n    }));\n  }\n  get root() {\n    return this._root;\n  }\n  get local() {\n    return this._local;\n  }\n  get idKey() {\n    return this._opts.idKey;\n  }\n  get collation() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collation;\n  }\n  get processingMode() {\n    var _a;\n    return ((_a = this._opts) === null || _a === void 0 ? void 0 : _a.processingMode) || ProcessingMode.CLONE_OFF;\n  }\n  get useStrictMode() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useStrictMode;\n  }\n  get scriptEnabled() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.scriptEnabled;\n  }\n  get useGlobalContext() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useGlobalContext;\n  }\n  get hashFunction() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.hashFunction;\n  }\n  get collectionResolver() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collectionResolver;\n  }\n  get jsonSchemaValidator() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.jsonSchemaValidator;\n  }\n  get variables() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.variables;\n  }\n  get context() {\n    var _a;\n    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.context;\n  }\n}\n/**\n * Creates an Option from another where required keys are initialized.\n * @param options Options\n */\nexport function initOptions(options) {\n  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze(Object.assign(Object.assign({\n    idKey: \"_id\",\n    scriptEnabled: true,\n    useStrictMode: true,\n    useGlobalContext: true,\n    processingMode: ProcessingMode.CLONE_OFF\n  }, options), {\n    context: (options === null || options === void 0 ? void 0 : options.context) ? Context.from(options === null || options === void 0 ? void 0 : options.context) : Context.init({})\n  }));\n}\n/**\n * The different groups of operators\n */\nexport var OperatorType;\n(function (OperatorType) {\n  OperatorType[\"ACCUMULATOR\"] = \"accumulator\";\n  OperatorType[\"EXPRESSION\"] = \"expression\";\n  OperatorType[\"PIPELINE\"] = \"pipeline\";\n  OperatorType[\"PROJECTION\"] = \"projection\";\n  OperatorType[\"QUERY\"] = \"query\";\n  OperatorType[\"WINDOW\"] = \"window\";\n})(OperatorType || (OperatorType = {}));\nexport class Context {\n  constructor(ops) {\n    this.operators = {\n      [OperatorType.ACCUMULATOR]: {},\n      [OperatorType.EXPRESSION]: {},\n      [OperatorType.PIPELINE]: {},\n      [OperatorType.PROJECTION]: {},\n      [OperatorType.QUERY]: {},\n      [OperatorType.WINDOW]: {}\n    };\n    for (const [type, operators] of Object.entries(ops)) {\n      this.addOperators(type, operators);\n    }\n  }\n  static init(ops = {}) {\n    return new Context(ops);\n  }\n  static from(ctx) {\n    return new Context(ctx.operators);\n  }\n  addOperators(type, ops) {\n    for (const [name, fn] of Object.entries(ops)) {\n      if (!this.getOperator(type, name)) {\n        this.operators[type][name] = fn;\n      }\n    }\n    return this;\n  }\n  // register\n  addAccumulatorOps(ops) {\n    return this.addOperators(OperatorType.ACCUMULATOR, ops);\n  }\n  addExpressionOps(ops) {\n    return this.addOperators(OperatorType.EXPRESSION, ops);\n  }\n  addQueryOps(ops) {\n    return this.addOperators(OperatorType.QUERY, ops);\n  }\n  addPipelineOps(ops) {\n    return this.addOperators(OperatorType.PIPELINE, ops);\n  }\n  addProjectionOps(ops) {\n    return this.addOperators(OperatorType.PROJECTION, ops);\n  }\n  addWindowOps(ops) {\n    return this.addOperators(OperatorType.WINDOW, ops);\n  }\n  // getters\n  getOperator(type, name) {\n    return type in this.operators ? this.operators[type][name] || null : null;\n  }\n}\n// global context\nconst GLOBAL_CONTEXT = Context.init();\n/**\n * Register fully specified operators for the given operator class.\n *\n * @param type The operator type\n * @param operators Map of the operators\n */\nexport function useOperators(type, operators) {\n  for (const [name, fn] of Object.entries(operators)) {\n    assert(isFunction(fn) && isOperator(name), `'${name}' is not a valid operator`);\n    const currentFn = getOperator(type, name, null);\n    assert(!currentFn || fn === currentFn, `${name} already exists for '${type}' operators. Cannot change operator function once registered.`);\n  }\n  // toss the operator salad :)\n  switch (type) {\n    case OperatorType.ACCUMULATOR:\n      GLOBAL_CONTEXT.addAccumulatorOps(operators);\n      break;\n    case OperatorType.EXPRESSION:\n      GLOBAL_CONTEXT.addExpressionOps(operators);\n      break;\n    case OperatorType.PIPELINE:\n      GLOBAL_CONTEXT.addPipelineOps(operators);\n      break;\n    case OperatorType.PROJECTION:\n      GLOBAL_CONTEXT.addProjectionOps(operators);\n      break;\n    case OperatorType.QUERY:\n      GLOBAL_CONTEXT.addQueryOps(operators);\n      break;\n    case OperatorType.WINDOW:\n      GLOBAL_CONTEXT.addWindowOps(operators);\n      break;\n  }\n}\n/**\n * Overrides the current global context with this new one.\n *\n * @param context The new context to override the global one with.\n */\n// export const setGlobalContext = (context: Context): void => {\n//   GLOBAL_CONTEXT = context;\n// };\n/**\n * Returns the operator function or undefined if it is not found\n * @param type Type of operator\n * @param operator Name of the operator\n */\nexport function getOperator(type, operator, options) {\n  const {\n    context: ctx,\n    useGlobalContext: fallback\n  } = options || {};\n  const fn = ctx ? ctx.getOperator(type, operator) : null;\n  return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type, operator) : fn;\n}\n/* eslint-disable unused-imports/no-unused-vars-ts */\n/**\n * Implementation of system variables\n * @type {Object}\n */\nconst systemVariables = {\n  $$ROOT(_obj, _expr, options) {\n    return options.root;\n  },\n  $$CURRENT(obj, _expr, _options) {\n    return obj;\n  },\n  $$REMOVE(_obj, _expr, _options) {\n    return undefined;\n  },\n  $$NOW(_obj, _expr, options) {\n    return new Date(options.timestamp);\n  }\n};\n/**\n * Implementation of $redact variables\n *\n * Each function accepts 3 arguments (obj, expr, options)\n *\n * @type {Object}\n */\nconst redactVariables = {\n  $$KEEP(obj, _expr, _options) {\n    return obj;\n  },\n  $$PRUNE(_obj, _expr, _options) {\n    return undefined;\n  },\n  $$DESCEND(obj, expr, options) {\n    // traverse nested documents iff there is a $cond\n    if (!has(expr, \"$cond\")) return obj;\n    let result;\n    for (const [key, current] of Object.entries(obj)) {\n      if (isObjectLike(current)) {\n        if (current instanceof Array) {\n          const array = [];\n          for (let elem of current) {\n            if (isObject(elem)) {\n              elem = redact(elem, expr, options.update(elem));\n            }\n            if (!isNil(elem)) {\n              array.push(elem);\n            }\n          }\n          result = array;\n        } else {\n          result = redact(current, expr, options.update(current));\n        }\n        if (isNil(result)) {\n          delete obj[key]; // pruned result\n        } else {\n          obj[key] = result;\n        }\n      }\n    }\n    return obj;\n  }\n};\n/* eslint-enable unused-imports/no-unused-vars-ts */\n/**\n * Computes the value of the expression on the object for the given operator\n *\n * @param obj the current object from the collection\n * @param expr the expression for the given field\n * @param operator the operator to resolve the field with\n * @param options {Object} extra options\n * @returns {*}\n */\nexport function computeValue(obj, expr, operator, options) {\n  var _a;\n  // ensure valid options exist on first invocation\n  const copts = ComputeOptions.init(options, obj);\n  operator = operator || \"\";\n  if (isOperator(operator)) {\n    // if the field of the object is a valid operator\n    const callExpression = getOperator(OperatorType.EXPRESSION, operator, options);\n    if (callExpression) return callExpression(obj, expr, copts);\n    // we also handle $group accumulator operators\n    const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator, options);\n    if (callAccumulator) {\n      // if object is not an array, first try to compute using the expression\n      if (!(obj instanceof Array)) {\n        obj = computeValue(obj, expr, null, copts);\n        expr = null;\n      }\n      // validate that we have an array\n      assert(obj instanceof Array, `'${operator}' target must be an array.`);\n      // for accumulators, we use the global options since the root is specific to each element within array.\n      return callAccumulator(obj, expr,\n      // reset the root object for accumulators.\n      copts.update(null, copts.local));\n    }\n    // operator was not found\n    throw new MingoError(`operator '${operator}' is not registered`);\n  }\n  // if expr is a string and begins with \"$$\", then we have a variable.\n  //  this can be one of; redact variable, system variable, user-defined variable.\n  //  we check and process them in that order.\n  //\n  // if expr begins only a single \"$\", then it is a path to a field on the object.\n  if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n    // we return redact variables as literals\n    if (has(redactVariables, expr)) {\n      return expr;\n    }\n    // default to root for resolving path.\n    let context = copts.root;\n    // handle selectors with explicit prefix\n    const arr = expr.split(\".\");\n    if (has(systemVariables, arr[0])) {\n      // set 'root' only the first time it is required to be used for all subsequent calls\n      // if it already available on the options, it will be used\n      context = systemVariables[arr[0]](obj, null, copts);\n      expr = expr.slice(arr[0].length + 1); //  +1 for '.'\n    } else if (arr[0].slice(0, 2) === \"$$\") {\n      // handle user-defined variables\n      context = Object.assign({}, copts.variables,\n      // global vars\n      // current item is added before local variables because the binding may be changed.\n      {\n        this: obj\n      }, (_a = copts.local) === null || _a === void 0 ? void 0 : _a.variables // local vars\n      );\n      const prefix = arr[0].slice(2);\n      assert(has(context, prefix), `Use of undefined variable: ${prefix}`);\n      expr = expr.slice(2);\n    } else {\n      // 'expr' is a path to a field on the object.\n      expr = expr.slice(1);\n    }\n    if (expr === \"\") return context;\n    return resolve(context, expr);\n  }\n  // check and return value if already in a resolved state\n  if (isArray(expr)) {\n    return expr.map(item => computeValue(obj, item, null, copts));\n  } else if (isObject(expr)) {\n    const result = {};\n    for (const [key, val] of Object.entries(expr)) {\n      result[key] = computeValue(obj, val, key, copts);\n      // must run ONLY one aggregate operator per expression\n      // if so, return result of the computed value\n      if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some(t => !!getOperator(t, key, options))) {\n        // there should be only one operator\n        assert(Object.keys(expr).length === 1, \"Invalid aggregation expression '\" + JSON.stringify(expr) + \"'\");\n        return result[key];\n      }\n    }\n    return result;\n  }\n  return expr;\n}\n/**\n * Redact an object\n * @param  {Object} obj The object to redact\n * @param  {*} expr The redact expression\n * @param  {*} options  Options for value\n * @return {*} returns the result of the redacted object\n */\nexport function redact(obj, expr, options) {\n  const result = computeValue(obj, expr, null, options);\n  return has(redactVariables, result) ? redactVariables[result](obj, expr, options) : result;\n}","map":{"version":3,"names":["MingoError","assert","has","isArray","isFunction","isNil","isObject","isObjectLike","isOperator","isString","resolve","ProcessingMode","ComputeOptions","constructor","_opts","_root","_local","timestamp","Date","now","update","init","options","root","local","Object","assign","_a","variables","getOptions","freeze","context","Context","from","idKey","collation","processingMode","CLONE_OFF","useStrictMode","scriptEnabled","useGlobalContext","hashFunction","collectionResolver","jsonSchemaValidator","initOptions","OperatorType","ops","operators","ACCUMULATOR","EXPRESSION","PIPELINE","PROJECTION","QUERY","WINDOW","type","entries","addOperators","ctx","name","fn","getOperator","addAccumulatorOps","addExpressionOps","addQueryOps","addPipelineOps","addProjectionOps","addWindowOps","GLOBAL_CONTEXT","useOperators","currentFn","operator","fallback","systemVariables","$$ROOT","_obj","_expr","$$CURRENT","obj","_options","$$REMOVE","undefined","$$NOW","redactVariables","$$KEEP","$$PRUNE","$$DESCEND","expr","result","key","current","Array","array","elem","redact","push","computeValue","copts","callExpression","callAccumulator","length","arr","split","slice","this","prefix","map","item","val","some","t","keys","JSON","stringify"],"sources":["/Users/abdelghanem/Desktop/tasker/node_modules/mingo/dist/esm/core.js"],"sourcesContent":["import { MingoError } from \"./types\";\nimport { assert, has, isArray, isFunction, isNil, isObject, isObjectLike, isOperator, isString, resolve } from \"./util\";\n/**\n * This controls how input and output documents are processed to meet different application needs.\n * Each mode has different trade offs for; immutability, reference sharing, and performance.\n */\nexport var ProcessingMode;\n(function (ProcessingMode) {\n    /**\n     * Clone inputs prior to processing, and the outputs if some objects graphs may be shared.\n     * Use this option to keep input collection immutable and to get distinct output objects.\n     *\n     * Note: This option is expensive and reduces performance.\n     */\n    ProcessingMode[\"CLONE_ALL\"] = \"CLONE_ALL\";\n    /**\n     * Clones inputs prior to processing.\n     * This option will return output objects with shared graphs in their path if specific operators are used.\n     * Use this option to keep the input collection immutable.\n     *\n     */\n    ProcessingMode[\"CLONE_INPUT\"] = \"CLONE_INPUT\";\n    /**\n     * Clones the output to return distinct objects with no shared paths.\n     * This option modifies the input collection and during processing.\n     */\n    ProcessingMode[\"CLONE_OUTPUT\"] = \"CLONE_OUTPUT\";\n    /**\n     * Turn off cloning and modifies the input collection as needed.\n     * This option will also return output objects with shared paths in their graph when specific operators are used.\n     * This option provides the greatest speedup for the biggest tradeoff.\n     * When using the aggregation pipeline, you can use the \"$out\" operator to collect immutable intermediate results.\n     *\n     * @default\n     */\n    ProcessingMode[\"CLONE_OFF\"] = \"CLONE_OFF\";\n})(ProcessingMode || (ProcessingMode = {}));\n/** Custom type to facilitate type checking for global options */\nexport class ComputeOptions {\n    constructor(_opts, \n    /** Reference to the root object when processing subgraphs of the object. */\n    _root, _local, \n    /** The current time in milliseconds. Remains the same throughout all stages of the aggregation pipeline. */\n    timestamp = Date.now()) {\n        this._opts = _opts;\n        this._root = _root;\n        this._local = _local;\n        this.timestamp = timestamp;\n        this.update(_root, _local);\n    }\n    /**\n     * Initialize new ComputeOptions.\n     *\n     * @param options\n     * @param root\n     * @param local\n     * @returns {ComputeOptions}\n     */\n    static init(options, root, local) {\n        return options instanceof ComputeOptions\n            ? new ComputeOptions(options._opts, isNil(options.root) ? root : options.root, Object.assign({}, options.local, local))\n            : new ComputeOptions(options, root, local);\n    }\n    /** Updates the internal mutable state. */\n    update(root, local) {\n        var _a;\n        // NOTE: this is done for efficiency to avoid creating too many intermediate options objects.\n        this._root = root;\n        this._local = local\n            ? Object.assign({}, local, {\n                variables: Object.assign({}, (_a = this._local) === null || _a === void 0 ? void 0 : _a.variables, local === null || local === void 0 ? void 0 : local.variables)\n            })\n            : local;\n        return this;\n    }\n    getOptions() {\n        return Object.freeze(Object.assign(Object.assign({}, this._opts), { context: Context.from(this._opts.context) }));\n    }\n    get root() {\n        return this._root;\n    }\n    get local() {\n        return this._local;\n    }\n    get idKey() {\n        return this._opts.idKey;\n    }\n    get collation() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collation;\n    }\n    get processingMode() {\n        var _a;\n        return ((_a = this._opts) === null || _a === void 0 ? void 0 : _a.processingMode) || ProcessingMode.CLONE_OFF;\n    }\n    get useStrictMode() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useStrictMode;\n    }\n    get scriptEnabled() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.scriptEnabled;\n    }\n    get useGlobalContext() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useGlobalContext;\n    }\n    get hashFunction() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.hashFunction;\n    }\n    get collectionResolver() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collectionResolver;\n    }\n    get jsonSchemaValidator() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.jsonSchemaValidator;\n    }\n    get variables() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.variables;\n    }\n    get context() {\n        var _a;\n        return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.context;\n    }\n}\n/**\n * Creates an Option from another where required keys are initialized.\n * @param options Options\n */\nexport function initOptions(options) {\n    return options instanceof ComputeOptions\n        ? options.getOptions()\n        : Object.freeze(Object.assign(Object.assign({ idKey: \"_id\", scriptEnabled: true, useStrictMode: true, useGlobalContext: true, processingMode: ProcessingMode.CLONE_OFF }, options), { context: (options === null || options === void 0 ? void 0 : options.context)\n                ? Context.from(options === null || options === void 0 ? void 0 : options.context)\n                : Context.init({}) }));\n}\n/**\n * The different groups of operators\n */\nexport var OperatorType;\n(function (OperatorType) {\n    OperatorType[\"ACCUMULATOR\"] = \"accumulator\";\n    OperatorType[\"EXPRESSION\"] = \"expression\";\n    OperatorType[\"PIPELINE\"] = \"pipeline\";\n    OperatorType[\"PROJECTION\"] = \"projection\";\n    OperatorType[\"QUERY\"] = \"query\";\n    OperatorType[\"WINDOW\"] = \"window\";\n})(OperatorType || (OperatorType = {}));\nexport class Context {\n    constructor(ops) {\n        this.operators = {\n            [OperatorType.ACCUMULATOR]: {},\n            [OperatorType.EXPRESSION]: {},\n            [OperatorType.PIPELINE]: {},\n            [OperatorType.PROJECTION]: {},\n            [OperatorType.QUERY]: {},\n            [OperatorType.WINDOW]: {}\n        };\n        for (const [type, operators] of Object.entries(ops)) {\n            this.addOperators(type, operators);\n        }\n    }\n    static init(ops = {}) {\n        return new Context(ops);\n    }\n    static from(ctx) {\n        return new Context(ctx.operators);\n    }\n    addOperators(type, ops) {\n        for (const [name, fn] of Object.entries(ops)) {\n            if (!this.getOperator(type, name)) {\n                this.operators[type][name] = fn;\n            }\n        }\n        return this;\n    }\n    // register\n    addAccumulatorOps(ops) {\n        return this.addOperators(OperatorType.ACCUMULATOR, ops);\n    }\n    addExpressionOps(ops) {\n        return this.addOperators(OperatorType.EXPRESSION, ops);\n    }\n    addQueryOps(ops) {\n        return this.addOperators(OperatorType.QUERY, ops);\n    }\n    addPipelineOps(ops) {\n        return this.addOperators(OperatorType.PIPELINE, ops);\n    }\n    addProjectionOps(ops) {\n        return this.addOperators(OperatorType.PROJECTION, ops);\n    }\n    addWindowOps(ops) {\n        return this.addOperators(OperatorType.WINDOW, ops);\n    }\n    // getters\n    getOperator(type, name) {\n        return type in this.operators ? this.operators[type][name] || null : null;\n    }\n}\n// global context\nconst GLOBAL_CONTEXT = Context.init();\n/**\n * Register fully specified operators for the given operator class.\n *\n * @param type The operator type\n * @param operators Map of the operators\n */\nexport function useOperators(type, operators) {\n    for (const [name, fn] of Object.entries(operators)) {\n        assert(isFunction(fn) && isOperator(name), `'${name}' is not a valid operator`);\n        const currentFn = getOperator(type, name, null);\n        assert(!currentFn || fn === currentFn, `${name} already exists for '${type}' operators. Cannot change operator function once registered.`);\n    }\n    // toss the operator salad :)\n    switch (type) {\n        case OperatorType.ACCUMULATOR:\n            GLOBAL_CONTEXT.addAccumulatorOps(operators);\n            break;\n        case OperatorType.EXPRESSION:\n            GLOBAL_CONTEXT.addExpressionOps(operators);\n            break;\n        case OperatorType.PIPELINE:\n            GLOBAL_CONTEXT.addPipelineOps(operators);\n            break;\n        case OperatorType.PROJECTION:\n            GLOBAL_CONTEXT.addProjectionOps(operators);\n            break;\n        case OperatorType.QUERY:\n            GLOBAL_CONTEXT.addQueryOps(operators);\n            break;\n        case OperatorType.WINDOW:\n            GLOBAL_CONTEXT.addWindowOps(operators);\n            break;\n    }\n}\n/**\n * Overrides the current global context with this new one.\n *\n * @param context The new context to override the global one with.\n */\n// export const setGlobalContext = (context: Context): void => {\n//   GLOBAL_CONTEXT = context;\n// };\n/**\n * Returns the operator function or undefined if it is not found\n * @param type Type of operator\n * @param operator Name of the operator\n */\nexport function getOperator(type, operator, options) {\n    const { context: ctx, useGlobalContext: fallback } = options || {};\n    const fn = ctx ? ctx.getOperator(type, operator) : null;\n    return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type, operator) : fn;\n}\n/* eslint-disable unused-imports/no-unused-vars-ts */\n/**\n * Implementation of system variables\n * @type {Object}\n */\nconst systemVariables = {\n    $$ROOT(_obj, _expr, options) {\n        return options.root;\n    },\n    $$CURRENT(obj, _expr, _options) {\n        return obj;\n    },\n    $$REMOVE(_obj, _expr, _options) {\n        return undefined;\n    },\n    $$NOW(_obj, _expr, options) {\n        return new Date(options.timestamp);\n    }\n};\n/**\n * Implementation of $redact variables\n *\n * Each function accepts 3 arguments (obj, expr, options)\n *\n * @type {Object}\n */\nconst redactVariables = {\n    $$KEEP(obj, _expr, _options) {\n        return obj;\n    },\n    $$PRUNE(_obj, _expr, _options) {\n        return undefined;\n    },\n    $$DESCEND(obj, expr, options) {\n        // traverse nested documents iff there is a $cond\n        if (!has(expr, \"$cond\"))\n            return obj;\n        let result;\n        for (const [key, current] of Object.entries(obj)) {\n            if (isObjectLike(current)) {\n                if (current instanceof Array) {\n                    const array = [];\n                    for (let elem of current) {\n                        if (isObject(elem)) {\n                            elem = redact(elem, expr, options.update(elem));\n                        }\n                        if (!isNil(elem)) {\n                            array.push(elem);\n                        }\n                    }\n                    result = array;\n                }\n                else {\n                    result = redact(current, expr, options.update(current));\n                }\n                if (isNil(result)) {\n                    delete obj[key]; // pruned result\n                }\n                else {\n                    obj[key] = result;\n                }\n            }\n        }\n        return obj;\n    }\n};\n/* eslint-enable unused-imports/no-unused-vars-ts */\n/**\n * Computes the value of the expression on the object for the given operator\n *\n * @param obj the current object from the collection\n * @param expr the expression for the given field\n * @param operator the operator to resolve the field with\n * @param options {Object} extra options\n * @returns {*}\n */\nexport function computeValue(obj, expr, operator, options) {\n    var _a;\n    // ensure valid options exist on first invocation\n    const copts = ComputeOptions.init(options, obj);\n    operator = operator || \"\";\n    if (isOperator(operator)) {\n        // if the field of the object is a valid operator\n        const callExpression = getOperator(OperatorType.EXPRESSION, operator, options);\n        if (callExpression)\n            return callExpression(obj, expr, copts);\n        // we also handle $group accumulator operators\n        const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator, options);\n        if (callAccumulator) {\n            // if object is not an array, first try to compute using the expression\n            if (!(obj instanceof Array)) {\n                obj = computeValue(obj, expr, null, copts);\n                expr = null;\n            }\n            // validate that we have an array\n            assert(obj instanceof Array, `'${operator}' target must be an array.`);\n            // for accumulators, we use the global options since the root is specific to each element within array.\n            return callAccumulator(obj, expr, \n            // reset the root object for accumulators.\n            copts.update(null, copts.local));\n        }\n        // operator was not found\n        throw new MingoError(`operator '${operator}' is not registered`);\n    }\n    // if expr is a string and begins with \"$$\", then we have a variable.\n    //  this can be one of; redact variable, system variable, user-defined variable.\n    //  we check and process them in that order.\n    //\n    // if expr begins only a single \"$\", then it is a path to a field on the object.\n    if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n        // we return redact variables as literals\n        if (has(redactVariables, expr)) {\n            return expr;\n        }\n        // default to root for resolving path.\n        let context = copts.root;\n        // handle selectors with explicit prefix\n        const arr = expr.split(\".\");\n        if (has(systemVariables, arr[0])) {\n            // set 'root' only the first time it is required to be used for all subsequent calls\n            // if it already available on the options, it will be used\n            context = systemVariables[arr[0]](obj, null, copts);\n            expr = expr.slice(arr[0].length + 1); //  +1 for '.'\n        }\n        else if (arr[0].slice(0, 2) === \"$$\") {\n            // handle user-defined variables\n            context = Object.assign({}, copts.variables, // global vars\n            // current item is added before local variables because the binding may be changed.\n            { this: obj }, (_a = copts.local) === null || _a === void 0 ? void 0 : _a.variables // local vars\n            );\n            const prefix = arr[0].slice(2);\n            assert(has(context, prefix), `Use of undefined variable: ${prefix}`);\n            expr = expr.slice(2);\n        }\n        else {\n            // 'expr' is a path to a field on the object.\n            expr = expr.slice(1);\n        }\n        if (expr === \"\")\n            return context;\n        return resolve(context, expr);\n    }\n    // check and return value if already in a resolved state\n    if (isArray(expr)) {\n        return expr.map((item) => computeValue(obj, item, null, copts));\n    }\n    else if (isObject(expr)) {\n        const result = {};\n        for (const [key, val] of Object.entries(expr)) {\n            result[key] = computeValue(obj, val, key, copts);\n            // must run ONLY one aggregate operator per expression\n            // if so, return result of the computed value\n            if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some(t => !!getOperator(t, key, options))) {\n                // there should be only one operator\n                assert(Object.keys(expr).length === 1, \"Invalid aggregation expression '\" + JSON.stringify(expr) + \"'\");\n                return result[key];\n            }\n        }\n        return result;\n    }\n    return expr;\n}\n/**\n * Redact an object\n * @param  {Object} obj The object to redact\n * @param  {*} expr The redact expression\n * @param  {*} options  Options for value\n * @return {*} returns the result of the redacted object\n */\nexport function redact(obj, expr, options) {\n    const result = computeValue(obj, expr, null, options);\n    return has(redactVariables, result)\n        ? redactVariables[result](obj, expr, options)\n        : result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}